
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = value;
            let child_ctx = info.ctx;
            if (key !== undefined) {
                child_ctx = child_ctx.slice();
                child_ctx[key] = value;
            }
            const block = type && (info.current = type)(child_ctx);
            let needs_flush = false;
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                needs_flush = true;
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
            if (needs_flush) {
                flush();
            }
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
                if (!info.hasCatch) {
                    throw error;
                }
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = promise;
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.29.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function getAugmentedNamespace(n) {
    	if (n.__esModule) return n;
    	var a = Object.defineProperty({}, '__esModule', {value: true});
    	Object.keys(n).forEach(function (k) {
    		var d = Object.getOwnPropertyDescriptor(n, k);
    		Object.defineProperty(a, k, d.get ? d : {
    			enumerable: true,
    			get: function () {
    				return n[k];
    			}
    		});
    	});
    	return a;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    //
    // Polyfills for legacy environments
    //
    /*
     * Support Android 4.4.x
     */
    if (!ArrayBuffer.isView) {
        ArrayBuffer.isView = function (a) {
            return a !== null && typeof (a) === 'object' && a.buffer instanceof ArrayBuffer;
        };
    }

    var index_esm = createCommonjsModule(function (module, exports) {
    function apply(src, tar) {
    	tar.headers = src.headers || {};
    	tar.statusMessage = src.statusText;
    	tar.statusCode = src.status;
    	tar.data = src.response;
    }

    exports.send = function (method, uri, opts) {
    	return new Promise(function (res, rej) {
    		opts = opts || {};
    		var k, str, tmp, arr;
    		var req = new XMLHttpRequest;
    		var headers = opts.headers || {};

    		// IE compatible
    		if (opts.timeout) req.timeout = opts.timeout;
    		req.ontimeout = req.onerror = function (err) {
    			err.timeout = err.type == 'timeout';
    			rej(err);
    		};

    		req.open(method, uri.href || uri);

    		req.onload = function () {
    			arr = req.getAllResponseHeaders().trim().split(/[\r\n]+/);
    			apply(req, req); //=> req.headers

    			while (tmp = arr.shift()) {
    				tmp = tmp.split(': ');
    				req.headers[tmp.shift().toLowerCase()] = tmp.join(': ');
    			}

    			tmp = req.headers['content-type'];
    			if (tmp && !!~tmp.indexOf('application/json')) {
    				try {
    					req.data = JSON.parse(req.data, opts.reviver);
    				} catch (err) {
    					apply(req, err);
    					return rej(err);
    				}
    			}

    			(req.status >= 400 ? rej : res)(req);
    		};

    		if ((str = opts.body) && typeof str == 'object') {
    			headers['content-type'] = 'application/json';
    			str = JSON.stringify(str);
    		}

    		req.withCredentials = !!opts.withCredentials;

    		for (k in headers) {
    			req.setRequestHeader(k, headers[k]);
    		}

    		req.send(str);
    	});
    };

    exports.get = exports.send.bind(exports.send, 'GET');
    exports.post = exports.send.bind(exports.send, 'POST');
    exports.patch = exports.send.bind(exports.send, 'PATCH');
    exports.del = exports.send.bind(exports.send, 'DELETE');
    exports.put = exports.send.bind(exports.send, 'PUT');
    });

    var ServerError_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerError = void 0;
    var ServerError = /** @class */ (function (_super) {
        __extends(ServerError, _super);
        function ServerError(code, message) {
            var _this = _super.call(this, message) || this;
            _this.name = "ServerError";
            _this.code = code;
            return _this;
        }
        return ServerError;
    }(Error));
    exports.ServerError = ServerError;

    });

    var decode_1 = createCommonjsModule(function (module, exports) {
    /**
     * Copyright (c) 2014 Ion Drive Software Ltd.
     * https://github.com/darrachequesne/notepack/
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Patch for Colyseus:
     * -------------------
     *
     * added `offset` on Decoder constructor, for messages arriving with a code
     * before actual msgpack data
     */
    function Decoder(buffer, offset) {
        this._offset = offset;
        if (buffer instanceof ArrayBuffer) {
            this._buffer = buffer;
            this._view = new DataView(this._buffer);
        }
        else if (ArrayBuffer.isView(buffer)) {
            this._buffer = buffer.buffer;
            this._view = new DataView(this._buffer, buffer.byteOffset, buffer.byteLength);
        }
        else {
            throw new Error('Invalid argument');
        }
    }
    function utf8Read(view, offset, length) {
        var string = '', chr = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = view.getUint8(i);
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (view.getUint8(++i) & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((view.getUint8(++i) & 0x3f) << 6) |
                    ((view.getUint8(++i) & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((view.getUint8(++i) & 0x3f) << 12) |
                    ((view.getUint8(++i) & 0x3f) << 6) |
                    ((view.getUint8(++i) & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            throw new Error('Invalid byte ' + byte.toString(16));
        }
        return string;
    }
    Decoder.prototype._array = function (length) {
        var value = new Array(length);
        for (var i = 0; i < length; i++) {
            value[i] = this._parse();
        }
        return value;
    };
    Decoder.prototype._map = function (length) {
        var key = '', value = {};
        for (var i = 0; i < length; i++) {
            key = this._parse();
            value[key] = this._parse();
        }
        return value;
    };
    Decoder.prototype._str = function (length) {
        var value = utf8Read(this._view, this._offset, length);
        this._offset += length;
        return value;
    };
    Decoder.prototype._bin = function (length) {
        var value = this._buffer.slice(this._offset, this._offset + length);
        this._offset += length;
        return value;
    };
    Decoder.prototype._parse = function () {
        var prefix = this._view.getUint8(this._offset++);
        var value, length = 0, type = 0, hi = 0, lo = 0;
        if (prefix < 0xc0) {
            // positive fixint
            if (prefix < 0x80) {
                return prefix;
            }
            // fixmap
            if (prefix < 0x90) {
                return this._map(prefix & 0x0f);
            }
            // fixarray
            if (prefix < 0xa0) {
                return this._array(prefix & 0x0f);
            }
            // fixstr
            return this._str(prefix & 0x1f);
        }
        // negative fixint
        if (prefix > 0xdf) {
            return (0xff - prefix + 1) * -1;
        }
        switch (prefix) {
            // nil
            case 0xc0:
                return null;
            // false
            case 0xc2:
                return false;
            // true
            case 0xc3:
                return true;
            // bin
            case 0xc4:
                length = this._view.getUint8(this._offset);
                this._offset += 1;
                return this._bin(length);
            case 0xc5:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._bin(length);
            case 0xc6:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._bin(length);
            // ext
            case 0xc7:
                length = this._view.getUint8(this._offset);
                type = this._view.getInt8(this._offset + 1);
                this._offset += 2;
                return [type, this._bin(length)];
            case 0xc8:
                length = this._view.getUint16(this._offset);
                type = this._view.getInt8(this._offset + 2);
                this._offset += 3;
                return [type, this._bin(length)];
            case 0xc9:
                length = this._view.getUint32(this._offset);
                type = this._view.getInt8(this._offset + 4);
                this._offset += 5;
                return [type, this._bin(length)];
            // float
            case 0xca:
                value = this._view.getFloat32(this._offset);
                this._offset += 4;
                return value;
            case 0xcb:
                value = this._view.getFloat64(this._offset);
                this._offset += 8;
                return value;
            // uint
            case 0xcc:
                value = this._view.getUint8(this._offset);
                this._offset += 1;
                return value;
            case 0xcd:
                value = this._view.getUint16(this._offset);
                this._offset += 2;
                return value;
            case 0xce:
                value = this._view.getUint32(this._offset);
                this._offset += 4;
                return value;
            case 0xcf:
                hi = this._view.getUint32(this._offset) * Math.pow(2, 32);
                lo = this._view.getUint32(this._offset + 4);
                this._offset += 8;
                return hi + lo;
            // int
            case 0xd0:
                value = this._view.getInt8(this._offset);
                this._offset += 1;
                return value;
            case 0xd1:
                value = this._view.getInt16(this._offset);
                this._offset += 2;
                return value;
            case 0xd2:
                value = this._view.getInt32(this._offset);
                this._offset += 4;
                return value;
            case 0xd3:
                hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                lo = this._view.getUint32(this._offset + 4);
                this._offset += 8;
                return hi + lo;
            // fixext
            case 0xd4:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                if (type === 0x00) {
                    this._offset += 1;
                    return void 0;
                }
                return [type, this._bin(1)];
            case 0xd5:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(2)];
            case 0xd6:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(4)];
            case 0xd7:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                if (type === 0x00) {
                    hi = this._view.getInt32(this._offset) * Math.pow(2, 32);
                    lo = this._view.getUint32(this._offset + 4);
                    this._offset += 8;
                    return new Date(hi + lo);
                }
                return [type, this._bin(8)];
            case 0xd8:
                type = this._view.getInt8(this._offset);
                this._offset += 1;
                return [type, this._bin(16)];
            // str
            case 0xd9:
                length = this._view.getUint8(this._offset);
                this._offset += 1;
                return this._str(length);
            case 0xda:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._str(length);
            case 0xdb:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._str(length);
            // array
            case 0xdc:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._array(length);
            case 0xdd:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._array(length);
            // map
            case 0xde:
                length = this._view.getUint16(this._offset);
                this._offset += 2;
                return this._map(length);
            case 0xdf:
                length = this._view.getUint32(this._offset);
                this._offset += 4;
                return this._map(length);
        }
        throw new Error('Could not parse');
    };
    function decode(buffer, offset) {
        if (offset === void 0) { offset = 0; }
        var decoder = new Decoder(buffer, offset);
        var value = decoder._parse();
        if (decoder._offset !== buffer.byteLength) {
            throw new Error((buffer.byteLength - decoder._offset) + ' trailing bytes');
        }
        return value;
    }
    exports.default = decode;

    });

    var encode_1 = createCommonjsModule(function (module, exports) {
    /**
     * Copyright (c) 2014 Ion Drive Software Ltd.
     * https://github.com/darrachequesne/notepack/
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE.
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    function utf8Write(view, offset, str) {
        var c = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                view.setUint8(offset++, c);
            }
            else if (c < 0x800) {
                view.setUint8(offset++, 0xc0 | (c >> 6));
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
            else if (c < 0xd800 || c >= 0xe000) {
                view.setUint8(offset++, 0xe0 | (c >> 12));
                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
            else {
                i++;
                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                view.setUint8(offset++, 0xf0 | (c >> 18));
                view.setUint8(offset++, 0x80 | (c >> 12) & 0x3f);
                view.setUint8(offset++, 0x80 | (c >> 6) & 0x3f);
                view.setUint8(offset++, 0x80 | (c & 0x3f));
            }
        }
    }
    function utf8Length(str) {
        var c = 0, length = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                length += 1;
            }
            else if (c < 0x800) {
                length += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                length += 3;
            }
            else {
                i++;
                length += 4;
            }
        }
        return length;
    }
    function _encode(bytes, defers, value) {
        var type = typeof value, i = 0, l = 0, hi = 0, lo = 0, length = 0, size = 0;
        if (type === 'string') {
            length = utf8Length(value);
            // fixstr
            if (length < 0x20) {
                bytes.push(length | 0xa0);
                size = 1;
            }
            // str 8
            else if (length < 0x100) {
                bytes.push(0xd9, length);
                size = 2;
            }
            // str 16
            else if (length < 0x10000) {
                bytes.push(0xda, length >> 8, length);
                size = 3;
            }
            // str 32
            else if (length < 0x100000000) {
                bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);
                size = 5;
            }
            else {
                throw new Error('String too long');
            }
            defers.push({ _str: value, _length: length, _offset: bytes.length });
            return size + length;
        }
        if (type === 'number') {
            // TODO: encode to float 32?
            // float 64
            if (Math.floor(value) !== value || !isFinite(value)) {
                bytes.push(0xcb);
                defers.push({ _float: value, _length: 8, _offset: bytes.length });
                return 9;
            }
            if (value >= 0) {
                // positive fixnum
                if (value < 0x80) {
                    bytes.push(value);
                    return 1;
                }
                // uint 8
                if (value < 0x100) {
                    bytes.push(0xcc, value);
                    return 2;
                }
                // uint 16
                if (value < 0x10000) {
                    bytes.push(0xcd, value >> 8, value);
                    return 3;
                }
                // uint 32
                if (value < 0x100000000) {
                    bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);
                    return 5;
                }
                // uint 64
                hi = (value / Math.pow(2, 32)) >> 0;
                lo = value >>> 0;
                bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 9;
            }
            else {
                // negative fixnum
                if (value >= -0x20) {
                    bytes.push(value);
                    return 1;
                }
                // int 8
                if (value >= -0x80) {
                    bytes.push(0xd0, value);
                    return 2;
                }
                // int 16
                if (value >= -0x8000) {
                    bytes.push(0xd1, value >> 8, value);
                    return 3;
                }
                // int 32
                if (value >= -0x80000000) {
                    bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);
                    return 5;
                }
                // int 64
                hi = Math.floor(value / Math.pow(2, 32));
                lo = value >>> 0;
                bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 9;
            }
        }
        if (type === 'object') {
            // nil
            if (value === null) {
                bytes.push(0xc0);
                return 1;
            }
            if (Array.isArray(value)) {
                length = value.length;
                // fixarray
                if (length < 0x10) {
                    bytes.push(length | 0x90);
                    size = 1;
                }
                // array 16
                else if (length < 0x10000) {
                    bytes.push(0xdc, length >> 8, length);
                    size = 3;
                }
                // array 32
                else if (length < 0x100000000) {
                    bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);
                    size = 5;
                }
                else {
                    throw new Error('Array too large');
                }
                for (i = 0; i < length; i++) {
                    size += _encode(bytes, defers, value[i]);
                }
                return size;
            }
            // fixext 8 / Date
            if (value instanceof Date) {
                var time = value.getTime();
                hi = Math.floor(time / Math.pow(2, 32));
                lo = time >>> 0;
                bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);
                return 10;
            }
            if (value instanceof ArrayBuffer) {
                length = value.byteLength;
                // bin 8
                if (length < 0x100) {
                    bytes.push(0xc4, length);
                    size = 2;
                }
                else 
                // bin 16
                if (length < 0x10000) {
                    bytes.push(0xc5, length >> 8, length);
                    size = 3;
                }
                else 
                // bin 32
                if (length < 0x100000000) {
                    bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);
                    size = 5;
                }
                else {
                    throw new Error('Buffer too large');
                }
                defers.push({ _bin: value, _length: length, _offset: bytes.length });
                return size + length;
            }
            if (typeof value.toJSON === 'function') {
                return _encode(bytes, defers, value.toJSON());
            }
            var keys = [], key = '';
            var allKeys = Object.keys(value);
            for (i = 0, l = allKeys.length; i < l; i++) {
                key = allKeys[i];
                if (typeof value[key] !== 'function') {
                    keys.push(key);
                }
            }
            length = keys.length;
            // fixmap
            if (length < 0x10) {
                bytes.push(length | 0x80);
                size = 1;
            }
            // map 16
            else if (length < 0x10000) {
                bytes.push(0xde, length >> 8, length);
                size = 3;
            }
            // map 32
            else if (length < 0x100000000) {
                bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);
                size = 5;
            }
            else {
                throw new Error('Object too large');
            }
            for (i = 0; i < length; i++) {
                key = keys[i];
                size += _encode(bytes, defers, key);
                size += _encode(bytes, defers, value[key]);
            }
            return size;
        }
        // false/true
        if (type === 'boolean') {
            bytes.push(value ? 0xc3 : 0xc2);
            return 1;
        }
        // fixext 1 / undefined
        if (type === 'undefined') {
            bytes.push(0xd4, 0, 0);
            return 3;
        }
        throw new Error('Could not encode');
    }
    function encode(value) {
        var bytes = [];
        var defers = [];
        var size = _encode(bytes, defers, value);
        var buf = new ArrayBuffer(size);
        var view = new DataView(buf);
        var deferIndex = 0;
        var deferWritten = 0;
        var nextOffset = -1;
        if (defers.length > 0) {
            nextOffset = defers[0]._offset;
        }
        var defer, deferLength = 0, offset = 0;
        for (var i = 0, l = bytes.length; i < l; i++) {
            view.setUint8(deferWritten + i, bytes[i]);
            if (i + 1 !== nextOffset) {
                continue;
            }
            defer = defers[deferIndex];
            deferLength = defer._length;
            offset = deferWritten + nextOffset;
            if (defer._bin) {
                var bin = new Uint8Array(defer._bin);
                for (var j = 0; j < deferLength; j++) {
                    view.setUint8(offset + j, bin[j]);
                }
            }
            else if (defer._str) {
                utf8Write(view, offset, defer._str);
            }
            else if (defer._float !== undefined) {
                view.setFloat64(offset, defer._float);
            }
            deferIndex++;
            deferWritten += deferLength;
            if (defers[deferIndex]) {
                nextOffset = defers[deferIndex]._offset;
            }
        }
        return buf;
    }
    exports.default = encode;

    });

    var msgpack = createCommonjsModule(function (module, exports) {
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var decode_1$1 = __importDefault(decode_1);
    var encode_1$1 = __importDefault(encode_1);
    exports.decode = decode_1$1.default;
    exports.encode = encode_1$1.default;

    });

    var lib = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var EventEmitter = /** @class */ (function () {
        function EventEmitter() {
            this.handlers = [];
        }
        EventEmitter.prototype.register = function (cb, once) {
            this.handlers.push(cb);
            return this;
        };
        EventEmitter.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.handlers.forEach(function (handler) { return handler.apply(void 0, args); });
        };
        EventEmitter.prototype.invokeAsync = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Promise.all(this.handlers.map(function (handler) { return handler.apply(void 0, args); }));
        };
        EventEmitter.prototype.remove = function (cb) {
            var index = this.handlers.indexOf(cb);
            this.handlers[index] = this.handlers[this.handlers.length - 1];
            this.handlers.pop();
        };
        EventEmitter.prototype.clear = function () {
            this.handlers = [];
        };
        return EventEmitter;
    }());
    exports.EventEmitter = EventEmitter;
    function createSignal() {
        var emitter = new EventEmitter();
        function register(cb) {
            return emitter.register(cb, this === null);
        }
        register.once = function (cb) {
            var callback = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                cb.apply(void 0, args);
                emitter.remove(callback);
            };
            emitter.register(callback);
        };
        register.remove = function (cb) { return emitter.remove(cb); };
        register.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return emitter.invoke.apply(emitter, args);
        };
        register.invokeAsync = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return emitter.invokeAsync.apply(emitter, args);
        };
        register.clear = function () { return emitter.clear(); };
        return register;
    }
    exports.createSignal = createSignal;
    });

    let createNanoEvents = () => ({
      events: {},
      emit (event, ...args) {
        for (let i of this.events[event] || []) {
          i(...args);
        }
      },
      on (event, cb) {
    (this.events[event] = this.events[event] || []).push(cb);
        return () => (this.events[event] = this.events[event].filter(i => i !== cb))
      }
    });

    var nanoevents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        createNanoEvents: createNanoEvents
    });

    var backoff_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports,"__esModule",{value:true});exports.createBackoff=createBackoff;var backoff={exponential:function exponential(attempt,delay){return Math.floor(Math.random()*Math.pow(2,attempt)*delay);},fibonacci:function fibonacci(attempt,delay){var current=1;if(attempt>current){var prev=1,current=2;for(var index=2;index<attempt;index++){var next=prev+current;prev=current;current=next;}}return Math.floor(Math.random()*current*delay);}};function createBackoff(type,options){return new Backoff(backoff[type],options);}function Backoff(func,options){this.func=func;this.attempts=0;this.delay=typeof options.initialDelay!=="undefined"?options.initialDelay:100;}Backoff.prototype.backoff=function(){setTimeout(this.onReady,this.func(++this.attempts,this.delay));};
    });

    var _nodeResolve_empty = {};

    var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        'default': _nodeResolve_empty
    });

    var require$$0 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

    var lib$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var createBackoff=backoff_1.createBackoff;var WebSocketImpl=typeof WebSocket!=="undefined"?WebSocket:require$$0;var WebSocketClient=function(){/**
       * @param url DOMString The URL to which to connect; this should be the URL to which the WebSocket server will respond.
       * @param protocols DOMString|DOMString[] Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol). If you don't specify a protocol string, an empty string is assumed.
       */function WebSocketClient(url,protocols){var options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};_classCallCheck(this,WebSocketClient);this.url=url;this.protocols=protocols;this.reconnectEnabled=true;this.listeners={};this.backoff=createBackoff(options.backoff||'exponential',options);this.backoff.onReady=this.onBackoffReady.bind(this);if(typeof options.connect==="undefined"||options.connect){this.open();}}_createClass(WebSocketClient,[{key:'open',value:function open(){var reconnect=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;this.isReconnect=reconnect;// keep binaryType used on previous WebSocket connection
    var binaryType=this.ws&&this.ws.binaryType;this.ws=new WebSocketImpl(this.url,this.protocols);this.ws.onclose=this.onCloseCallback.bind(this);this.ws.onerror=this.onErrorCallback.bind(this);this.ws.onmessage=this.onMessageCallback.bind(this);this.ws.onopen=this.onOpenCallback.bind(this);if(binaryType){this.ws.binaryType=binaryType;}}/**
       * @ignore
       */},{key:'onBackoffReady',value:function onBackoffReady(number,delay){// console.log("onBackoffReady", number + ' ' + delay + 'ms');
    this.open(true);}/**
       * @ignore
       */},{key:'onCloseCallback',value:function onCloseCallback(e){if(!this.isReconnect&&this.listeners['onclose']){this.listeners['onclose'].apply(null,arguments);}if(this.reconnectEnabled&&e.code<3000){this.backoff.backoff();}}/**
       * @ignore
       */},{key:'onErrorCallback',value:function onErrorCallback(){if(this.listeners['onerror']){this.listeners['onerror'].apply(null,arguments);}}/**
       * @ignore
       */},{key:'onMessageCallback',value:function onMessageCallback(){if(this.listeners['onmessage']){this.listeners['onmessage'].apply(null,arguments);}}/**
       * @ignore
       */},{key:'onOpenCallback',value:function onOpenCallback(){if(this.listeners['onopen']){this.listeners['onopen'].apply(null,arguments);}if(this.isReconnect&&this.listeners['onreconnect']){this.listeners['onreconnect'].apply(null,arguments);}this.isReconnect=false;}/**
       * The number of bytes of data that have been queued using calls to send()
       * but not yet transmitted to the network. This value does not reset to zero
       * when the connection is closed; if you keep calling send(), this will
       * continue to climb.
       *
       * @type unsigned long
       * @readonly
       */},{key:'close',/**
       * Closes the WebSocket connection or connection attempt, if any. If the
       * connection is already CLOSED, this method does nothing.
       *
       * @param code A numeric value indicating the status code explaining why the connection is being closed. If this parameter is not specified, a default value of 1000 (indicating a normal "transaction complete" closure) is assumed. See the list of status codes on the CloseEvent page for permitted values.
       * @param reason A human-readable string explaining why the connection is closing. This string must be no longer than 123 bytes of UTF-8 text (not characters).
       *
       * @return void
       */value:function close(code,reason){if(typeof code=='undefined'){code=1000;}this.reconnectEnabled=false;this.ws.close(code,reason);}/**
       * Transmits data to the server over the WebSocket connection.
       * @param data DOMString|ArrayBuffer|Blob
       * @return void
       */},{key:'send',value:function send(data){this.ws.send(data);}/**
       * An event listener to be called when the WebSocket connection's readyState changes to CLOSED. The listener receives a CloseEvent named "close".
       * @param listener EventListener
       */},{key:'bufferedAmount',get:function get(){return this.ws.bufferedAmount;}/**
       * The current state of the connection; this is one of the Ready state constants.
       * @type unsigned short
       * @readonly
       */},{key:'readyState',get:function get(){return this.ws.readyState;}/**
       * A string indicating the type of binary data being transmitted by the
       * connection. This should be either "blob" if DOM Blob objects are being
       * used or "arraybuffer" if ArrayBuffer objects are being used.
       * @type DOMString
       */},{key:'binaryType',get:function get(){return this.ws.binaryType;},set:function set(binaryType){this.ws.binaryType=binaryType;}/**
       * The extensions selected by the server. This is currently only the empty
       * string or a list of extensions as negotiated by the connection.
       * @type DOMString
       */},{key:'extensions',get:function get(){return this.ws.extensions;},set:function set(extensions){this.ws.extensions=extensions;}/**
       * A string indicating the name of the sub-protocol the server selected;
       * this will be one of the strings specified in the protocols parameter when
       * creating the WebSocket object.
       * @type DOMString
       */},{key:'protocol',get:function get(){return this.ws.protocol;},set:function set(protocol){this.ws.protocol=protocol;}},{key:'onclose',set:function set(listener){this.listeners['onclose']=listener;},get:function get(){return this.listeners['onclose'];}/**
       * An event listener to be called when an error occurs. This is a simple event named "error".
       * @param listener EventListener
       */},{key:'onerror',set:function set(listener){this.listeners['onerror']=listener;},get:function get(){return this.listeners['onerror'];}/**
       * An event listener to be called when a message is received from the server. The listener receives a MessageEvent named "message".
       * @param listener EventListener
       */},{key:'onmessage',set:function set(listener){this.listeners['onmessage']=listener;},get:function get(){return this.listeners['onmessage'];}/**
       * An event listener to be called when the WebSocket connection's readyState changes to OPEN; this indicates that the connection is ready to send and receive data. The event is a simple one with the name "open".
       * @param listener EventListener
       */},{key:'onopen',set:function set(listener){this.listeners['onopen']=listener;},get:function get(){return this.listeners['onopen'];}/**
       * @param listener EventListener
       */},{key:'onreconnect',set:function set(listener){this.listeners['onreconnect']=listener;},get:function get(){return this.listeners['onreconnect'];}}]);return WebSocketClient;}();/**
     * The connection is not yet open.
     */WebSocketClient.CONNECTING=WebSocketImpl.CONNECTING;/**
     * The connection is open and ready to communicate.
     */WebSocketClient.OPEN=WebSocketImpl.OPEN;/**
     * The connection is in the process of closing.
     */WebSocketClient.CLOSING=WebSocketImpl.CLOSING;/**
     * The connection is closed or couldn't be opened.
     */WebSocketClient.CLOSED=WebSocketImpl.CLOSED;exports.default=WebSocketClient;
    });

    var Connection_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Connection = void 0;
    var websocket_1 = __importDefault(lib$1);
    var Connection = /** @class */ (function (_super) {
        __extends(Connection, _super);
        function Connection(url, autoConnect) {
            if (autoConnect === void 0) { autoConnect = true; }
            var _this = _super.call(this, url, undefined, { connect: autoConnect }) || this;
            _this._enqueuedCalls = [];
            return _this;
        }
        Connection.prototype.onOpenCallback = function (event) {
            _super.prototype.onOpenCallback.call(this);
            this.binaryType = 'arraybuffer';
            if (this._enqueuedCalls.length > 0) {
                for (var _i = 0, _a = this._enqueuedCalls; _i < _a.length; _i++) {
                    var _b = _a[_i], method = _b[0], args = _b[1];
                    this[method].apply(this, args);
                }
                // clear enqueued calls.
                this._enqueuedCalls = [];
            }
        };
        Connection.prototype.send = function (data) {
            if (this.ws.readyState === websocket_1.default.OPEN) {
                if (data instanceof ArrayBuffer) {
                    return _super.prototype.send.call(this, data);
                }
                else if (Array.isArray(data)) {
                    return _super.prototype.send.call(this, (new Uint8Array(data)).buffer);
                }
            }
            else {
                // WebSocket not connected.
                // Enqueue data to be sent when readyState == OPEN
                this._enqueuedCalls.push(['send', [data]]);
            }
        };
        return Connection;
    }(websocket_1.default));
    exports.Connection = Connection;

    });

    var Serializer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSerializer = exports.registerSerializer = void 0;
    var serializers = {};
    function registerSerializer(id, serializer) {
        serializers[id] = serializer;
    }
    exports.registerSerializer = registerSerializer;
    function getSerializer(id) {
        var serializer = serializers[id];
        if (!serializer) {
            throw new Error("missing serializer: " + id);
        }
        return serializer;
    }
    exports.getSerializer = getSerializer;

    });

    var Protocol_1 = createCommonjsModule(function (module, exports) {
    // Use codes between 0~127 for lesser throughput (1 byte)
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8Length = exports.utf8Read = exports.ErrorCode = exports.Protocol = void 0;
    var Protocol;
    (function (Protocol) {
        // Room-related (10~19)
        Protocol[Protocol["HANDSHAKE"] = 9] = "HANDSHAKE";
        Protocol[Protocol["JOIN_ROOM"] = 10] = "JOIN_ROOM";
        Protocol[Protocol["ERROR"] = 11] = "ERROR";
        Protocol[Protocol["LEAVE_ROOM"] = 12] = "LEAVE_ROOM";
        Protocol[Protocol["ROOM_DATA"] = 13] = "ROOM_DATA";
        Protocol[Protocol["ROOM_STATE"] = 14] = "ROOM_STATE";
        Protocol[Protocol["ROOM_STATE_PATCH"] = 15] = "ROOM_STATE_PATCH";
        Protocol[Protocol["ROOM_DATA_SCHEMA"] = 16] = "ROOM_DATA_SCHEMA";
    })(Protocol = exports.Protocol || (exports.Protocol = {}));
    var ErrorCode;
    (function (ErrorCode) {
        ErrorCode[ErrorCode["MATCHMAKE_NO_HANDLER"] = 4210] = "MATCHMAKE_NO_HANDLER";
        ErrorCode[ErrorCode["MATCHMAKE_INVALID_CRITERIA"] = 4211] = "MATCHMAKE_INVALID_CRITERIA";
        ErrorCode[ErrorCode["MATCHMAKE_INVALID_ROOM_ID"] = 4212] = "MATCHMAKE_INVALID_ROOM_ID";
        ErrorCode[ErrorCode["MATCHMAKE_UNHANDLED"] = 4213] = "MATCHMAKE_UNHANDLED";
        ErrorCode[ErrorCode["MATCHMAKE_EXPIRED"] = 4214] = "MATCHMAKE_EXPIRED";
        ErrorCode[ErrorCode["AUTH_FAILED"] = 4215] = "AUTH_FAILED";
        ErrorCode[ErrorCode["APPLICATION_ERROR"] = 4216] = "APPLICATION_ERROR";
    })(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
    function utf8Read(view, offset) {
        var length = view[offset++];
        var string = '', chr = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = view[i];
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (view[++i] & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((view[++i] & 0x3f) << 6) |
                    ((view[++i] & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((view[++i] & 0x3f) << 12) |
                    ((view[++i] & 0x3f) << 6) |
                    ((view[++i] & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            throw new Error('Invalid byte ' + byte.toString(16));
        }
        return string;
    }
    exports.utf8Read = utf8Read;
    // Faster for short strings than Buffer.byteLength
    function utf8Length(str) {
        if (str === void 0) { str = ''; }
        var c = 0;
        var length = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                length += 1;
            }
            else if (c < 0x800) {
                length += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                length += 3;
            }
            else {
                i++;
                length += 4;
            }
        }
        return length + 1;
    }
    exports.utf8Length = utf8Length;

    });

    var encode = createCommonjsModule(function (module, exports) {
    /**
     * Copyright (c) 2018 Endel Dreyer
     * Copyright (c) 2014 Ion Drive Software Ltd.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.number = exports.string = exports.boolean = exports.writeFloat64 = exports.writeFloat32 = exports.float64 = exports.float32 = exports.uint64 = exports.int64 = exports.uint32 = exports.int32 = exports.uint16 = exports.int16 = exports.uint8 = exports.int8 = exports.utf8Write = void 0;
    /**
     * msgpack implementation highly based on notepack.io
     * https://github.com/darrachequesne/notepack
     */
    function utf8Length(str) {
        var c = 0, length = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                length += 1;
            }
            else if (c < 0x800) {
                length += 2;
            }
            else if (c < 0xd800 || c >= 0xe000) {
                length += 3;
            }
            else {
                i++;
                length += 4;
            }
        }
        return length;
    }
    function utf8Write(view, offset, str) {
        var c = 0;
        for (var i = 0, l = str.length; i < l; i++) {
            c = str.charCodeAt(i);
            if (c < 0x80) {
                view[offset++] = c;
            }
            else if (c < 0x800) {
                view[offset++] = 0xc0 | (c >> 6);
                view[offset++] = 0x80 | (c & 0x3f);
            }
            else if (c < 0xd800 || c >= 0xe000) {
                view[offset++] = 0xe0 | (c >> 12);
                view[offset++] = 0x80 | (c >> 6 & 0x3f);
                view[offset++] = 0x80 | (c & 0x3f);
            }
            else {
                i++;
                c = 0x10000 + (((c & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                view[offset++] = 0xf0 | (c >> 18);
                view[offset++] = 0x80 | (c >> 12 & 0x3f);
                view[offset++] = 0x80 | (c >> 6 & 0x3f);
                view[offset++] = 0x80 | (c & 0x3f);
            }
        }
    }
    exports.utf8Write = utf8Write;
    function int8(bytes, value) {
        bytes.push(value & 255);
    }
    exports.int8 = int8;
    function uint8(bytes, value) {
        bytes.push(value & 255);
    }
    exports.uint8 = uint8;
    function int16(bytes, value) {
        bytes.push(value & 255);
        bytes.push((value >> 8) & 255);
    }
    exports.int16 = int16;
    function uint16(bytes, value) {
        bytes.push(value & 255);
        bytes.push((value >> 8) & 255);
    }
    exports.uint16 = uint16;
    function int32(bytes, value) {
        bytes.push(value & 255);
        bytes.push((value >> 8) & 255);
        bytes.push((value >> 16) & 255);
        bytes.push((value >> 24) & 255);
    }
    exports.int32 = int32;
    function uint32(bytes, value) {
        var b4 = value >> 24;
        var b3 = value >> 16;
        var b2 = value >> 8;
        var b1 = value;
        bytes.push(b1 & 255);
        bytes.push(b2 & 255);
        bytes.push(b3 & 255);
        bytes.push(b4 & 255);
    }
    exports.uint32 = uint32;
    function int64(bytes, value) {
        var high = Math.floor(value / Math.pow(2, 32));
        var low = value >>> 0;
        uint32(bytes, low);
        uint32(bytes, high);
    }
    exports.int64 = int64;
    function uint64(bytes, value) {
        var high = (value / Math.pow(2, 32)) >> 0;
        var low = value >>> 0;
        uint32(bytes, low);
        uint32(bytes, high);
    }
    exports.uint64 = uint64;
    function float32(bytes, value) {
        writeFloat32(bytes, value);
    }
    exports.float32 = float32;
    function float64(bytes, value) {
        writeFloat64(bytes, value);
    }
    exports.float64 = float64;
    var _int32 = new Int32Array(2);
    var _float32 = new Float32Array(_int32.buffer);
    var _float64 = new Float64Array(_int32.buffer);
    function writeFloat32(bytes, value) {
        _float32[0] = value;
        int32(bytes, _int32[0]);
    }
    exports.writeFloat32 = writeFloat32;
    function writeFloat64(bytes, value) {
        _float64[0] = value;
        int32(bytes, _int32[ 0 ]);
        int32(bytes, _int32[ 1 ]);
    }
    exports.writeFloat64 = writeFloat64;
    function boolean(bytes, value) {
        return uint8(bytes, value ? 1 : 0);
    }
    exports.boolean = boolean;
    function string(bytes, value) {
        // encode `null` strings as empty.
        if (!value) {
            value = "";
        }
        var length = utf8Length(value);
        var size = 0;
        // fixstr
        if (length < 0x20) {
            bytes.push(length | 0xa0);
            size = 1;
        }
        // str 8
        else if (length < 0x100) {
            bytes.push(0xd9);
            uint8(bytes, length);
            size = 2;
        }
        // str 16
        else if (length < 0x10000) {
            bytes.push(0xda);
            uint16(bytes, length);
            size = 3;
        }
        // str 32
        else if (length < 0x100000000) {
            bytes.push(0xdb);
            uint32(bytes, length);
            size = 5;
        }
        else {
            throw new Error('String too long');
        }
        utf8Write(bytes, bytes.length, value);
        return size + length;
    }
    exports.string = string;
    function number(bytes, value) {
        if (isNaN(value)) {
            return number(bytes, 0);
        }
        else if (!isFinite(value)) {
            return number(bytes, (value > 0) ? Number.MAX_SAFE_INTEGER : -Number.MAX_SAFE_INTEGER);
        }
        else if (value !== (value | 0)) {
            bytes.push(0xcb);
            writeFloat64(bytes, value);
            return 9;
            // TODO: encode float 32?
            // is it possible to differentiate between float32 / float64 here?
            // // float 32
            // bytes.push(0xca);
            // writeFloat32(bytes, value);
            // return 5;
        }
        if (value >= 0) {
            // positive fixnum
            if (value < 0x80) {
                uint8(bytes, value);
                return 1;
            }
            // uint 8
            if (value < 0x100) {
                bytes.push(0xcc);
                uint8(bytes, value);
                return 2;
            }
            // uint 16
            if (value < 0x10000) {
                bytes.push(0xcd);
                uint16(bytes, value);
                return 3;
            }
            // uint 32
            if (value < 0x100000000) {
                bytes.push(0xce);
                uint32(bytes, value);
                return 5;
            }
            // uint 64
            bytes.push(0xcf);
            uint64(bytes, value);
            return 9;
        }
        else {
            // negative fixnum
            if (value >= -0x20) {
                bytes.push(0xe0 | (value + 0x20));
                return 1;
            }
            // int 8
            if (value >= -0x80) {
                bytes.push(0xd0);
                int8(bytes, value);
                return 2;
            }
            // int 16
            if (value >= -0x8000) {
                bytes.push(0xd1);
                int16(bytes, value);
                return 3;
            }
            // int 32
            if (value >= -0x80000000) {
                bytes.push(0xd2);
                int32(bytes, value);
                return 5;
            }
            // int 64
            bytes.push(0xd3);
            int64(bytes, value);
            return 9;
        }
    }
    exports.number = number;

    });

    var spec = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OPERATION = exports.TYPE_ID = exports.SWITCH_TO_STRUCTURE = void 0;
    // export const SWITCH_TO_STRUCTURE = 193; (easily collides with DELETE_AND_ADD + fieldIndex = 2)
    exports.SWITCH_TO_STRUCTURE = 255; // (decoding collides with DELETE_AND_ADD + fieldIndex = 63)
    exports.TYPE_ID = 213;
    /**
     * Encoding Schema field operations.
     */
    var OPERATION;
    (function (OPERATION) {
        // add new structure/primitive
        OPERATION[OPERATION["ADD"] = 128] = "ADD";
        // replace structure/primitive
        OPERATION[OPERATION["REPLACE"] = 0] = "REPLACE";
        // delete field
        OPERATION[OPERATION["DELETE"] = 64] = "DELETE";
        // DELETE field, followed by an ADD
        OPERATION[OPERATION["DELETE_AND_ADD"] = 192] = "DELETE_AND_ADD";
        // TOUCH is used to determine hierarchy of nested Schema structures during serialization.
        // touches are NOT encoded.
        OPERATION[OPERATION["TOUCH"] = 1] = "TOUCH";
        // MapSchema Operations
        OPERATION[OPERATION["CLEAR"] = 10] = "CLEAR";
    })(OPERATION = exports.OPERATION || (exports.OPERATION = {}));
    // export enum OPERATION {
    //     // add new structure/primitive
    //     // (128)
    //     ADD = 128, // 10000000,
    //     // replace structure/primitive
    //     REPLACE = 1,// 00000001
    //     // delete field
    //     DELETE = 192, // 11000000
    //     // DELETE field, followed by an ADD
    //     DELETE_AND_ADD = 224, // 11100000
    //     // TOUCH is used to determine hierarchy of nested Schema structures during serialization.
    //     // touches are NOT encoded.
    //     TOUCH = 0, // 00000000
    //     // MapSchema Operations
    //     CLEAR = 10,
    // }

    });

    var decode = createCommonjsModule(function (module, exports) {
    /**
     * Copyright (c) 2018 Endel Dreyer
     * Copyright (c) 2014 Ion Drive Software Ltd.
     *
     * Permission is hereby granted, free of charge, to any person obtaining a copy
     * of this software and associated documentation files (the "Software"), to deal
     * in the Software without restriction, including without limitation the rights
     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     * copies of the Software, and to permit persons to whom the Software is
     * furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in all
     * copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     * SOFTWARE
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.switchStructureCheck = exports.arrayCheck = exports.numberCheck = exports.number = exports.stringCheck = exports.string = exports.boolean = exports.readFloat64 = exports.readFloat32 = exports.uint64 = exports.int64 = exports.float64 = exports.float32 = exports.uint32 = exports.int32 = exports.uint16 = exports.int16 = exports.uint8 = exports.int8 = void 0;

    function utf8Read(bytes, offset, length) {
        var string = '', chr = 0;
        for (var i = offset, end = offset + length; i < end; i++) {
            var byte = bytes[i];
            if ((byte & 0x80) === 0x00) {
                string += String.fromCharCode(byte);
                continue;
            }
            if ((byte & 0xe0) === 0xc0) {
                string += String.fromCharCode(((byte & 0x1f) << 6) |
                    (bytes[++i] & 0x3f));
                continue;
            }
            if ((byte & 0xf0) === 0xe0) {
                string += String.fromCharCode(((byte & 0x0f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0));
                continue;
            }
            if ((byte & 0xf8) === 0xf0) {
                chr = ((byte & 0x07) << 18) |
                    ((bytes[++i] & 0x3f) << 12) |
                    ((bytes[++i] & 0x3f) << 6) |
                    ((bytes[++i] & 0x3f) << 0);
                if (chr >= 0x010000) { // surrogate pair
                    chr -= 0x010000;
                    string += String.fromCharCode((chr >>> 10) + 0xD800, (chr & 0x3FF) + 0xDC00);
                }
                else {
                    string += String.fromCharCode(chr);
                }
                continue;
            }
            console.error('Invalid byte ' + byte.toString(16));
            // (do not throw error to avoid server/client from crashing due to hack attemps)
            // throw new Error('Invalid byte ' + byte.toString(16));
        }
        return string;
    }
    function int8(bytes, it) {
        return uint8(bytes, it) << 24 >> 24;
    }
    exports.int8 = int8;
    function uint8(bytes, it) {
        return bytes[it.offset++];
    }
    exports.uint8 = uint8;
    function int16(bytes, it) {
        return uint16(bytes, it) << 16 >> 16;
    }
    exports.int16 = int16;
    function uint16(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8;
    }
    exports.uint16 = uint16;
    function int32(bytes, it) {
        return bytes[it.offset++] | bytes[it.offset++] << 8 | bytes[it.offset++] << 16 | bytes[it.offset++] << 24;
    }
    exports.int32 = int32;
    function uint32(bytes, it) {
        return int32(bytes, it) >>> 0;
    }
    exports.uint32 = uint32;
    function float32(bytes, it) {
        return readFloat32(bytes, it);
    }
    exports.float32 = float32;
    function float64(bytes, it) {
        return readFloat64(bytes, it);
    }
    exports.float64 = float64;
    function int64(bytes, it) {
        var low = uint32(bytes, it);
        var high = int32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    exports.int64 = int64;
    function uint64(bytes, it) {
        var low = uint32(bytes, it);
        var high = uint32(bytes, it) * Math.pow(2, 32);
        return high + low;
    }
    exports.uint64 = uint64;
    var _int32 = new Int32Array(2);
    var _float32 = new Float32Array(_int32.buffer);
    var _float64 = new Float64Array(_int32.buffer);
    function readFloat32(bytes, it) {
        _int32[0] = int32(bytes, it);
        return _float32[0];
    }
    exports.readFloat32 = readFloat32;
    function readFloat64(bytes, it) {
        _int32[ 0 ] = int32(bytes, it);
        _int32[ 1 ] = int32(bytes, it);
        return _float64[0];
    }
    exports.readFloat64 = readFloat64;
    function boolean(bytes, it) {
        return uint8(bytes, it) > 0;
    }
    exports.boolean = boolean;
    function string(bytes, it) {
        var prefix = bytes[it.offset++];
        var length;
        if (prefix < 0xc0) {
            // fixstr
            length = prefix & 0x1f;
        }
        else if (prefix === 0xd9) {
            length = uint8(bytes, it);
        }
        else if (prefix === 0xda) {
            length = uint16(bytes, it);
        }
        else if (prefix === 0xdb) {
            length = uint32(bytes, it);
        }
        var value = utf8Read(bytes, it.offset, length);
        it.offset += length;
        return value;
    }
    exports.string = string;
    function stringCheck(bytes, it) {
        var prefix = bytes[it.offset];
        return (
        // fixstr
        (prefix < 0xc0 && prefix > 0xa0) ||
            // str 8
            prefix === 0xd9 ||
            // str 16
            prefix === 0xda ||
            // str 32
            prefix === 0xdb);
    }
    exports.stringCheck = stringCheck;
    function number(bytes, it) {
        var prefix = bytes[it.offset++];
        if (prefix < 0x80) {
            // positive fixint
            return prefix;
        }
        else if (prefix === 0xca) {
            // float 32
            return readFloat32(bytes, it);
        }
        else if (prefix === 0xcb) {
            // float 64
            return readFloat64(bytes, it);
        }
        else if (prefix === 0xcc) {
            // uint 8
            return uint8(bytes, it);
        }
        else if (prefix === 0xcd) {
            // uint 16
            return uint16(bytes, it);
        }
        else if (prefix === 0xce) {
            // uint 32
            return uint32(bytes, it);
        }
        else if (prefix === 0xcf) {
            // uint 64
            return uint64(bytes, it);
        }
        else if (prefix === 0xd0) {
            // int 8
            return int8(bytes, it);
        }
        else if (prefix === 0xd1) {
            // int 16
            return int16(bytes, it);
        }
        else if (prefix === 0xd2) {
            // int 32
            return int32(bytes, it);
        }
        else if (prefix === 0xd3) {
            // int 64
            return int64(bytes, it);
        }
        else if (prefix > 0xdf) {
            // negative fixint
            return (0xff - prefix + 1) * -1;
        }
    }
    exports.number = number;
    function numberCheck(bytes, it) {
        var prefix = bytes[it.offset];
        // positive fixint - 0x00 - 0x7f
        // float 32        - 0xca
        // float 64        - 0xcb
        // uint 8          - 0xcc
        // uint 16         - 0xcd
        // uint 32         - 0xce
        // uint 64         - 0xcf
        // int 8           - 0xd0
        // int 16          - 0xd1
        // int 32          - 0xd2
        // int 64          - 0xd3
        return (prefix < 0x80 ||
            (prefix >= 0xca && prefix <= 0xd3));
    }
    exports.numberCheck = numberCheck;
    function arrayCheck(bytes, it) {
        return bytes[it.offset] < 0xa0;
        // const prefix = bytes[it.offset] ;
        // if (prefix < 0xa0) {
        //   return prefix;
        // // array
        // } else if (prefix === 0xdc) {
        //   it.offset += 2;
        // } else if (0xdd) {
        //   it.offset += 4;
        // }
        // return prefix;
    }
    exports.arrayCheck = arrayCheck;
    function switchStructureCheck(bytes, it) {
        return (
        // previous byte should be `SWITCH_TO_STRUCTURE`
        bytes[it.offset - 1] === spec.SWITCH_TO_STRUCTURE &&
            // next byte should be a number
            (bytes[it.offset] < 0x80 || (bytes[it.offset] >= 0xca && bytes[it.offset] <= 0xd3)));
    }
    exports.switchStructureCheck = switchStructureCheck;

    });

    var nanoevents_1 = /*@__PURE__*/getAugmentedNamespace(nanoevents);

    var Room_1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Room = void 0;
    var msgpack$1 = __importStar(msgpack);





    var encode$1 = __importStar(encode);
    var decode$1 = __importStar(decode);
    var Room = /** @class */ (function () {
        function Room(name, rootSchema) {
            var _this = this;
            // Public signals
            this.onStateChange = lib.createSignal();
            this.onError = lib.createSignal();
            this.onLeave = lib.createSignal();
            this.onJoin = lib.createSignal();
            this.hasJoined = false;
            this.onMessageHandlers = nanoevents_1.createNanoEvents();
            this.id = null;
            this.name = name;
            if (rootSchema) {
                this.serializer = new (Serializer.getSerializer("schema"));
                this.rootSchema = rootSchema;
                this.serializer.state = new rootSchema();
            }
            this.onError(function (code, message) { return console.warn("colyseus.js - onError => (" + code + ") " + message); });
            this.onLeave(function () { return _this.removeAllListeners(); });
        }
        Room.prototype.connect = function (endpoint) {
            var _this = this;
            this.connection = new Connection_1.Connection(endpoint, false);
            this.connection.reconnectEnabled = false;
            this.connection.onmessage = this.onMessageCallback.bind(this);
            this.connection.onclose = function (e) {
                if (!_this.hasJoined) {
                    console.warn("Room connection was closed unexpectedly (" + e.code + "): " + e.reason);
                    _this.onError.invoke(e.code, e.reason);
                    return;
                }
                _this.onLeave.invoke(e.code);
            };
            this.connection.onerror = function (e) {
                console.warn("Room, onError (" + e.code + "): " + e.reason);
                _this.onError.invoke(e.code, e.reason);
            };
            this.connection.open();
        };
        Room.prototype.leave = function (consented) {
            if (consented === void 0) { consented = true; }
            if (this.connection) {
                if (consented) {
                    this.connection.send([Protocol_1.Protocol.LEAVE_ROOM]);
                }
                else {
                    this.connection.close();
                }
            }
            else {
                this.onLeave.invoke(4000); // "consented" code
            }
        };
        Room.prototype.onMessage = function (type, callback) {
            return this.onMessageHandlers.on(this.getMessageHandlerKey(type), callback);
        };
        Room.prototype.send = function (type, message) {
            var initialBytes = [Protocol_1.Protocol.ROOM_DATA];
            if (typeof (type) === "string") {
                encode$1.string(initialBytes, type);
            }
            else {
                encode$1.number(initialBytes, type);
            }
            var arr;
            if (message !== undefined) {
                var encoded = msgpack$1.encode(message);
                arr = new Uint8Array(initialBytes.length + encoded.byteLength);
                arr.set(new Uint8Array(initialBytes), 0);
                arr.set(new Uint8Array(encoded), initialBytes.length);
            }
            else {
                arr = new Uint8Array(initialBytes);
            }
            this.connection.send(arr.buffer);
        };
        Object.defineProperty(Room.prototype, "state", {
            get: function () {
                return this.serializer.getState();
            },
            enumerable: false,
            configurable: true
        });
        // TODO: deprecate / move somewhere else
        // this method is useful only for FossilDeltaSerializer
        Room.prototype.listen = function (segments, callback, immediate) {
            if (this.serializerId === "schema") {
                console.warn("'" + this.serializerId + "' serializer doesn't support .listen() method here.");
                return;
            }
            else if (!this.serializerId) {
                console.warn("room.Listen() should be called after room.onJoin has been called (DEPRECATION WARNING)");
            }
            return this.serializer.api.listen(segments, callback, immediate);
        };
        // TODO: deprecate / move somewhere else
        // this method is useful only for FossilDeltaSerializer
        Room.prototype.removeListener = function (listener) {
            return this.serializer.api.removeListener(listener);
        };
        Room.prototype.removeAllListeners = function () {
            if (this.serializer) {
                this.serializer.teardown();
            }
            this.onJoin.clear();
            this.onStateChange.clear();
            this.onError.clear();
            this.onLeave.clear();
            this.onMessageHandlers.events = {};
        };
        Room.prototype.onMessageCallback = function (event) {
            var bytes = Array.from(new Uint8Array(event.data));
            var code = bytes[0];
            if (code === Protocol_1.Protocol.JOIN_ROOM) {
                var offset = 1;
                this.serializerId = Protocol_1.utf8Read(bytes, offset);
                offset += Protocol_1.utf8Length(this.serializerId);
                // Instantiate serializer if not locally available.
                if (!this.serializer) {
                    var serializer = Serializer.getSerializer(this.serializerId);
                    this.serializer = new serializer();
                }
                if (bytes.length > offset && this.serializer.handshake) {
                    this.serializer.handshake(bytes, { offset: offset });
                }
                this.hasJoined = true;
                this.onJoin.invoke();
                // acknowledge successfull JOIN_ROOM
                this.connection.send([Protocol_1.Protocol.JOIN_ROOM]);
            }
            else if (code === Protocol_1.Protocol.ERROR) {
                var it_1 = { offset: 1 };
                var code_1 = decode$1.number(bytes, it_1);
                var message = decode$1.string(bytes, it_1);
                this.onError.invoke(code_1, message);
            }
            else if (code === Protocol_1.Protocol.LEAVE_ROOM) {
                this.leave();
            }
            else if (code === Protocol_1.Protocol.ROOM_DATA_SCHEMA) {
                var it_2 = { offset: 1 };
                var context_1 = this.serializer.getState().constructor._context;
                var type = context_1.get(decode$1.number(bytes, it_2));
                var message = new type();
                message.decode(bytes, it_2);
                this.dispatchMessage(type, message);
            }
            else if (code === Protocol_1.Protocol.ROOM_STATE) {
                bytes.shift(); // drop `code` byte
                this.setState(bytes);
            }
            else if (code === Protocol_1.Protocol.ROOM_STATE_PATCH) {
                bytes.shift(); // drop `code` byte
                this.patch(bytes);
            }
            else if (code === Protocol_1.Protocol.ROOM_DATA) {
                var it_3 = { offset: 1 };
                var type = (decode$1.stringCheck(bytes, it_3))
                    ? decode$1.string(bytes, it_3)
                    : decode$1.number(bytes, it_3);
                var message = (bytes.length > it_3.offset)
                    ? msgpack$1.decode(event.data, it_3.offset)
                    : undefined;
                this.dispatchMessage(type, message);
            }
        };
        Room.prototype.setState = function (encodedState) {
            this.serializer.setState(encodedState);
            this.onStateChange.invoke(this.serializer.getState());
        };
        Room.prototype.patch = function (binaryPatch) {
            this.serializer.patch(binaryPatch);
            this.onStateChange.invoke(this.serializer.getState());
        };
        Room.prototype.dispatchMessage = function (type, message) {
            var messageType = this.getMessageHandlerKey(type);
            if (this.onMessageHandlers.events[messageType]) {
                this.onMessageHandlers.emit(messageType, message);
            }
            else if (this.onMessageHandlers.events['*']) {
                this.onMessageHandlers.emit('*', type, message);
            }
            else {
                console.warn("onMessage not registered for type '" + type + "'.");
            }
        };
        Room.prototype.getMessageHandlerKey = function (type) {
            switch (typeof (type)) {
                // typeof Schema
                case "function": return "$" + type._typeid;
                // string
                case "string": return type;
                // number
                case "number": return "i" + type;
                default: throw new Error("invalid message type.");
            }
        };
        return Room;
    }());
    exports.Room = Room;

    });

    var Storage = createCommonjsModule(function (module, exports) {
    /// <reference path="../typings/cocos-creator.d.ts" />
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getItem = exports.removeItem = exports.setItem = void 0;
    /**
     * We do not assign 'storage' to window.localStorage immediatelly for React
     * Native compatibility. window.localStorage is not present when this module is
     * loaded.
     */
    var storage;
    function getStorage() {
        if (!storage) {
            storage = (typeof (cc) !== 'undefined' && cc.sys && cc.sys.localStorage)
                ? cc.sys.localStorage // compatibility with cocos creator
                : typeof (window) !== "undefined" && window.localStorage //RN does have window object at this point, but localStorage is not defined
                    ? window.localStorage // regular browser environment
                    : {
                        cache: {},
                        setItem: function (key, value) { this.cache[key] = value; },
                        getItem: function (key) { this.cache[key]; },
                        removeItem: function (key) { delete this.cache[key]; },
                    };
        }
        return storage;
    }
    function setItem(key, value) {
        getStorage().setItem(key, value);
    }
    exports.setItem = setItem;
    function removeItem(key) {
        getStorage().removeItem(key);
    }
    exports.removeItem = removeItem;
    function getItem(key, callback) {
        var value = getStorage().getItem(key);
        if (typeof (Promise) === 'undefined' || // old browsers
            !(value instanceof Promise)) {
            // browser has synchronous return
            callback(value);
        }
        else {
            // react-native is asynchronous
            value.then(function (id) { return callback(id); });
        }
    }
    exports.getItem = getItem;

    });

    var Auth_1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = exports.Platform = void 0;
    var http = __importStar(index_esm);

    var TOKEN_STORAGE = "colyseus-auth-token";
    var Platform;
    (function (Platform) {
        Platform["ios"] = "ios";
        Platform["android"] = "android";
    })(Platform = exports.Platform || (exports.Platform = {}));
    var Auth = /** @class */ (function () {
        function Auth(endpoint) {
            var _this = this;
            this._id = undefined;
            this.username = undefined;
            this.displayName = undefined;
            this.avatarUrl = undefined;
            this.isAnonymous = undefined;
            this.email = undefined;
            this.lang = undefined;
            this.location = undefined;
            this.timezone = undefined;
            this.metadata = undefined;
            this.devices = undefined;
            this.facebookId = undefined;
            this.twitterId = undefined;
            this.googleId = undefined;
            this.gameCenterId = undefined;
            this.steamId = undefined;
            this.friendIds = undefined;
            this.blockedUserIds = undefined;
            this.createdAt = undefined;
            this.updatedAt = undefined;
            // auth token
            this.token = undefined;
            this.endpoint = endpoint.replace("ws", "http");
            Storage.getItem(TOKEN_STORAGE, function (token) { return _this.token = token; });
        }
        Object.defineProperty(Auth.prototype, "hasToken", {
            get: function () {
                return !!this.token;
            },
            enumerable: false,
            configurable: true
        });
        Auth.prototype.login = function (options) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var queryParams, data, attr;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            queryParams = Object.assign({}, options);
                            if (this.hasToken) {
                                queryParams.token = this.token;
                            }
                            return [4 /*yield*/, this.request('post', '/auth', queryParams)];
                        case 1:
                            data = _a.sent();
                            // set & cache token
                            this.token = data.token;
                            Storage.setItem(TOKEN_STORAGE, this.token);
                            for (attr in data) {
                                if (this.hasOwnProperty(attr)) {
                                    this[attr] = data[attr];
                                }
                            }
                            this.registerPingService();
                            return [2 /*return*/, this];
                    }
                });
            });
        };
        Auth.prototype.save = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/auth', {}, {
                                username: this.username,
                                displayName: this.displayName,
                                avatarUrl: this.avatarUrl,
                                lang: this.lang,
                                location: this.location,
                                timezone: this.timezone,
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, this];
                    }
                });
            });
        };
        Auth.prototype.getFriends = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/all')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.getOnlineFriends = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/online')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.getFriendRequests = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('get', '/friends/requests')];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.sendFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('post', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.acceptFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.declineFriendRequest = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('del', '/friends/requests', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.blockUser = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('post', '/friends/block', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.unblockUser = function (friendId) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.request('put', '/friends/block', { userId: friendId })];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        Auth.prototype.request = function (method, segments, query, body, headers) {
            if (query === void 0) { query = {}; }
            if (headers === void 0) { headers = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var queryParams, name_1, queryString, opts;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            headers['Accept'] = 'application/json';
                            if (this.hasToken) {
                                headers['Authorization'] = 'Bearer ' + this.token;
                            }
                            queryParams = [];
                            for (name_1 in query) {
                                queryParams.push(name_1 + "=" + query[name_1]);
                            }
                            queryString = (queryParams.length > 0)
                                ? "?" + queryParams.join("&")
                                : '';
                            opts = { headers: headers };
                            if (body) {
                                opts.body = body;
                            }
                            return [4 /*yield*/, http[method]("" + this.endpoint + segments + queryString, opts)];
                        case 1: return [2 /*return*/, (_a.sent()).data];
                    }
                });
            });
        };
        Auth.prototype.logout = function () {
            this.token = undefined;
            Storage.removeItem(TOKEN_STORAGE);
            this.unregisterPingService();
        };
        Auth.prototype.registerPingService = function (timeout) {
            var _this = this;
            if (timeout === void 0) { timeout = 15000; }
            this.unregisterPingService();
            this.keepOnlineInterval = setInterval(function () { return _this.request('get', '/auth'); }, timeout);
        };
        Auth.prototype.unregisterPingService = function () {
            clearInterval(this.keepOnlineInterval);
        };
        return Auth;
    }());
    exports.Auth = Auth;

    });

    var Push_1 = createCommonjsModule(function (module, exports) {
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Push = void 0;
    var Push = /** @class */ (function () {
        function Push(endpoint) {
            this.endpoint = endpoint.replace("ws", "http");
        }
        Push.prototype.register = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.check();
                            return [4 /*yield*/, this.registerServiceWorker()];
                        case 1:
                            _a.sent();
                            return [4 /*yield*/, this.requestNotificationPermission()];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Push.prototype.registerServiceWorker = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, navigator.serviceWorker.register(this.endpoint + "/push")];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Push.prototype.requestNotificationPermission = function () {
            return __awaiter(this, void 0, void 0, function () {
                var permission;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, window["Notification"].requestPermission()];
                        case 1:
                            permission = _a.sent();
                            // value of permission can be 'granted', 'default', 'denied'
                            // granted: user has accepted the request
                            // default: user has dismissed the notification permission popup by clicking on x
                            // denied: user has denied the request.
                            if (permission !== "granted") {
                                throw new Error("Permission not granted for Notification");
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        Push.prototype.check = function () {
            if (!("serviceWorker" in navigator)) {
                throw new Error("No Service Worker support!");
            }
            if (!("PushManager" in window)) {
                throw new Error("No Push API Support!");
            }
        };
        return Push;
    }());
    exports.Push = Push;

    });

    var Client_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.MatchMakeError = void 0;





    var MatchMakeError = /** @class */ (function (_super) {
        __extends(MatchMakeError, _super);
        function MatchMakeError(message, code) {
            var _this = _super.call(this, message) || this;
            _this.code = code;
            Object.setPrototypeOf(_this, MatchMakeError.prototype);
            return _this;
        }
        return MatchMakeError;
    }(Error));
    exports.MatchMakeError = MatchMakeError;
    var Client = /** @class */ (function () {
        function Client(endpoint) {
            if (endpoint === void 0) { endpoint = location.protocol.replace("http", "ws") + "//" + location.hostname + (location.port && ":" + location.port); }
            this.endpoint = endpoint;
            this.auth = new Auth_1.Auth(this.endpoint);
            this.push = new Push_1.Push(this.endpoint);
        }
        Client.prototype.joinOrCreate = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinOrCreate', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.create = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('create', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.join = function (roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('join', roomName, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.joinById = function (roomId, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, options, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.reconnect = function (roomId, sessionId, rootSchema) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.createMatchMakeRequest('joinById', roomId, { sessionId: sessionId }, rootSchema)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
        Client.prototype.getAvailableRooms = function (roomName) {
            if (roomName === void 0) { roomName = ""; }
            return __awaiter(this, void 0, void 0, function () {
                var url;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.endpoint.replace("ws", "http") + "/matchmake/" + roomName;
                            return [4 /*yield*/, index_esm.get(url, { headers: { 'Accept': 'application/json' } })];
                        case 1: return [2 /*return*/, (_a.sent()).data];
                    }
                });
            });
        };
        Client.prototype.consumeSeatReservation = function (response, rootSchema) {
            return __awaiter(this, void 0, void 0, function () {
                var room;
                return __generator(this, function (_a) {
                    room = this.createRoom(response.room.name, rootSchema);
                    room.id = response.room.roomId;
                    room.sessionId = response.sessionId;
                    room.connect(this.buildEndpoint(response.room, { sessionId: room.sessionId }));
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var onError = function (code, message) { return reject(new ServerError_1.ServerError(code, message)); };
                            room.onError.once(onError);
                            room['onJoin'].once(function () {
                                room.onError.remove(onError);
                                resolve(room);
                            });
                        })];
                });
            });
        };
        Client.prototype.createMatchMakeRequest = function (method, roomName, options, rootSchema) {
            if (options === void 0) { options = {}; }
            return __awaiter(this, void 0, void 0, function () {
                var url, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.endpoint.replace("ws", "http") + "/matchmake/" + method + "/" + roomName;
                            // automatically forward auth token, if present
                            if (this.auth.hasToken) {
                                options.token = this.auth.token;
                            }
                            return [4 /*yield*/, index_esm.post(url, {
                                    headers: {
                                        'Accept': 'application/json',
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(options)
                                })];
                        case 1:
                            response = (_a.sent()).data;
                            if (response.error) {
                                throw new MatchMakeError(response.error, response.code);
                            }
                            return [2 /*return*/, this.consumeSeatReservation(response, rootSchema)];
                    }
                });
            });
        };
        Client.prototype.createRoom = function (roomName, rootSchema) {
            return new Room_1.Room(roomName, rootSchema);
        };
        Client.prototype.buildEndpoint = function (room, options) {
            if (options === void 0) { options = {}; }
            var params = [];
            for (var name_1 in options) {
                if (!options.hasOwnProperty(name_1)) {
                    continue;
                }
                params.push(name_1 + "=" + options[name_1]);
            }
            return this.endpoint + "/" + room.processId + "/" + room.roomId + "?" + params.join('&');
        };
        return Client;
    }());
    exports.Client = Client;

    });

    var compare_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function compare(tree1, tree2) {
        var patches = [];
        generate(tree1, tree2, patches, []);
        return patches;
    }
    exports.compare = compare;
    function concat(arr, value) {
        var newArr = arr.slice();
        newArr.push(value);
        return newArr;
    }
    function objectKeys(obj) {
        if (Array.isArray(obj)) {
            var keys_1 = new Array(obj.length);
            for (var k = 0; k < keys_1.length; k++) {
                keys_1[k] = "" + k;
            }
            return keys_1;
        }
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var i in obj) {
            if (obj.hasOwnProperty(i)) {
                keys.push(i);
            }
        }
        return keys;
    }
    // Dirty check if obj is different from mirror, generate patches and update mirror
    function generate(mirror, obj, patches, path) {
        var newKeys = objectKeys(obj);
        var oldKeys = objectKeys(mirror);
        var deleted = false;
        for (var t = oldKeys.length - 1; t >= 0; t--) {
            var key = oldKeys[t];
            var oldVal = mirror[key];
            if (obj.hasOwnProperty(key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {
                var newVal = obj[key];
                if (typeof oldVal == "object" && oldVal != null && typeof newVal == "object" && newVal != null) {
                    generate(oldVal, newVal, patches, concat(path, key));
                }
                else {
                    if (oldVal !== newVal) {
                        patches.push({
                            operation: "replace",
                            path: concat(path, key),
                            value: newVal,
                            previousValue: oldVal
                        });
                    }
                }
            }
            else {
                patches.push({ operation: "remove", path: concat(path, key) });
                deleted = true; // property has been deleted
            }
        }
        if (!deleted && newKeys.length == oldKeys.length) {
            return;
        }
        for (var t = newKeys.length - 1; t >= 0; t--) {
            var key = newKeys[t];
            if (!mirror.hasOwnProperty(key) && obj[key] !== undefined) {
                var newVal = obj[key];
                var addPath = concat(path, key);
                // compare deeper additions
                if (typeof newVal == "object" && newVal != null) {
                    generate({}, newVal, patches, addPath);
                }
                patches.push({ operation: "add", path: addPath, value: newVal });
            }
        }
    }
    });

    var StateContainer_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    var StateContainer = /** @class */ (function () {
        function StateContainer(state) {
            this.listeners = [];
            this.matcherPlaceholders = {
                ":id": /^([a-zA-Z0-9\-_]+)$/,
                ":number": /^([0-9]+)$/,
                ":string": /^(\w+)$/,
                ":axis": /^([xyz])$/,
                ":*": /(.*)/,
            };
            this.state = state;
            this.reset();
        }
        StateContainer.prototype.set = function (newState) {
            var patches = compare_1.compare(this.state, newState);
            this.state = newState;
            this.checkPatches(patches, this.listeners, this.defaultListener);
            return patches;
        };
        StateContainer.prototype.registerPlaceholder = function (placeholder, matcher) {
            this.matcherPlaceholders[placeholder] = matcher;
        };
        StateContainer.prototype.listen = function (segments, callback, immediate) {
            var _this = this;
            var rules;
            if (typeof (segments) === "function") {
                rules = [];
                callback = segments;
            }
            else {
                rules = segments.split("/");
            }
            if (callback.length > 1) {
                console.warn(".listen() accepts only one parameter.");
            }
            var listener = {
                callback: callback,
                rawRules: rules,
                rules: rules.map(function (segment) {
                    if (typeof (segment) === "string") {
                        // replace placeholder matchers
                        return (segment.indexOf(":") === 0)
                            ? _this.matcherPlaceholders[segment] || _this.matcherPlaceholders[":*"]
                            : new RegExp("^" + segment + "$");
                    }
                    else {
                        return segment;
                    }
                })
            };
            if (rules.length === 0) {
                this.defaultListener = listener;
            }
            else {
                this.listeners.push(listener);
            }
            // immediatelly try to trigger this listener.
            if (immediate) {
                this.checkPatches(compare_1.compare({}, this.state), [listener]);
            }
            return listener;
        };
        StateContainer.prototype.removeListener = function (listener) {
            for (var i = this.listeners.length - 1; i >= 0; i--) {
                if (this.listeners[i] === listener) {
                    this.listeners.splice(i, 1);
                }
            }
        };
        StateContainer.prototype.removeAllListeners = function () {
            this.reset();
        };
        StateContainer.prototype.checkPatches = function (patches, listeners, defaultListener) {
            for (var j = 0, len = listeners.length; j < len; j++) {
                var listener = listeners[j];
                for (var i = patches.length - 1; i >= 0; i--) {
                    var pathVariables = listener && this.getPathVariables(patches[i], listener);
                    if (pathVariables) {
                        listener.callback({
                            path: pathVariables,
                            rawPath: patches[i].path,
                            operation: patches[i].operation,
                            value: patches[i].value
                        });
                        patches[i].matched = true;
                    }
                }
            }
            // trigger default listener callback with each unmatched patch
            if (defaultListener) {
                for (var i = patches.length - 1; i >= 0; i--) {
                    if (!patches[i].matched) {
                        defaultListener.callback(patches[i]);
                    }
                }
            }
        };
        StateContainer.prototype.getPathVariables = function (patch, listener) {
            // skip if rules count differ from patch
            if (patch.path.length !== listener.rules.length) {
                return false;
            }
            var path = {};
            for (var i = 0, len = listener.rules.length; i < len; i++) {
                var matches = patch.path[i].match(listener.rules[i]);
                if (!matches || matches.length === 0 || matches.length > 2) {
                    return false;
                }
                else if (listener.rawRules[i].substr(0, 1) === ":") {
                    path[listener.rawRules[i].substr(1)] = matches[1];
                }
            }
            return path;
        };
        StateContainer.prototype.reset = function () {
            this.listeners = [];
        };
        return StateContainer;
    }());
    exports.StateContainer = StateContainer;
    });

    var lib$2 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    exports.StateContainer = StateContainer_1.StateContainer;
    });

    var fossilDelta = createCommonjsModule(function (module) {
    // Fossil SCM delta compression algorithm
    // ======================================
    //
    // Format:
    // http://www.fossil-scm.org/index.html/doc/tip/www/delta_format.wiki
    //
    // Algorithm:
    // http://www.fossil-scm.org/index.html/doc/tip/www/delta_encoder_algorithm.wiki
    //
    // Original implementation:
    // http://www.fossil-scm.org/index.html/artifact/d1b0598adcd650b3551f63b17dfc864e73775c3d
    //
    // LICENSE
    // -------
    //
    // Copyright 2014 Dmitry Chestnykh (JavaScript port)
    // Copyright 2007 D. Richard Hipp  (original C version)
    // All rights reserved.
    //
    // Redistribution and use in source and binary forms, with or
    // without modification, are permitted provided that the
    // following conditions are met:
    //
    //   1. Redistributions of source code must retain the above
    //      copyright notice, this list of conditions and the
    //      following disclaimer.
    //
    //   2. Redistributions in binary form must reproduce the above
    //      copyright notice, this list of conditions and the
    //      following disclaimer in the documentation and/or other
    //      materials provided with the distribution.
    //
    // THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
    // OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    // ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE
    // LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
    // CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    // SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
    // BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    // WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
    // OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    // EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    //
    // The views and conclusions contained in the software and documentation
    // are those of the authors and contributors and should not be interpreted
    // as representing official policies, either expressed or implied, of anybody
    // else.
    //
    (function(root, factory) {
      if ( module.exports) module.exports = factory();
      else root.fossilDelta = factory();
    })(commonjsGlobal, function() {

    var fossilDelta = {};

    // Hash window width in bytes. Must be a power of two.
    var NHASH = 16;

    function RollingHash() {
      this.a = 0; // hash     (16-bit unsigned)
      this.b = 0; // values   (16-bit unsigned)
      this.i = 0; // start of the hash window (16-bit unsigned)
      this.z = new Array(NHASH); // the values that have been hashed.
    }

    // Initialize the rolling hash using the first NHASH bytes of
    // z at the given position.
    RollingHash.prototype.init = function(z, pos) {
      var a = 0, b = 0, i, x;
      for(i = 0; i < NHASH; i++){
        x = z[pos+i];
        a = (a + x) & 0xffff;
        b = (b + (NHASH-i)*x) & 0xffff;
        this.z[i] = x;
      }
      this.a = a & 0xffff;
      this.b = b & 0xffff;
      this.i = 0;
    };

    // Advance the rolling hash by a single byte "c".
    RollingHash.prototype.next = function(c) {
      var old = this.z[this.i];
      this.z[this.i] = c;
      this.i = (this.i+1)&(NHASH-1);
      this.a = (this.a - old + c) & 0xffff;
      this.b = (this.b - NHASH*old + this.a) & 0xffff;
    };

    // Return a 32-bit hash value.
    RollingHash.prototype.value = function() {
      return ((this.a & 0xffff) | (this.b & 0xffff)<<16)>>>0;
    };

    var zDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~".
                    split('').map(function (x) { return x.charCodeAt(0); });

    var zValue = [
      -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
      -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,
       0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,
      -1, 10, 11, 12, 13, 14, 15, 16,   17, 18, 19, 20, 21, 22, 23, 24,
      25, 26, 27, 28, 29, 30, 31, 32,   33, 34, 35, -1, -1, -1, -1, 36,
      -1, 37, 38, 39, 40, 41, 42, 43,   44, 45, 46, 47, 48, 49, 50, 51,
      52, 53, 54, 55, 56, 57, 58, 59,   60, 61, 62, -1, -1, -1, 63, -1
    ];

    // Reader reads bytes, chars, ints from array.
    function Reader(array) {
      this.a = array; // source array
      this.pos = 0;   // current position in array
    }

    Reader.prototype.haveBytes = function() {
      return this.pos < this.a.length;
    };

    Reader.prototype.getByte = function() {
      var b = this.a[this.pos];
      this.pos++;
      if (this.pos > this.a.length) throw new RangeError('out of bounds');
      return b;
    };

    Reader.prototype.getChar = function() {
      return String.fromCharCode(this.getByte());
    };

    // Read base64-encoded unsigned integer.
    Reader.prototype.getInt = function(){
      var v = 0, c;
      while(this.haveBytes() && (c = zValue[0x7f & this.getByte()]) >= 0) {
         v = (v<<6) + c;
      }
      this.pos--;
      return v >>> 0;
    };


    // Write writes an array.
    function Writer() {
      this.a = [];
    }

    Writer.prototype.toArray = function() {
      return this.a;
    };

    Writer.prototype.putByte = function(b) {
      this.a.push(b & 0xff);
    };

    // Write an ASCII character (s is a one-char string).
    Writer.prototype.putChar = function(s) {
      this.putByte(s.charCodeAt(0));
    };

    // Write a base64 unsigned integer.
    Writer.prototype.putInt = function(v){
      var i, j, zBuf = [];
      if (v === 0) {
        this.putChar('0');
        return;
      }
      for (i = 0; v > 0; i++, v >>>= 6)
        zBuf.push(zDigits[v&0x3f]);
      for (j = i-1; j >= 0; j--)
        this.putByte(zBuf[j]);
    };

    // Copy from array at start to end.
    Writer.prototype.putArray = function(a, start, end) {
      for (var i = start; i < end; i++) this.a.push(a[i]);
    };

    // Return the number digits in the base64 representation of a positive integer.
    function digitCount(v){
      var i, x;
      for (i = 1, x = 64; v >= x; i++, x <<= 6){ /* nothing */ }
      return i;
    }

    // Return a 32-bit checksum of the array.
    function checksum(arr) {
      var sum0 = 0, sum1 = 0, sum2 = 0, sum3 = 0,
          z = 0, N = arr.length;
      //TODO measure if this unrolling is helpful.
      while (N >= 16) {
        sum0 = sum0 + arr[z+0] | 0;
        sum1 = sum1 + arr[z+1] | 0;
        sum2 = sum2 + arr[z+2] | 0;
        sum3 = sum3 + arr[z+3] | 0;

        sum0 = sum0 + arr[z+4] | 0;
        sum1 = sum1 + arr[z+5] | 0;
        sum2 = sum2 + arr[z+6] | 0;
        sum3 = sum3 + arr[z+7] | 0;

        sum0 = sum0 + arr[z+8] | 0;
        sum1 = sum1 + arr[z+9] | 0;
        sum2 = sum2 + arr[z+10] | 0;
        sum3 = sum3 + arr[z+11] | 0;

        sum0 = sum0 + arr[z+12] | 0;
        sum1 = sum1 + arr[z+13] | 0;
        sum2 = sum2 + arr[z+14] | 0;
        sum3 = sum3 + arr[z+15] | 0;

        z += 16;
        N -= 16;
      }
      while (N >= 4) {
        sum0 = sum0 + arr[z+0] | 0;
        sum1 = sum1 + arr[z+1] | 0;
        sum2 = sum2 + arr[z+2] | 0;
        sum3 = sum3 + arr[z+3] | 0;
        z += 4;
        N -= 4;
      }
      sum3 = (((sum3 + (sum2 << 8) | 0) + (sum1 << 16) | 0) + (sum0 << 24) | 0);
      /* jshint -W086 */
      switch (N) {
        case 3: sum3 = sum3 + (arr[z+2] <<  8) | 0; /* falls through */
        case 2: sum3 = sum3 + (arr[z+1] << 16) | 0; /* falls through */
        case 1: sum3 = sum3 + (arr[z+0] << 24) | 0; /* falls through */
      }
      return sum3 >>> 0;
    }

    // Create a new delta from src to out.
    fossilDelta.create = function(src, out) {
      var zDelta = new Writer();
      var lenOut = out.length;
      var lenSrc = src.length;
      var i;

      zDelta.putInt(lenOut);
      zDelta.putChar('\n');

      // If the source is very small, it means that we have no
      // chance of ever doing a copy command.  Just output a single
      // literal segment for the entire target and exit.
      if (lenSrc <= NHASH) {
        zDelta.putInt(lenOut);
        zDelta.putChar(':');
        zDelta.putArray(out, 0, lenOut);
        zDelta.putInt(checksum(out));
        zDelta.putChar(';');
        return zDelta.toArray();
      }

      // Compute the hash table used to locate matching sections in the source.
      var nHash = Math.ceil(lenSrc / NHASH);
      var collide =  new Array(nHash);
      var landmark = new Array(nHash);
      for (i = 0; i < collide.length; i++) collide[i] = -1;
      for (i = 0; i < landmark.length; i++) landmark[i] = -1;
      var hv, h = new RollingHash();
      for (i = 0; i < lenSrc-NHASH; i += NHASH) {
        h.init(src, i);
        hv = h.value() % nHash;
        collide[i/NHASH] = landmark[hv];
        landmark[hv] = i/NHASH;
      }

      var base = 0;
      var iSrc, iBlock, bestCnt, bestOfst, bestLitsz;
      while (base+NHASH<lenOut) {
        bestOfst=0;
        bestLitsz=0;
        h.init(out, base);
        i = 0; // Trying to match a landmark against zOut[base+i]
        bestCnt = 0;
        while(1) {
          var limit = 250;
          hv = h.value() % nHash;
          iBlock = landmark[hv];
          while (iBlock >= 0 && (limit--)>0 ) {
            //
            // The hash window has identified a potential match against
            // landmark block iBlock.  But we need to investigate further.
            //
            // Look for a region in zOut that matches zSrc. Anchor the search
            // at zSrc[iSrc] and zOut[base+i].  Do not include anything prior to
            // zOut[base] or after zOut[outLen] nor anything after zSrc[srcLen].
            //
            // Set cnt equal to the length of the match and set ofst so that
            // zSrc[ofst] is the first element of the match.  litsz is the number
            // of characters between zOut[base] and the beginning of the match.
            // sz will be the overhead (in bytes) needed to encode the copy
            // command.  Only generate copy command if the overhead of the
            // copy command is less than the amount of literal text to be copied.
            //
            var cnt, ofst, litsz;
            var j, k, x, y;
            var sz;

            // Beginning at iSrc, match forwards as far as we can.
            // j counts the number of characters that match.
            iSrc = iBlock*NHASH;
            for (j = 0, x = iSrc, y = base+i; x < lenSrc && y < lenOut; j++, x++, y++) {
              if (src[x] !== out[y]) break;
            }
            j--;

            // Beginning at iSrc-1, match backwards as far as we can.
            // k counts the number of characters that match.
            for (k = 1; k < iSrc && k <= i; k++) {
              if (src[iSrc-k] !== out[base+i-k]) break;
            }
            k--;

            // Compute the offset and size of the matching region.
            ofst = iSrc-k;
            cnt = j+k+1;
            litsz = i-k;  // Number of bytes of literal text before the copy
            // sz will hold the number of bytes needed to encode the "insert"
            // command and the copy command, not counting the "insert" text.
            sz = digitCount(i-k)+digitCount(cnt)+digitCount(ofst)+3;
            if (cnt >= sz && cnt > bestCnt) {
              // Remember this match only if it is the best so far and it
              // does not increase the file size.
              bestCnt = cnt;
              bestOfst = iSrc-k;
              bestLitsz = litsz;
            }

            // Check the next matching block
            iBlock = collide[iBlock];
          }

          // We have a copy command that does not cause the delta to be larger
          // than a literal insert.  So add the copy command to the delta.
          if (bestCnt > 0) {
            if (bestLitsz > 0) {
              // Add an insert command before the copy.
              zDelta.putInt(bestLitsz);
              zDelta.putChar(':');
              zDelta.putArray(out, base, base+bestLitsz);
              base += bestLitsz;
            }
            base += bestCnt;
            zDelta.putInt(bestCnt);
            zDelta.putChar('@');
            zDelta.putInt(bestOfst);
            zDelta.putChar(',');
            bestCnt = 0;
            break;
          }

          // If we reach this point, it means no match is found so far
          if (base+i+NHASH >= lenOut){
            // We have reached the end and have not found any
            // matches.  Do an "insert" for everything that does not match
            zDelta.putInt(lenOut-base);
            zDelta.putChar(':');
            zDelta.putArray(out, base, base+lenOut-base);
            base = lenOut;
            break;
          }

          // Advance the hash by one character. Keep looking for a match.
          h.next(out[base+i+NHASH]);
          i++;
        }
      }
      // Output a final "insert" record to get all the text at the end of
      // the file that does not match anything in the source.
      if(base < lenOut) {
        zDelta.putInt(lenOut-base);
        zDelta.putChar(':');
        zDelta.putArray(out, base, base+lenOut-base);
      }
      // Output the final checksum record.
      zDelta.putInt(checksum(out));
      zDelta.putChar(';');
      return zDelta.toArray();
    };

    // Return the size (in bytes) of the output from applying a delta.
    fossilDelta.outputSize = function(delta){
      var zDelta = new Reader(delta);
      var size = zDelta.getInt();
      if (zDelta.getChar() !== '\n')
        throw new Error('size integer not terminated by \'\\n\'');
      return size;
    };

    // Apply a delta.
    fossilDelta.apply = function(src, delta, opts) {
      var limit, total = 0;
      var zDelta = new Reader(delta);
      var lenSrc = src.length;
      var lenDelta = delta.length;

      limit = zDelta.getInt();
      if (zDelta.getChar() !== '\n')
        throw new Error('size integer not terminated by \'\\n\'');
      var zOut = new Writer();
      while(zDelta.haveBytes()) {
        var cnt, ofst;
        cnt = zDelta.getInt();

        switch (zDelta.getChar()) {
          case '@':
            ofst = zDelta.getInt();
            if (zDelta.haveBytes() && zDelta.getChar() !== ',')
              throw new Error('copy command not terminated by \',\'');
            total += cnt;
            if (total > limit)
              throw new Error('copy exceeds output file size');
            if (ofst+cnt > lenSrc)
              throw new Error('copy extends past end of input');
            zOut.putArray(src, ofst, ofst+cnt);
            break;

          case ':':
            total += cnt;
            if (total > limit)
              throw new Error('insert command gives an output larger than predicted');
            if (cnt > lenDelta)
              throw new Error('insert count exceeds size of delta');
            zOut.putArray(zDelta.a, zDelta.pos, zDelta.pos+cnt);
            zDelta.pos += cnt;
            break;

          case ';':
            var out = zOut.toArray();
            if ((!opts || opts.verifyChecksum !== false) && cnt !== checksum(out))
              throw new Error('bad checksum');
            if (total !== limit)
              throw new Error('generated size does not match predicted size');
            return out;

          default:
            throw new Error('unknown delta operator');
        }
      }
      throw new Error('unterminated delta');
    };

    return fossilDelta;

    });
    });

    var FossilDeltaSerializer_1 = createCommonjsModule(function (module, exports) {
    var __createBinding = (commonjsGlobal && commonjsGlobal.__createBinding) || (Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }));
    var __setModuleDefault = (commonjsGlobal && commonjsGlobal.__setModuleDefault) || (Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    });
    var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FossilDeltaSerializer = void 0;

    var fossilDelta$1 = __importStar(fossilDelta);
    var msgpack$1 = __importStar(msgpack);
    var FossilDeltaSerializer = /** @class */ (function () {
        function FossilDeltaSerializer() {
            this.api = new lib$2.StateContainer({});
        }
        FossilDeltaSerializer.prototype.getState = function () {
            return this.api.state;
        };
        FossilDeltaSerializer.prototype.setState = function (encodedState) {
            this.previousState = new Uint8Array(encodedState);
            this.api.set(msgpack$1.decode(this.previousState));
        };
        FossilDeltaSerializer.prototype.patch = function (binaryPatch) {
            // apply patch
            this.previousState = new Uint8Array(fossilDelta$1.apply(this.previousState, binaryPatch));
            // trigger update callbacks
            this.api.set(msgpack$1.decode(this.previousState));
        };
        FossilDeltaSerializer.prototype.teardown = function () {
            this.api.removeAllListeners();
        };
        return FossilDeltaSerializer;
    }());
    exports.FossilDeltaSerializer = FossilDeltaSerializer;

    });

    var ChangeTree_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChangeTree = exports.Root = void 0;


    //
    // Root holds all schema references by unique id
    //
    var Root = /** @class */ (function () {
        function Root() {
            //
            // Relation of refId => Schema structure
            // For direct access of structures during decoding time.
            //
            this.refs = new Map();
            this.refCounts = {};
            this.deletedRefs = new Set();
            this.nextUniqueId = 0;
        }
        Root.prototype.getNextUniqueId = function () {
            return this.nextUniqueId++;
        };
        // for decoding
        Root.prototype.addRef = function (refId, ref, incrementCount) {
            if (incrementCount === void 0) { incrementCount = true; }
            this.refs.set(refId, ref);
            if (incrementCount) {
                this.refCounts[refId] = (this.refCounts[refId] || 0) + 1;
            }
        };
        // for decoding
        Root.prototype.removeRef = function (refId) {
            this.refCounts[refId] = this.refCounts[refId] - 1;
            this.deletedRefs.add(refId);
        };
        Root.prototype.clearRefs = function () {
            this.refs.clear();
            this.deletedRefs.clear();
            this.refCounts = {};
        };
        // for decoding
        Root.prototype.garbageCollectDeletedRefs = function () {
            var _this = this;
            this.deletedRefs.forEach(function (refId) {
                if (_this.refCounts[refId] <= 0) {
                    var ref = _this.refs.get(refId);
                    //
                    // Ensure child schema instances have their references removed as well.
                    //
                    if (ref instanceof Schema_1.Schema) {
                        for (var fieldName in ref['_definition'].schema) {
                            if (typeof (ref['_definition'].schema[fieldName]) !== "string" &&
                                ref[fieldName] &&
                                ref[fieldName]['$changes']) {
                                _this.removeRef(ref[fieldName]['$changes'].refId);
                            }
                        }
                    }
                    else {
                        var definition = ref['$changes'].parent._definition;
                        var type = definition.schema[definition.fieldsByIndex[ref['$changes'].parentIndex]];
                        if (typeof (Object.values(type)[0]) === "function") {
                            Array.from(ref.values())
                                .forEach(function (child) { return _this.removeRef(child['$changes'].refId); });
                        }
                    }
                    _this.refs.delete(refId);
                    delete _this.refCounts[refId];
                }
            });
            // clear deleted refs.
            this.deletedRefs.clear();
        };
        return Root;
    }());
    exports.Root = Root;
    var ChangeTree = /** @class */ (function () {
        function ChangeTree(ref, parent, root) {
            this.changed = false;
            this.changes = new Map();
            this.allChanges = new Set();
            // cached indexes for filtering
            this.caches = {};
            this.currentCustomOperation = 0;
            this.ref = ref;
            this.setParent(parent, root);
        }
        ChangeTree.prototype.setParent = function (parent, root, parentIndex) {
            var _this = this;
            if (!this.indexes) {
                this.indexes = (this.ref instanceof Schema_1.Schema)
                    ? this.ref['_definition'].indexes
                    : {};
            }
            this.parent = parent;
            this.parentIndex = parentIndex;
            // avoid setting parents with empty `root`
            if (!root) {
                return;
            }
            this.root = root;
            //
            // assign same parent on child structures
            //
            if (this.ref instanceof Schema_1.Schema) {
                var definition = this.ref['_definition'];
                for (var field in definition.schema) {
                    var value = this.ref[field];
                    if (value && value['$changes']) {
                        var parentIndex_1 = definition.indexes[field];
                        value['$changes'].setParent(this.ref, root, parentIndex_1);
                    }
                }
            }
            else if (typeof (this.ref) === "object") {
                this.ref.forEach(function (value, key) {
                    if (value instanceof Schema_1.Schema) {
                        var changeTreee = value['$changes'];
                        var parentIndex_2 = _this.ref['$changes'].indexes[key];
                        changeTreee.setParent(_this.ref, _this.root, parentIndex_2);
                    }
                });
            }
        };
        ChangeTree.prototype.operation = function (op) {
            this.changes.set(--this.currentCustomOperation, op);
        };
        ChangeTree.prototype.change = function (fieldName, operation) {
            if (operation === void 0) { operation = spec.OPERATION.ADD; }
            var index = (typeof (fieldName) === "number")
                ? fieldName
                : this.indexes[fieldName];
            this.assertValidIndex(index, fieldName);
            var previousChange = this.changes.get(index);
            if (!previousChange ||
                previousChange.op === spec.OPERATION.DELETE ||
                previousChange.op === spec.OPERATION.TOUCH // (mazmorra.io's BattleAction issue)
            ) {
                this.changes.set(index, {
                    op: (!previousChange)
                        ? operation
                        : (previousChange.op === spec.OPERATION.DELETE)
                            ? spec.OPERATION.DELETE_AND_ADD
                            : operation,
                    // : OPERATION.REPLACE,
                    index: index
                });
            }
            this.allChanges.add(index);
            this.changed = true;
            this.touchParents();
        };
        ChangeTree.prototype.touch = function (fieldName) {
            var index = (typeof (fieldName) === "number")
                ? fieldName
                : this.indexes[fieldName];
            this.assertValidIndex(index, fieldName);
            if (!this.changes.has(index)) {
                this.changes.set(index, { op: spec.OPERATION.TOUCH, index: index });
            }
            this.allChanges.add(index);
            // ensure touch is placed until the $root is found.
            this.touchParents();
        };
        ChangeTree.prototype.touchParents = function () {
            if (this.parent) {
                this.parent['$changes'].touch(this.parentIndex);
            }
        };
        ChangeTree.prototype.getType = function (index) {
            if (this.ref['_definition']) {
                var definition = this.ref['_definition'];
                return definition.schema[definition.fieldsByIndex[index]];
            }
            else {
                var definition = this.parent['_definition'];
                var parentType = definition.schema[definition.fieldsByIndex[this.parentIndex]];
                //
                // Get the child type from parent structure.
                // - ["string"] => "string"
                // - { map: "string" } => "string"
                // - { set: "string" } => "string"
                //
                return Object.values(parentType)[0];
            }
        };
        ChangeTree.prototype.getChildrenFilter = function () {
            var childFilters = this.parent['_definition'].childFilters;
            return childFilters && childFilters[this.parentIndex];
        };
        //
        // used during `.encode()`
        //
        ChangeTree.prototype.getValue = function (index) {
            return this.ref['getByIndex'](index);
        };
        ChangeTree.prototype.delete = function (fieldName) {
            var index = (typeof (fieldName) === "number")
                ? fieldName
                : this.indexes[fieldName];
            if (index === undefined) {
                console.warn("@colyseus/schema " + this.ref.constructor.name + ": trying to delete non-existing index: " + fieldName + " (" + index + ")");
                return;
            }
            var previousValue = this.getValue(index);
            // console.log("$changes.delete =>", { fieldName, index, previousValue });
            this.changes.set(index, { op: spec.OPERATION.DELETE, index: index });
            this.allChanges.delete(index);
            // delete cache
            delete this.caches[index];
            // remove `root` reference
            if (previousValue && previousValue['$changes']) {
                previousValue['$changes'].parent = undefined;
            }
            this.changed = true;
            this.touchParents();
        };
        ChangeTree.prototype.discard = function (changed, discardAll) {
            var _this = this;
            if (changed === void 0) { changed = false; }
            if (discardAll === void 0) { discardAll = false; }
            //
            // Map, Array, etc:
            // Remove cached key to ensure ADD operations is unsed instead of
            // REPLACE in case same key is used on next patches.
            //
            // TODO: refactor this. this is not relevant for Collection and Set.
            //
            if (!(this.ref instanceof Schema_1.Schema)) {
                this.changes.forEach(function (change) {
                    if (change.op === spec.OPERATION.DELETE) {
                        var index = _this.ref['getIndex'](change.index);
                        delete _this.indexes[index];
                    }
                });
            }
            this.changes.clear();
            this.changed = changed;
            if (discardAll) {
                this.allChanges.clear();
            }
            // re-set `currentCustomOperation`
            this.currentCustomOperation = 0;
        };
        /**
         * Recursively discard all changes from this, and child structures.
         */
        ChangeTree.prototype.discardAll = function () {
            var _this = this;
            this.changes.forEach(function (change) {
                var value = _this.getValue(change.index);
                if (value && value['$changes']) {
                    value['$changes'].discardAll();
                }
            });
            this.discard();
        };
        // cache(field: number, beginIndex: number, endIndex: number) {
        ChangeTree.prototype.cache = function (field, cachedBytes) {
            this.caches[field] = cachedBytes;
        };
        ChangeTree.prototype.clone = function () {
            return new ChangeTree(this.ref, this.parent, this.root);
        };
        ChangeTree.prototype.ensureRefId = function () {
            // skip if refId is already set.
            if (this.refId !== undefined) {
                return;
            }
            this.refId = this.root.getNextUniqueId();
        };
        ChangeTree.prototype.assertValidIndex = function (index, fieldName) {
            if (index === undefined) {
                throw new Error("ChangeTree: missing index for field \"" + fieldName + "\"");
            }
        };
        return ChangeTree;
    }());
    exports.ChangeTree = ChangeTree;

    });

    var types = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getType = exports.registerType = void 0;
    var registeredTypes = {};
    function registerType(identifier, definition) {
        registeredTypes[identifier] = definition;
    }
    exports.registerType = registerType;
    function getType(identifier) {
        return registeredTypes[identifier];
    }
    exports.getType = getType;

    });

    var ArraySchema_1 = createCommonjsModule(function (module, exports) {
    var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArraySchema = exports.getArrayProxy = void 0;




    var DEFAULT_SORT = function (a, b) {
        var A = a.toString();
        var B = b.toString();
        if (A < B)
            return -1;
        else if (A > B)
            return 1;
        else
            return 0;
    };
    function getArrayProxy(value) {
        value['$proxy'] = true;
        //
        // compatibility with @colyseus/schema 0.5.x
        // - allow `map["key"]`
        // - allow `map["key"] = "xxx"`
        // - allow `delete map["key"]`
        //
        value = new Proxy(value, {
            get: function (obj, prop) {
                if (typeof (prop) !== "symbol" &&
                    !isNaN(prop) // https://stackoverflow.com/a/175787/892698
                ) {
                    return obj.at(prop);
                }
                else {
                    return obj[prop];
                }
            },
            set: function (obj, prop, setValue) {
                if (typeof (prop) !== "symbol" &&
                    !isNaN(prop)) {
                    var indexes = Array.from(obj['$items'].keys());
                    var key = parseInt(indexes[prop] || prop);
                    if (setValue === undefined || setValue === null) {
                        obj.deleteAt(key);
                    }
                    else {
                        obj.setAt(key, setValue);
                    }
                }
                else {
                    obj[prop] = setValue;
                }
                return true;
            },
            deleteProperty: function (obj, prop) {
                if (typeof (prop) === "number") {
                    obj.deleteAt(prop);
                }
                else {
                    delete obj[prop];
                }
                return true;
            },
        });
        return value;
    }
    exports.getArrayProxy = getArrayProxy;
    var ArraySchema = /** @class */ (function () {
        function ArraySchema() {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            this.$changes = new ChangeTree_1.ChangeTree(this);
            this.$items = new Map();
            this.$indexes = new Map();
            this.$refId = 0;
            this.push.apply(this, __spread(items));
        }
        ArraySchema.is = function (type) {
            return Array.isArray(type);
        };
        Object.defineProperty(ArraySchema.prototype, "length", {
            get: function () {
                return this.$items.size;
            },
            set: function (value) {
                if (value === 0) {
                    this.clear();
                }
                else {
                    this.splice(value, this.length - value);
                }
            },
            enumerable: false,
            configurable: true
        });
        ArraySchema.prototype.push = function () {
            var _this = this;
            var values = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                values[_i] = arguments[_i];
            }
            var lastIndex;
            values.forEach(function (value) {
                // set "index" for reference.
                lastIndex = _this.$refId++;
                _this.setAt(lastIndex, value);
            });
            return lastIndex;
        };
        /**
         * Removes the last element from an array and returns it.
         */
        ArraySchema.prototype.pop = function () {
            var key = Array.from(this.$indexes.values()).pop();
            if (key === undefined) {
                return undefined;
            }
            this.$changes.delete(key);
            this.$indexes.delete(key);
            var value = this.$items.get(key);
            this.$items.delete(key);
            return value;
        };
        ArraySchema.prototype.at = function (index) {
            //
            // FIXME: this should be O(1)
            //
            var key = Array.from(this.$items.keys())[index];
            return this.$items.get(key);
        };
        ArraySchema.prototype.setAt = function (index, value) {
            if (value['$changes'] !== undefined) {
                value['$changes'].setParent(this, this.$changes.root, index);
            }
            var operation = (this.$changes.indexes[index] !== undefined)
                ? spec.OPERATION.REPLACE
                : spec.OPERATION.ADD;
            this.$changes.indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this.$changes.change(index, operation);
        };
        ArraySchema.prototype.deleteAt = function (index) {
            var key = Array.from(this.$items.keys())[index];
            if (key === undefined) {
                return false;
            }
            return this.$deleteAt(key);
        };
        ArraySchema.prototype.$deleteAt = function (index) {
            // delete at internal index
            this.$changes.delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        };
        ArraySchema.prototype.clear = function (isDecoding) {
            var _this = this;
            // discard previous operations.
            this.$changes.discard(true, true);
            this.$changes.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // flag child items for garbage collection.
            if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                this.$items.forEach(function (item) {
                    _this.$changes.root.removeRef(item['$changes'].refId);
                });
            }
            // clear items
            this.$items.clear();
            this.$changes.operation({ index: 0, op: spec.OPERATION.CLEAR });
            // touch all structures until reach root
            this.$changes.touchParents();
        };
        /**
         * Combines two or more arrays.
         * @param items Additional items to add to the end of array1.
         */
        ArraySchema.prototype.concat = function () {
            var _a;
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            return new (ArraySchema.bind.apply(ArraySchema, __spread([void 0], (_a = Array.from(this.$items.values())).concat.apply(_a, __spread(items)))))();
        };
        /**
         * Adds all the elements of an array separated by the specified separator string.
         * @param separator A string used to separate one element of an array from the next in the resulting String. If omitted, the array elements are separated with a comma.
         */
        ArraySchema.prototype.join = function (separator) {
            return Array.from(this.$items.values()).join(separator);
        };
        /**
         * Reverses the elements in an Array.
         */
        ArraySchema.prototype.reverse = function () {
            var _this = this;
            var indexes = Array.from(this.$items.keys());
            var reversedItems = Array.from(this.$items.values()).reverse();
            reversedItems.forEach(function (item, i) {
                _this.setAt(indexes[i], item);
            });
            return this;
        };
        /**
         * Removes the first element from an array and returns it.
         */
        ArraySchema.prototype.shift = function () {
            var indexes = Array.from(this.$items.keys());
            var shiftAt = indexes.shift();
            if (shiftAt === undefined) {
                return undefined;
            }
            var value = this.$items.get(shiftAt);
            this.$deleteAt(shiftAt);
            return value;
        };
        /**
         * Returns a section of an array.
         * @param start The beginning of the specified portion of the array.
         * @param end The end of the specified portion of the array. This is exclusive of the element at the index 'end'.
         */
        ArraySchema.prototype.slice = function (start, end) {
            return new (ArraySchema.bind.apply(ArraySchema, __spread([void 0], Array.from(this.$items.values()).slice(start, end))))();
        };
        /**
         * Sorts an array.
         * @param compareFn Function used to determine the order of the elements. It is expected to return
         * a negative value if first argument is less than second argument, zero if they're equal and a positive
         * value otherwise. If omitted, the elements are sorted in ascending, ASCII character order.
         * ```ts
         * [11,2,22,1].sort((a, b) => a - b)
         * ```
         */
        ArraySchema.prototype.sort = function (compareFn) {
            var _this = this;
            if (compareFn === void 0) { compareFn = DEFAULT_SORT; }
            var indexes = Array.from(this.$items.keys());
            var sortedItems = Array.from(this.$items.values()).sort(compareFn);
            sortedItems.forEach(function (item, i) {
                _this.setAt(indexes[i], item);
            });
            return this;
        };
        /**
         * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
         * @param start The zero-based location in the array from which to start removing elements.
         * @param deleteCount The number of elements to remove.
         * @param items Elements to insert into the array in place of the deleted elements.
         */
        ArraySchema.prototype.splice = function (start, deleteCount) {
            if (deleteCount === void 0) { deleteCount = this.length - start; }
            var items = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                items[_i - 2] = arguments[_i];
            }
            var indexes = Array.from(this.$items.keys());
            var removedItems = [];
            for (var i = start; i < start + deleteCount; i++) {
                removedItems.push(this.$items.get(indexes[i]));
                this.$deleteAt(indexes[i]);
            }
            return removedItems;
        };
        /**
         * Inserts new elements at the start of an array.
         * @param items  Elements to insert at the start of the Array.
         */
        ArraySchema.prototype.unshift = function () {
            var _this = this;
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            var length = this.length;
            var addedLength = items.length;
            // const indexes = Array.from(this.$items.keys());
            var previousValues = Array.from(this.$items.values());
            items.forEach(function (item, i) {
                _this.setAt(i, item);
            });
            previousValues.forEach(function (previousValue, i) {
                _this.setAt(addedLength + i, previousValue);
            });
            return length + addedLength;
        };
        /**
         * Returns the index of the first occurrence of a value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.
         */
        ArraySchema.prototype.indexOf = function (searchElement, fromIndex) {
            return Array.from(this.$items.values()).indexOf(searchElement, fromIndex);
        };
        /**
         * Returns the index of the last occurrence of a specified value in an array.
         * @param searchElement The value to locate in the array.
         * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at the last index in the array.
         */
        ArraySchema.prototype.lastIndexOf = function (searchElement, fromIndex) {
            if (fromIndex === void 0) { fromIndex = this.length - 1; }
            return Array.from(this.$items.values()).lastIndexOf(searchElement, fromIndex);
        };
        /**
         * Determines whether all the members of an array satisfy the specified test.
         * @param callbackfn A function that accepts up to three arguments. The every method calls
         * the callbackfn function for each element in the array until the callbackfn returns a value
         * which is coercible to the Boolean value false, or until the end of the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function.
         * If thisArg is omitted, undefined is used as the this value.
         */
        ArraySchema.prototype.every = function (callbackfn, thisArg) {
            return Array.from(this.$items.values()).every(callbackfn, thisArg);
        };
        /**
         * Determines whether the specified callback function returns true for any element of an array.
         * @param callbackfn A function that accepts up to three arguments. The some method calls
         * the callbackfn function for each element in the array until the callbackfn returns a value
         * which is coercible to the Boolean value true, or until the end of the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function.
         * If thisArg is omitted, undefined is used as the this value.
         */
        ArraySchema.prototype.some = function (callbackfn, thisArg) {
            return Array.from(this.$items.values()).some(callbackfn, thisArg);
        };
        /**
         * Performs the specified action for each element in an array.
         * @param callbackfn  A function that accepts up to three arguments. forEach calls the callbackfn function one time for each element in the array.
         * @param thisArg  An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        ArraySchema.prototype.forEach = function (callbackfn, thisArg) {
            Array.from(this.$items.values()).forEach(callbackfn, thisArg);
        };
        /**
         * Calls a defined callback function on each element of an array, and returns an array that contains the results.
         * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
         */
        ArraySchema.prototype.map = function (callbackfn, thisArg) {
            return Array.from(this.$items.values()).map(callbackfn, thisArg);
        };
        ArraySchema.prototype.filter = function (callbackfn, thisArg) {
            return Array.from(this.$items.values()).filter(callbackfn, thisArg);
        };
        /**
         * Calls the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduce method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        ArraySchema.prototype.reduce = function (callbackfn, initialValue) {
            return Array.from(this.$items.values()).reduce(callbackfn, initialValue);
        };
        /**
         * Calls the specified callback function for all the elements in an array, in descending order. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.
         * @param callbackfn A function that accepts up to four arguments. The reduceRight method calls the callbackfn function one time for each element in the array.
         * @param initialValue If initialValue is specified, it is used as the initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.
         */
        ArraySchema.prototype.reduceRight = function (callbackfn, initialValue) {
            return Array.from(this.$items.values()).reduceRight(callbackfn, initialValue);
        };
        /**
         * Returns the value of the first element in the array where predicate is true, and undefined
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found, find
         * immediately returns that element value. Otherwise, find returns undefined.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        ArraySchema.prototype.find = function (predicate, thisArg) {
            return Array.from(this.$items.values()).find(predicate, thisArg);
        };
        /**
         * Returns the index of the first element in the array where predicate is true, and -1
         * otherwise.
         * @param predicate find calls predicate once for each element of the array, in ascending
         * order, until it finds one where predicate returns true. If such an element is found,
         * findIndex immediately returns that element index. Otherwise, findIndex returns -1.
         * @param thisArg If provided, it will be used as the this value for each invocation of
         * predicate. If it is not provided, undefined is used instead.
         */
        ArraySchema.prototype.findIndex = function (predicate, thisArg) {
            return Array.from(this.$items.values()).findIndex(predicate, thisArg);
        };
        /**
         * Returns the this object after filling the section identified by start and end with value
         * @param value value to fill array section with
         * @param start index to start filling the array at. If start is negative, it is treated as
         * length+start where length is the length of the array.
         * @param end index to stop filling the array at. If end is negative, it is treated as
         * length+end.
         */
        ArraySchema.prototype.fill = function (value, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#fill() not implemented");
        };
        /**
         * Returns the this object after copying a section of the array identified by start and end
         * to the same array starting at position target
         * @param target If target is negative, it is treated as length+target where length is the
         * length of the array.
         * @param start If start is negative, it is treated as length+start. If end is negative, it
         * is treated as length+end.
         * @param end If not specified, length of the this object is used as its default value.
         */
        ArraySchema.prototype.copyWithin = function (target, start, end) {
            //
            // TODO
            //
            throw new Error("ArraySchema#copyWithin() not implemented");
        };
        /**
         * Returns a string representation of an array.
         */
        ArraySchema.prototype.toString = function () { return this.$items.toString(); };
        /**
         * Returns a string representation of an array. The elements are converted to string using their toLocalString methods.
         */
        ArraySchema.prototype.toLocaleString = function () { return this.$items.toLocaleString(); };
        /** Iterator */
        ArraySchema.prototype[Symbol.iterator] = function () {
            return Array.from(this.$items.values())[Symbol.iterator]();
        };
        ArraySchema.prototype[Symbol.unscopables] = function () {
            return this.$items[Symbol.unscopables]();
        };
        /**
         * Returns an iterable of key, value pairs for every entry in the array
         */
        ArraySchema.prototype.entries = function () { return this.$items.entries(); };
        /**
         * Returns an iterable of keys in the array
         */
        ArraySchema.prototype.keys = function () { return this.$items.keys(); };
        /**
         * Returns an iterable of values in the array
         */
        ArraySchema.prototype.values = function () { return this.$items.values(); };
        /**
         * Determines whether an array includes a certain element, returning true or false as appropriate.
         * @param searchElement The element to search for.
         * @param fromIndex The position in this array at which to begin searching for searchElement.
         */
        ArraySchema.prototype.includes = function (searchElement, fromIndex) {
            return Array.from(this.$items.values()).includes(searchElement, fromIndex);
        };
        /**
         * Calls a defined callback function on each element of an array. Then, flattens the result into
         * a new array.
         * This is identical to a map followed by flat with depth 1.
         *
         * @param callback A function that accepts up to three arguments. The flatMap method calls the
         * callback function one time for each element in the array.
         * @param thisArg An object to which the this keyword can refer in the callback function. If
         * thisArg is omitted, undefined is used as the this value.
         */
        // @ts-ignore
        ArraySchema.prototype.flatMap = function (callback, thisArg) {
            // @ts-ignore
            throw new Error("ArraySchema#flatMap() is not supported.");
        };
        /**
         * Returns a new array with all sub-array elements concatenated into it recursively up to the
         * specified depth.
         *
         * @param depth The maximum recursion depth
         */
        // @ts-ignore
        ArraySchema.prototype.flat = function (depth) {
            // @ts-ignore
            throw new Error("ArraySchema#flat() is not supported.");
        };
        // get size () {
        //     return this.$items.size;
        // }
        ArraySchema.prototype.setIndex = function (index, key) {
            this.$indexes.set(index, key);
        };
        ArraySchema.prototype.getIndex = function (index) {
            return this.$indexes.get(index);
        };
        ArraySchema.prototype.getByIndex = function (index) {
            return this.$items.get(this.$indexes.get(index));
        };
        ArraySchema.prototype.deleteByIndex = function (index) {
            var key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        };
        ArraySchema.prototype.toArray = function () {
            return Array.from(this.$items.values());
        };
        ArraySchema.prototype.toJSON = function () {
            return this.toArray().map(function (value) {
                return (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
        };
        //
        // Decoding utilities
        //
        ArraySchema.prototype.clone = function (isDecoding) {
            var cloned;
            if (isDecoding) {
                cloned = new (ArraySchema.bind.apply(ArraySchema, __spread([void 0], Array.from(this.$items.values()))))();
            }
            else {
                cloned = new (ArraySchema.bind.apply(ArraySchema, __spread([void 0], this.map(function (item) { return ((item['$changes'])
                    ? item.clone()
                    : item); }))))();
            }
            return cloned;
        };
        ArraySchema.prototype.triggerAll = function () {
            Schema_1.Schema.prototype.triggerAll.apply(this);
        };
        return ArraySchema;
    }());
    exports.ArraySchema = ArraySchema;
    types.registerType("array", {
        constructor: ArraySchema,
        getProxy: getArrayProxy,
    });

    });

    var MapSchema_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MapSchema = exports.getMapProxy = void 0;




    function getMapProxy(value) {
        value['$proxy'] = true;
        value = new Proxy(value, {
            get: function (obj, prop) {
                if (typeof (prop) !== "symbol" && // accessing properties
                    typeof (obj[prop]) === "undefined") {
                    return obj.get(prop);
                }
                else {
                    return obj[prop];
                }
            },
            set: function (obj, prop, setValue) {
                if (typeof (prop) !== "symbol" &&
                    (prop.indexOf("$") === -1 &&
                        prop !== "onAdd" &&
                        prop !== "onRemove" &&
                        prop !== "onChange")) {
                    obj.set(prop, setValue);
                }
                else {
                    obj[prop] = setValue;
                }
                return true;
            },
            deleteProperty: function (obj, prop) {
                obj.delete(prop);
                return true;
            },
        });
        return value;
    }
    exports.getMapProxy = getMapProxy;
    var MapSchema = /** @class */ (function () {
        function MapSchema(initialValues) {
            var _this = this;
            this.$changes = new ChangeTree_1.ChangeTree(this);
            this.$items = new Map();
            this.$indexes = new Map();
            this.$refId = 0;
            if (initialValues) {
                if (initialValues instanceof Map) {
                    initialValues.forEach(function (v, k) { return _this.set(k, v); });
                }
                else {
                    for (var k in initialValues) {
                        this.set(k, initialValues[k]);
                    }
                }
            }
        }
        MapSchema.is = function (type) {
            return type['map'] !== undefined;
        };
        /** Iterator */
        MapSchema.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); };
        Object.defineProperty(MapSchema.prototype, Symbol.toStringTag, {
            get: function () { return this.$items[Symbol.toStringTag]; },
            enumerable: false,
            configurable: true
        });
        MapSchema.prototype.set = function (key, value) {
            // get "index" for this value.
            var hasIndex = typeof (this.$changes.indexes[key]) !== "undefined";
            var index = (hasIndex)
                ? this.$changes.indexes[key]
                : this.$refId++;
            var operation = (hasIndex)
                ? spec.OPERATION.REPLACE
                : spec.OPERATION.ADD;
            var isRef = (value['$changes']) !== undefined;
            if (isRef) {
                value['$changes'].setParent(this, this.$changes.root, index);
            }
            //
            // (encoding)
            // set a unique id to relate directly with this key/value.
            //
            if (!hasIndex) {
                this.$changes.indexes[key] = index;
                this.$indexes.set(index, key);
            }
            else if (isRef && // if is schema, force ADD operation if value differ from previous one.
                this.$items.get(key) !== value) {
                operation = spec.OPERATION.ADD;
            }
            this.$items.set(key, value);
            this.$changes.change(key, operation);
            return this;
        };
        MapSchema.prototype.get = function (key) {
            return this.$items.get(key);
        };
        MapSchema.prototype.delete = function (key) {
            //
            // TODO: add a "purge" method after .encode() runs, to cleanup removed `$indexes`
            //
            // We don't remove $indexes to allow setting the same key in the same patch
            // (See "should allow to remove and set an item in the same place" test)
            //
            // // const index = this.$changes.indexes[key];
            // // this.$indexes.delete(index);
            this.$changes.delete(key);
            return this.$items.delete(key);
        };
        MapSchema.prototype.clear = function (isDecoding) {
            var _this = this;
            // discard previous operations.
            this.$changes.discard(true, true);
            this.$changes.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // flag child items for garbage collection.
            if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                this.$items.forEach(function (item) {
                    _this.$changes.root.removeRef(item['$changes'].refId);
                });
            }
            // clear items
            this.$items.clear();
            this.$changes.operation({ index: 0, op: spec.OPERATION.CLEAR });
            // touch all structures until reach root
            this.$changes.touchParents();
        };
        MapSchema.prototype.has = function (key) {
            return this.$items.has(key);
        };
        MapSchema.prototype.forEach = function (callbackfn) {
            this.$items.forEach(callbackfn);
        };
        MapSchema.prototype.entries = function () {
            return this.$items.entries();
        };
        MapSchema.prototype.keys = function () {
            return this.$items.keys();
        };
        MapSchema.prototype.values = function () {
            return this.$items.values();
        };
        Object.defineProperty(MapSchema.prototype, "size", {
            get: function () {
                return this.$items.size;
            },
            enumerable: false,
            configurable: true
        });
        MapSchema.prototype.setIndex = function (index, key) {
            this.$indexes.set(index, key);
        };
        MapSchema.prototype.getIndex = function (index) {
            return this.$indexes.get(index);
        };
        MapSchema.prototype.getByIndex = function (index) {
            return this.$items.get(this.$indexes.get(index));
        };
        MapSchema.prototype.deleteByIndex = function (index) {
            var key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        };
        MapSchema.prototype.toJSON = function () {
            var map = {};
            this.forEach(function (value, key) {
                map[key] = (typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value;
            });
            return map;
        };
        //
        // Decoding utilities
        //
        MapSchema.prototype.clone = function (isDecoding) {
            var cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new MapSchema(), this);
            }
            else {
                // server-side
                var cloned_1 = new MapSchema();
                this.forEach(function (value, key) {
                    if (value['$changes']) {
                        cloned_1.set(key, value['clone']());
                    }
                    else {
                        cloned_1.set(key, value);
                    }
                });
            }
            return cloned;
        };
        MapSchema.prototype.triggerAll = function () {
            Schema_1.Schema.prototype.triggerAll.apply(this);
        };
        return MapSchema;
    }());
    exports.MapSchema = MapSchema;
    types.registerType("map", {
        constructor: MapSchema,
        getProxy: getMapProxy,
    });

    });

    var annotations = createCommonjsModule(function (module, exports) {
    var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineTypes = exports.deprecated = exports.filterChildren = exports.filter = exports.type = exports.globalContext = exports.Context = exports.hasFilter = exports.SchemaDefinition = void 0;




    var SchemaDefinition = /** @class */ (function () {
        function SchemaDefinition() {
            //
            // TODO: use a "field" structure combining all these properties per-field.
            //
            this.indexes = {};
            this.fieldsByIndex = {};
            this.deprecated = {};
            this.descriptors = {};
        }
        SchemaDefinition.create = function (parent) {
            var definition = new SchemaDefinition();
            // support inheritance
            definition.schema = Object.assign({}, parent && parent.schema || {});
            definition.indexes = Object.assign({}, parent && parent.indexes || {});
            definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});
            definition.descriptors = Object.assign({}, parent && parent.descriptors || {});
            definition.deprecated = Object.assign({}, parent && parent.deprecated || {});
            return definition;
        };
        SchemaDefinition.prototype.addField = function (field, type) {
            var index = this.getNextFieldIndex();
            this.fieldsByIndex[index] = field;
            this.indexes[field] = index;
            this.schema[field] = (Array.isArray(type))
                ? { array: type[0] }
                : type;
        };
        SchemaDefinition.prototype.addFilter = function (field, cb) {
            if (!this.filters) {
                this.filters = {};
                this.indexesWithFilters = [];
            }
            this.filters[this.indexes[field]] = cb;
            this.indexesWithFilters.push(this.indexes[field]);
            return true;
        };
        SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {
            var index = this.indexes[field];
            var type = this.schema[field];
            if (types.getType(Object.keys(type)[0])) {
                if (!this.childFilters) {
                    this.childFilters = {};
                }
                this.childFilters[index] = cb;
                return true;
            }
            else {
                console.warn("@filterChildren: field '" + field + "' can't have children. Ignoring filter.");
            }
        };
        SchemaDefinition.prototype.getChildrenFilter = function (field) {
            return this.childFilters && this.childFilters[this.indexes[field]];
        };
        SchemaDefinition.prototype.getNextFieldIndex = function () {
            return Object.keys(this.schema || {}).length;
        };
        return SchemaDefinition;
    }());
    exports.SchemaDefinition = SchemaDefinition;
    function hasFilter(klass) {
        return klass._context && klass._context.useFilters;
    }
    exports.hasFilter = hasFilter;
    var Context = /** @class */ (function () {
        function Context() {
            this.types = {};
            this.schemas = new Map();
            this.useFilters = false;
        }
        Context.prototype.has = function (schema) {
            return this.schemas.has(schema);
        };
        Context.prototype.get = function (typeid) {
            return this.types[typeid];
        };
        Context.prototype.add = function (schema, typeid) {
            if (typeid === void 0) { typeid = this.schemas.size; }
            // FIXME: move this to somewhere else?
            // support inheritance
            schema._definition = SchemaDefinition.create(schema._definition);
            schema._typeid = typeid;
            this.types[typeid] = schema;
            this.schemas.set(schema, typeid);
        };
        Context.create = function (context) {
            if (context === void 0) { context = new Context; }
            return function (definition) {
                return type(definition, context);
            };
        };
        return Context;
    }());
    exports.Context = Context;
    exports.globalContext = new Context();
    /**
     * `@type()` decorator for proxies
     */
    function type(type, context) {
        if (context === void 0) { context = exports.globalContext; }
        return function (target, field) {
            var constructor = target.constructor;
            constructor._context = context;
            /*
             * static schema
             */
            if (!context.has(constructor)) {
                context.add(constructor);
            }
            var definition = constructor._definition;
            definition.addField(field, type);
            /**
             * skip if descriptor already exists for this field (`@deprecated()`)
             */
            if (definition.descriptors[field]) {
                return;
            }
            var isArray = ArraySchema_1.ArraySchema.is(type);
            var isMap = !isArray && MapSchema_1.MapSchema.is(type);
            // TODO: refactor me.
            // Allow abstract intermediary classes with no fields to be serialized
            // (See "should support an inheritance with a Schema type without fields" test)
            if (typeof (type) !== "string" && !Schema_1.Schema.is(type)) {
                var childType = Object.values(type)[0];
                if (typeof (childType) !== "string" && !context.has(childType)) {
                    context.add(childType);
                }
            }
            var fieldCached = "_" + field;
            definition.descriptors[fieldCached] = {
                enumerable: false,
                configurable: false,
                writable: true,
            };
            definition.descriptors[field] = {
                get: function () {
                    return this[fieldCached];
                },
                set: function (value) {
                    /**
                     * Create Proxy for array or map items
                     */
                    // skip if value is the same as cached.
                    if (value === this[fieldCached]) {
                        return;
                    }
                    if (value !== undefined &&
                        value !== null) {
                        // automaticallty transform Array into ArraySchema
                        if (isArray && !(value instanceof ArraySchema_1.ArraySchema)) {
                            value = new (ArraySchema_1.ArraySchema.bind.apply(ArraySchema_1.ArraySchema, __spread([void 0], value)))();
                        }
                        // automaticallty transform Map into MapSchema
                        if (isMap && !(value instanceof MapSchema_1.MapSchema)) {
                            value = new MapSchema_1.MapSchema(value);
                        }
                        // try to turn provided structure into a Proxy
                        if (value['$proxy'] === undefined) {
                            if (isMap) {
                                value = MapSchema_1.getMapProxy(value);
                            }
                            else if (isArray) {
                                value = ArraySchema_1.getArrayProxy(value);
                            }
                        }
                        // flag the change for encoding.
                        this.$changes.change(field);
                        //
                        // call setParent() recursively for this and its child
                        // structures.
                        //
                        if (value['$changes']) {
                            value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);
                        }
                    }
                    else {
                        //
                        // Setting a field to `null` or `undefined` will delete it.
                        //
                        this.$changes.delete(field);
                    }
                    this[fieldCached] = value;
                },
                enumerable: true,
                configurable: true
            };
        };
    }
    exports.type = type;
    /**
     * `@filter()` decorator for defining data filters per client
     */
    function filter(cb) {
        return function (target, field) {
            var constructor = target.constructor;
            var definition = constructor._definition;
            if (definition.addFilter(field, cb)) {
                constructor._context.useFilters = true;
            }
        };
    }
    exports.filter = filter;
    function filterChildren(cb) {
        return function (target, field) {
            var constructor = target.constructor;
            var definition = constructor._definition;
            if (definition.addChildrenFilter(field, cb)) {
                constructor._context.useFilters = true;
            }
        };
    }
    exports.filterChildren = filterChildren;
    /**
     * `@deprecated()` flag a field as deprecated.
     * The previous `@type()` annotation should remain along with this one.
     */
    function deprecated(throws, context) {
        if (throws === void 0) { throws = true; }
        if (context === void 0) { context = exports.globalContext; }
        return function (target, field) {
            var constructor = target.constructor;
            var definition = constructor._definition;
            definition.deprecated[field] = true;
            if (throws) {
                definition.descriptors[field] = {
                    get: function () { throw new Error(field + " is deprecated."); },
                    set: function (value) { },
                    enumerable: false,
                    configurable: true
                };
            }
        };
    }
    exports.deprecated = deprecated;
    function defineTypes(target, fields, context) {
        if (context === void 0) { context = target._context || exports.globalContext; }
        for (var field in fields) {
            type(fields[field], context)(target.prototype, field);
        }
        return target;
    }
    exports.defineTypes = defineTypes;

    });

    var CollectionSchema_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionSchema = void 0;




    var CollectionSchema = /** @class */ (function () {
        function CollectionSchema(initialValues) {
            var _this = this;
            this.$changes = new ChangeTree_1.ChangeTree(this);
            this.$items = new Map();
            this.$indexes = new Map();
            this.$refId = 0;
            if (initialValues) {
                initialValues.forEach(function (v) { return _this.add(v); });
            }
        }
        CollectionSchema.is = function (type) {
            return type['collection'] !== undefined;
        };
        CollectionSchema.prototype.add = function (value) {
            // set "index" for reference.
            var index = this.$refId++;
            var isRef = (value['$changes']) !== undefined;
            if (isRef) {
                value['$changes'].setParent(this, this.$changes.root, index);
            }
            this.$changes.indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this.$changes.change(index);
            return index;
        };
        CollectionSchema.prototype.at = function (index) {
            var key = Array.from(this.$items.keys())[index];
            return this.$items.get(key);
        };
        CollectionSchema.prototype.entries = function () {
            return this.$items.entries();
        };
        CollectionSchema.prototype.delete = function (item) {
            var entries = this.$items.entries();
            var index;
            var entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.$changes.delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        };
        CollectionSchema.prototype.clear = function (isDecoding) {
            var _this = this;
            // discard previous operations.
            this.$changes.discard(true, true);
            this.$changes.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // flag child items for garbage collection.
            if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                this.$items.forEach(function (item) {
                    _this.$changes.root.removeRef(item['$changes'].refId);
                });
            }
            // clear items
            this.$items.clear();
            this.$changes.operation({ index: 0, op: spec.OPERATION.CLEAR });
            // touch all structures until reach root
            this.$changes.touchParents();
        };
        CollectionSchema.prototype.has = function (value) {
            return Array.from(this.$items.values()).some(function (v) { return v === value; });
        };
        CollectionSchema.prototype.forEach = function (callbackfn) {
            var _this = this;
            this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });
        };
        CollectionSchema.prototype.values = function () {
            return this.$items.values();
        };
        Object.defineProperty(CollectionSchema.prototype, "size", {
            get: function () {
                return this.$items.size;
            },
            enumerable: false,
            configurable: true
        });
        CollectionSchema.prototype.setIndex = function (index, key) {
            this.$indexes.set(index, key);
        };
        CollectionSchema.prototype.getIndex = function (index) {
            return this.$indexes.get(index);
        };
        CollectionSchema.prototype.getByIndex = function (index) {
            return this.$items.get(this.$indexes.get(index));
        };
        CollectionSchema.prototype.deleteByIndex = function (index) {
            var key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        };
        CollectionSchema.prototype.toArray = function () {
            return Array.from(this.$items.values());
        };
        CollectionSchema.prototype.toJSON = function () {
            var values = [];
            this.forEach(function (value, key) {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        };
        //
        // Decoding utilities
        //
        CollectionSchema.prototype.clone = function (isDecoding) {
            var cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new CollectionSchema(), this);
            }
            else {
                // server-side
                var cloned_1 = new CollectionSchema();
                this.forEach(function (value) {
                    if (value['$changes']) {
                        cloned_1.add(value['clone']());
                    }
                    else {
                        cloned_1.add(value);
                    }
                });
            }
            return cloned;
        };
        CollectionSchema.prototype.triggerAll = function () {
            Schema_1.Schema.prototype.triggerAll.apply(this);
        };
        return CollectionSchema;
    }());
    exports.CollectionSchema = CollectionSchema;
    types.registerType("collection", {
        constructor: CollectionSchema,
    });

    });

    var SetSchema_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SetSchema = void 0;




    var SetSchema = /** @class */ (function () {
        function SetSchema(initialValues) {
            var _this = this;
            this.$changes = new ChangeTree_1.ChangeTree(this);
            this.$items = new Map();
            this.$indexes = new Map();
            this.$refId = 0;
            if (initialValues) {
                initialValues.forEach(function (v) { return _this.add(v); });
            }
        }
        SetSchema.is = function (type) {
            return type['set'] !== undefined;
        };
        SetSchema.prototype.add = function (value) {
            if (this.has(value)) {
                return false;
            }
            // set "index" for reference.
            var index = this.$refId++;
            var isRef = (value['$changes']) !== undefined;
            if (isRef) {
                value['$changes'].setParent(this, this.$changes.root, index);
            }
            this.$changes.indexes[index] = index;
            this.$indexes.set(index, index);
            this.$items.set(index, value);
            this.$changes.change(index);
            return index;
        };
        SetSchema.prototype.entries = function () {
            return this.$items.entries();
        };
        SetSchema.prototype.delete = function (item) {
            var entries = this.$items.entries();
            var index;
            var entry;
            while (entry = entries.next()) {
                if (entry.done) {
                    break;
                }
                if (item === entry.value[1]) {
                    index = entry.value[0];
                    break;
                }
            }
            if (index === undefined) {
                return false;
            }
            this.$changes.delete(index);
            this.$indexes.delete(index);
            return this.$items.delete(index);
        };
        SetSchema.prototype.clear = function (isDecoding) {
            var _this = this;
            // discard previous operations.
            this.$changes.discard(true, true);
            this.$changes.indexes = {};
            // clear previous indexes
            this.$indexes.clear();
            // flag child items for garbage collection.
            if (isDecoding && typeof (this.$changes.getType()) !== "string") {
                this.$items.forEach(function (item) {
                    _this.$changes.root.removeRef(item['$changes'].refId);
                });
            }
            // clear items
            this.$items.clear();
            this.$changes.operation({ index: 0, op: spec.OPERATION.CLEAR });
            // touch all structures until reach root
            this.$changes.touchParents();
        };
        SetSchema.prototype.has = function (value) {
            var values = this.$items.values();
            var has = false;
            var entry;
            while (entry = values.next()) {
                if (entry.done) {
                    break;
                }
                if (value === entry.value) {
                    has = true;
                    break;
                }
            }
            return has;
        };
        SetSchema.prototype.forEach = function (callbackfn) {
            var _this = this;
            this.$items.forEach(function (value, key, _) { return callbackfn(value, key, _this); });
        };
        SetSchema.prototype.values = function () {
            return this.$items.values();
        };
        Object.defineProperty(SetSchema.prototype, "size", {
            get: function () {
                return this.$items.size;
            },
            enumerable: false,
            configurable: true
        });
        SetSchema.prototype.setIndex = function (index, key) {
            this.$indexes.set(index, key);
        };
        SetSchema.prototype.getIndex = function (index) {
            return this.$indexes.get(index);
        };
        SetSchema.prototype.getByIndex = function (index) {
            return this.$items.get(this.$indexes.get(index));
        };
        SetSchema.prototype.deleteByIndex = function (index) {
            var key = this.$indexes.get(index);
            this.$items.delete(key);
            this.$indexes.delete(index);
        };
        SetSchema.prototype.toArray = function () {
            return Array.from(this.$items.values());
        };
        SetSchema.prototype.toJSON = function () {
            var values = [];
            this.forEach(function (value, key) {
                values.push((typeof (value['toJSON']) === "function")
                    ? value['toJSON']()
                    : value);
            });
            return values;
        };
        //
        // Decoding utilities
        //
        SetSchema.prototype.clone = function (isDecoding) {
            var cloned;
            if (isDecoding) {
                // client-side
                cloned = Object.assign(new SetSchema(), this);
            }
            else {
                // server-side
                var cloned_1 = new SetSchema();
                this.forEach(function (value) {
                    if (value['$changes']) {
                        cloned_1.add(value['clone']());
                    }
                    else {
                        cloned_1.add(value);
                    }
                });
            }
            return cloned;
        };
        SetSchema.prototype.triggerAll = function () {
            Schema_1.Schema.prototype.triggerAll.apply(this);
        };
        return SetSchema;
    }());
    exports.SetSchema = SetSchema;
    types.registerType("set", {
        constructor: SetSchema,
    });

    });

    var EventEmitter_1 = createCommonjsModule(function (module, exports) {
    /**
     * Extracted from https://www.npmjs.com/package/strong-events
     */
    var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (commonjsGlobal && commonjsGlobal.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventEmitter = void 0;
    var EventEmitter = /** @class */ (function () {
        function EventEmitter() {
            this.handlers = [];
        }
        EventEmitter.prototype.register = function (cb, once) {
            this.handlers.push(cb);
            return this;
        };
        EventEmitter.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            this.handlers.forEach(function (handler) { return handler.apply(void 0, __spread(args)); });
        };
        EventEmitter.prototype.invokeAsync = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return Promise.all(this.handlers.map(function (handler) { return handler.apply(void 0, __spread(args)); }));
        };
        EventEmitter.prototype.remove = function (cb) {
            var index = this.handlers.indexOf(cb);
            this.handlers[index] = this.handlers[this.handlers.length - 1];
            this.handlers.pop();
        };
        EventEmitter.prototype.clear = function () {
            this.handlers = [];
        };
        return EventEmitter;
    }());
    exports.EventEmitter = EventEmitter;

    });

    var filters = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientState = void 0;
    var ClientState = /** @class */ (function () {
        function ClientState() {
            this.refIds = new WeakSet();
            this.containerIndexes = new WeakMap();
        }
        // containerIndexes = new Map<ChangeTree, Set<number>>();
        ClientState.prototype.addRefId = function (changeTree) {
            if (!this.refIds.has(changeTree)) {
                this.refIds.add(changeTree);
                this.containerIndexes.set(changeTree, new Set());
            }
        };
        ClientState.get = function (client) {
            if (client.$filterState === undefined) {
                client.$filterState = new ClientState();
            }
            return client.$filterState;
        };
        return ClientState;
    }());
    exports.ClientState = ClientState;

    });

    var Schema_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __read = (commonjsGlobal && commonjsGlobal.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Schema = void 0;












    var EncodeSchemaError = /** @class */ (function (_super) {
        __extends(EncodeSchemaError, _super);
        function EncodeSchemaError() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EncodeSchemaError;
    }(Error));
    function assertType(value, type, klass, field) {
        var typeofTarget;
        var allowNull = false;
        switch (type) {
            case "number":
            case "int8":
            case "uint8":
            case "int16":
            case "uint16":
            case "int32":
            case "uint32":
            case "int64":
            case "uint64":
            case "float32":
            case "float64":
                typeofTarget = "number";
                if (isNaN(value)) {
                    console.log("trying to encode \"NaN\" in " + klass.constructor.name + "#" + field);
                }
                break;
            case "string":
                typeofTarget = "string";
                allowNull = true;
                break;
            case "boolean":
                // boolean is always encoded as true/false based on truthiness
                return;
        }
        if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
            var foundValue = "'" + JSON.stringify(value) + "'" + ((value && value.constructor && " (" + value.constructor.name + ")") || '');
            throw new EncodeSchemaError("a '" + typeofTarget + "' was expected, but " + foundValue + " was provided in " + klass.constructor.name + "#" + field);
        }
    }
    function assertInstanceType(value, type, klass, field) {
        if (!(value instanceof type)) {
            throw new EncodeSchemaError("a '" + type.name + "' was expected, but '" + value.constructor.name + "' was provided in " + klass.constructor.name + "#" + field);
        }
    }
    function encodePrimitiveType(type, bytes, value, klass, field) {
        assertType(value, type, klass, field);
        var encodeFunc = encode[type];
        if (encodeFunc) {
            encodeFunc(bytes, value);
        }
        else {
            throw new EncodeSchemaError("a '" + type + "' was expected, but " + value + " was provided in " + klass.constructor.name + "#" + field);
        }
    }
    function decodePrimitiveType(type, bytes, it) {
        return decode[type](bytes, it);
    }
    /**
     * Schema encoder / decoder
     */
    var Schema = /** @class */ (function () {
        // allow inherited classes to have a constructor
        function Schema() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            // fix enumerability of fields for end-user
            Object.defineProperties(this, {
                $changes: {
                    value: new ChangeTree_1.ChangeTree(this, undefined, new ChangeTree_1.Root()),
                    enumerable: false,
                    writable: true
                },
                $listeners: {
                    value: {},
                    enumerable: false,
                    writable: true
                },
            });
            var descriptors = this._definition.descriptors;
            if (descriptors) {
                Object.defineProperties(this, descriptors);
            }
            //
            // Assign initial values
            //
            if (args[0]) {
                this.assign(args[0]);
            }
        }
        Schema.onError = function (e) {
            console.error(e);
        };
        Schema.is = function (type) {
            return (type['_definition'] &&
                type['_definition'].schema !== undefined);
        };
        Schema.prototype.assign = function (props) {
            Object.assign(this, props);
            return this;
        };
        Object.defineProperty(Schema.prototype, "_definition", {
            get: function () { return this.constructor._definition; },
            enumerable: false,
            configurable: true
        });
        Schema.prototype.listen = function (attr, callback) {
            var _this = this;
            if (!this.$listeners[attr]) {
                this.$listeners[attr] = new EventEmitter_1.EventEmitter();
            }
            this.$listeners[attr].register(callback);
            // return un-register callback.
            return function () {
                return _this.$listeners[attr].remove(callback);
            };
        };
        Schema.prototype.decode = function (bytes, it, ref, allChanges) {
            if (it === void 0) { it = { offset: 0 }; }
            if (ref === void 0) { ref = this; }
            if (allChanges === void 0) { allChanges = new Map(); }
            var $root = this.$changes.root;
            var totalBytes = bytes.length;
            var refId = 0;
            var changes = [];
            $root.refs.set(refId, this);
            allChanges.set(refId, changes);
            while (it.offset < totalBytes) {
                var byte = bytes[it.offset++];
                if (byte == spec.SWITCH_TO_STRUCTURE) {
                    refId = decode.number(bytes, it);
                    var nextRef = $root.refs.get(refId);
                    //
                    // Trying to access a reference that haven't been decoded yet.
                    //
                    if (!nextRef) {
                        throw new Error("\"refId\" not found: " + refId);
                    }
                    ref = nextRef;
                    // create empty list of changes for this refId.
                    changes = [];
                    allChanges.set(refId, changes);
                    continue;
                }
                var changeTree = ref['$changes'];
                var isSchema = (ref['_definition'] !== undefined);
                var operation = (isSchema)
                    ? (byte >> 6) << 6 // "compressed" index + operation
                    : byte; // "uncompressed" index + operation (array/map items)
                if (operation === spec.OPERATION.CLEAR) {
                    //
                    // TODO: refactor me!
                    // The `.clear()` method is calling `$root.removeRef(refId)` for
                    // each item inside this collection
                    //
                    ref.clear(true);
                    continue;
                }
                var fieldIndex = (isSchema)
                    ? byte % (operation || 255) // if "REPLACE" operation (0), use 255
                    : decode.number(bytes, it);
                var fieldName = (isSchema)
                    ? (ref['_definition'].fieldsByIndex[fieldIndex])
                    : "";
                var type = changeTree.getType(fieldIndex);
                var value = void 0;
                var previousValue = void 0;
                var dynamicIndex = void 0;
                if (!isSchema) {
                    previousValue = ref['getByIndex'](fieldIndex);
                    if ((operation & spec.OPERATION.ADD) === spec.OPERATION.ADD) { // ADD or DELETE_AND_ADD
                        dynamicIndex = (ref instanceof MapSchema_1.MapSchema)
                            ? decode.string(bytes, it)
                            : fieldIndex;
                        ref['setIndex'](fieldIndex, dynamicIndex);
                    }
                    else {
                        // here
                        dynamicIndex = ref['getIndex'](fieldIndex);
                    }
                }
                else {
                    previousValue = ref["_" + fieldName];
                }
                //
                // Delete operations
                //
                if ((operation & spec.OPERATION.DELETE) === spec.OPERATION.DELETE) {
                    if (operation !== spec.OPERATION.DELETE_AND_ADD) {
                        ref['deleteByIndex'](fieldIndex);
                    }
                    // Flag `refId` for garbage collection.
                    if (previousValue && previousValue['$changes']) {
                        $root.removeRef(previousValue['$changes'].refId);
                    }
                    value = null;
                }
                if (fieldName === undefined) {
                    console.warn("@colyseus/schema: definition mismatch");
                    //
                    // keep skipping next bytes until reaches a known structure
                    // by local decoder.
                    //
                    var nextIterator = { offset: it.offset };
                    while (it.offset < totalBytes) {
                        if (decode.switchStructureCheck(bytes, it)) {
                            nextIterator.offset = it.offset + 1;
                            if ($root.refs.has(decode.number(bytes, nextIterator))) {
                                break;
                            }
                        }
                        it.offset++;
                    }
                    continue;
                }
                else if (operation === spec.OPERATION.DELETE) ;
                else if (Schema.is(type)) {
                    var refId_1 = decode.number(bytes, it);
                    value = $root.refs.get(refId_1);
                    if (operation !== spec.OPERATION.REPLACE) {
                        var childType = this.getSchemaType(bytes, it, type);
                        if (!value) {
                            value = this.createTypeInstance(childType);
                            value.$changes.refId = refId_1;
                            if (previousValue) {
                                value.onChange = previousValue.onChange;
                                value.onRemove = previousValue.onRemove;
                                value.$listeners = previousValue.$listeners;
                                if (previousValue['$changes'].refId &&
                                    refId_1 !== previousValue['$changes'].refId) {
                                    $root.removeRef(previousValue['$changes'].refId);
                                }
                            }
                        }
                        $root.addRef(refId_1, value, (value !== previousValue));
                    }
                }
                else if (typeof (type) === "string") {
                    //
                    // primitive value (number, string, boolean, etc)
                    //
                    value = decodePrimitiveType(type, bytes, it);
                }
                else {
                    var typeDef = types.getType(Object.keys(type)[0]);
                    var refId_2 = decode.number(bytes, it);
                    var valueRef = ($root.refs.has(refId_2))
                        ? previousValue
                        : new typeDef.constructor();
                    value = valueRef.clone(true);
                    value.$changes.refId = refId_2;
                    // preserve schema callbacks
                    if (previousValue) {
                        value.onAdd = previousValue.onAdd;
                        value.onRemove = previousValue.onRemove;
                        value.onChange = previousValue.onChange;
                        if (previousValue['$changes'].refId &&
                            refId_2 !== previousValue['$changes'].refId) {
                            $root.removeRef(previousValue['$changes'].refId);
                            //
                            // Trigger onRemove if structure has been replaced.
                            //
                            var deletes = [];
                            var entries = previousValue.entries();
                            var iter = void 0;
                            while ((iter = entries.next()) && !iter.done) {
                                var _a = __read(iter.value, 2), key = _a[0], value_1 = _a[1];
                                deletes.push({
                                    op: spec.OPERATION.DELETE,
                                    field: key,
                                    value: undefined,
                                    previousValue: value_1,
                                });
                            }
                            allChanges.set(previousValue['$changes'].refId, deletes);
                        }
                    }
                    $root.addRef(refId_2, value, (valueRef !== previousValue));
                    //
                    // TODO: deprecate proxies on next version.
                    // get proxy to target value.
                    //
                    if (typeDef.getProxy) {
                        value = typeDef.getProxy(value);
                    }
                }
                var hasChange = (previousValue !== value);
                if (value !== null &&
                    value !== undefined) {
                    if (value['$changes']) {
                        value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);
                    }
                    if (ref instanceof Schema) {
                        ref[fieldName] = value;
                        //
                        // FIXME: use `_field` instead of `field`.
                        //
                        // `field` is going to use the setter of the PropertyDescriptor
                        // and create a proxy for array/map. This is only useful for
                        // backwards-compatibility with @colyseus/schema@0.5.x
                        //
                        // // ref[_field] = value;
                    }
                    else if (ref instanceof MapSchema_1.MapSchema) {
                        // const key = ref['$indexes'].get(field);
                        var key = dynamicIndex;
                        // ref.set(key, value);
                        ref['$items'].set(key, value);
                    }
                    else if (ref instanceof ArraySchema_1.ArraySchema) {
                        // const key = ref['$indexes'][field];
                        // console.log("SETTING FOR ArraySchema =>", { field, key, value });
                        // ref[key] = value;
                        ref.setAt(fieldIndex, value);
                    }
                    else if (ref instanceof CollectionSchema_1.CollectionSchema ||
                        ref instanceof SetSchema_1.SetSchema) {
                        var index = ref.add(value);
                        ref['setIndex'](fieldIndex, index);
                    }
                }
                if (hasChange
                // &&
                // (
                //     this.onChange || ref.$listeners[field]
                // )
                ) {
                    changes.push({
                        op: operation,
                        field: fieldName,
                        dynamicIndex: dynamicIndex,
                        value: value,
                        previousValue: previousValue,
                    });
                }
            }
            this._triggerChanges(allChanges);
            // drop references of unused schemas
            $root.garbageCollectDeletedRefs();
            return allChanges;
        };
        Schema.prototype.encode = function (encodeAll, bytes, useFilters) {
            if (encodeAll === void 0) { encodeAll = false; }
            if (bytes === void 0) { bytes = []; }
            if (useFilters === void 0) { useFilters = false; }
            var rootChangeTree = this.$changes;
            var refIdsVisited = new WeakSet();
            var changeTrees = [rootChangeTree];
            var numChangeTrees = 1;
            for (var i = 0; i < numChangeTrees; i++) {
                var changeTree = changeTrees[i];
                var ref = changeTree.ref;
                var isSchema = (ref instanceof Schema);
                // Generate unique refId for the ChangeTree.
                changeTree.ensureRefId();
                // mark this ChangeTree as visited.
                refIdsVisited.add(changeTree);
                // root `refId` is skipped.
                if (changeTree !== rootChangeTree &&
                    (changeTree.changed || encodeAll)) {
                    encode.uint8(bytes, spec.SWITCH_TO_STRUCTURE);
                    encode.number(bytes, changeTree.refId);
                }
                var changes = (encodeAll)
                    ? Array.from(changeTree.allChanges)
                    : Array.from(changeTree.changes.values());
                for (var j = 0, cl = changes.length; j < cl; j++) {
                    var operation = (encodeAll)
                        ? { op: spec.OPERATION.ADD, index: changes[j] }
                        : changes[j];
                    var fieldIndex = operation.index;
                    var field = (isSchema)
                        ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]
                        : fieldIndex;
                    // cache begin index if `useFilters`
                    var beginIndex = bytes.length;
                    // encode field index + operation
                    if (operation.op !== spec.OPERATION.TOUCH) {
                        if (isSchema) {
                            //
                            // Compress `fieldIndex` + `operation` into a single byte.
                            // This adds a limitaion of 64 fields per Schema structure
                            //
                            encode.uint8(bytes, (fieldIndex | operation.op));
                        }
                        else {
                            encode.uint8(bytes, operation.op);
                            // custom operations
                            if (operation.op === spec.OPERATION.CLEAR) {
                                continue;
                            }
                            // indexed operations
                            encode.number(bytes, fieldIndex);
                        }
                    }
                    //
                    // encode "alias" for dynamic fields (maps)
                    //
                    if (!isSchema &&
                        (operation.op & spec.OPERATION.ADD) == spec.OPERATION.ADD // ADD or DELETE_AND_ADD
                    ) {
                        if (ref instanceof MapSchema_1.MapSchema) {
                            //
                            // MapSchema dynamic key
                            //
                            var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                            encode.string(bytes, dynamicIndex);
                        }
                    }
                    if (operation.op === spec.OPERATION.DELETE) {
                        //
                        // TODO: delete from filter cache data.
                        //
                        // if (useFilters) {
                        //     delete changeTree.caches[fieldIndex];
                        // }
                        continue;
                    }
                    // const type = changeTree.childType || ref._schema[field];
                    var type = changeTree.getType(fieldIndex);
                    // const type = changeTree.getType(fieldIndex);
                    var value = changeTree.getValue(fieldIndex);
                    // Enqueue ChangeTree to be visited
                    if (value &&
                        value['$changes'] &&
                        !refIdsVisited.has(value['$changes'])) {
                        changeTrees.push(value['$changes']);
                        value['$changes'].ensureRefId();
                        numChangeTrees++;
                    }
                    if (operation.op === spec.OPERATION.TOUCH) {
                        continue;
                    }
                    if (Schema.is(type)) {
                        assertInstanceType(value, type, ref, field);
                        //
                        // Encode refId for this instance.
                        // The actual instance is going to be encoded on next `changeTree` iteration.
                        //
                        encode.number(bytes, value.$changes.refId);
                        // Try to encode inherited TYPE_ID if it's an ADD operation.
                        if ((operation.op & spec.OPERATION.ADD) === spec.OPERATION.ADD) {
                            this.tryEncodeTypeId(bytes, type, value.constructor);
                        }
                    }
                    else if (typeof (type) === "string") {
                        //
                        // Primitive values
                        //
                        encodePrimitiveType(type, bytes, value, ref, field);
                    }
                    else {
                        //
                        // Custom type (MapSchema, ArraySchema, etc)
                        //
                        var definition = types.getType(Object.keys(type)[0]);
                        //
                        // ensure a ArraySchema has been provided
                        //
                        assertInstanceType(ref["_" + field], definition.constructor, ref, field);
                        //
                        // Encode refId for this instance.
                        // The actual instance is going to be encoded on next `changeTree` iteration.
                        //
                        encode.number(bytes, value.$changes.refId);
                    }
                    if (useFilters) {
                        // cache begin / end index
                        changeTree.cache(fieldIndex, bytes.slice(beginIndex));
                    }
                }
                if (!encodeAll && !useFilters) {
                    changeTree.discard();
                }
            }
            return bytes;
        };
        Schema.prototype.encodeAll = function (useFilters) {
            return this.encode(true, [], useFilters);
        };
        Schema.prototype.applyFilters = function (client, encodeAll) {
            if (encodeAll === void 0) { encodeAll = false; }
            var root = this;
            var refIdsDissallowed = new Set();
            var $filterState = filters.ClientState.get(client);
            var changeTrees = [this.$changes];
            var numChangeTrees = 1;
            var filteredBytes = [];
            var _loop_1 = function (i) {
                var changeTree = changeTrees[i];
                if (refIdsDissallowed.has(changeTree.refId)) {
                    return "continue";
                }
                var ref = changeTree.ref;
                var isSchema = ref instanceof Schema;
                encode.uint8(filteredBytes, spec.SWITCH_TO_STRUCTURE);
                encode.number(filteredBytes, changeTree.refId);
                var clientHasRefId = $filterState.refIds.has(changeTree);
                var isEncodeAll = (encodeAll || !clientHasRefId);
                // console.log("REF:", ref.constructor.name);
                // console.log("Encode all?", isEncodeAll);
                //
                // include `changeTree` on list of known refIds by this client.
                //
                $filterState.addRefId(changeTree);
                var containerIndexes = $filterState.containerIndexes.get(changeTree);
                var changes = (isEncodeAll)
                    ? Array.from(changeTree.allChanges)
                    : Array.from(changeTree.changes.values());
                //
                // WORKAROUND: tries to re-evaluate previously not included @filter() attributes
                // - see "DELETE a field of Schema" test case.
                //
                if (!encodeAll &&
                    isSchema &&
                    ref._definition.indexesWithFilters) {
                    var indexesWithFilters = ref._definition.indexesWithFilters;
                    indexesWithFilters.forEach(function (indexWithFilter) {
                        if (!containerIndexes.has(indexWithFilter) &&
                            changeTree.allChanges.has(indexWithFilter)) {
                            if (isEncodeAll) {
                                changes.push(indexWithFilter);
                            }
                            else {
                                changes.push({ op: spec.OPERATION.ADD, index: indexWithFilter, });
                            }
                        }
                    });
                }
                for (var j = 0, cl = changes.length; j < cl; j++) {
                    var change = (isEncodeAll)
                        ? { op: spec.OPERATION.ADD, index: changes[j] }
                        : changes[j];
                    // custom operations
                    if (change.op === spec.OPERATION.CLEAR) {
                        encode.uint8(filteredBytes, change.op);
                        continue;
                    }
                    var fieldIndex = change.index;
                    //
                    // Deleting fields: encode the operation + field index
                    //
                    if (change.op === spec.OPERATION.DELETE) {
                        //
                        // DELETE operations also need to go through filtering.
                        //
                        // TODO: cache the previous value so we can access the value (primitive or `refId`)
                        // (check against `$filterState.refIds`)
                        //
                        if (isSchema) {
                            encode.uint8(filteredBytes, change.op | fieldIndex);
                        }
                        else {
                            encode.uint8(filteredBytes, change.op);
                            encode.number(filteredBytes, fieldIndex);
                        }
                        continue;
                    }
                    // indexed operation
                    var value = changeTree.getValue(fieldIndex);
                    var type = changeTree.getType(fieldIndex);
                    if (isSchema) {
                        // Is a Schema!
                        var filter = (ref._definition.filters &&
                            ref._definition.filters[fieldIndex]);
                        if (filter && !filter.call(ref, client, value, root)) {
                            if (value && value['$changes']) {
                                refIdsDissallowed.add(value['$changes'].refId);
                            }
                            continue;
                        }
                    }
                    else {
                        // Is a collection! (map, array, etc.)
                        var parent = changeTree.parent;
                        var filter = changeTree.getChildrenFilter();
                        if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {
                            if (value && value['$changes']) {
                                refIdsDissallowed.add(value['$changes'].refId);
                            }
                            continue;
                        }
                    }
                    // visit child ChangeTree on further iteration.
                    if (value['$changes']) {
                        changeTrees.push(value['$changes']);
                        numChangeTrees++;
                    }
                    //
                    // Copy cached bytes
                    //
                    if (change.op !== spec.OPERATION.TOUCH) {
                        //
                        // TODO: refactor me!
                        //
                        if (change.op === spec.OPERATION.ADD || isSchema) {
                            //
                            // use cached bytes directly if is from Schema type.
                            //
                            filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                            containerIndexes.add(fieldIndex);
                        }
                        else {
                            if (containerIndexes.has(fieldIndex)) {
                                //
                                // use cached bytes if already has the field
                                //
                                filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                            }
                            else {
                                //
                                // force ADD operation if field is not known by this client.
                                //
                                containerIndexes.add(fieldIndex);
                                encode.uint8(filteredBytes, spec.OPERATION.ADD);
                                encode.number(filteredBytes, fieldIndex);
                                if (ref instanceof MapSchema_1.MapSchema) {
                                    //
                                    // MapSchema dynamic key
                                    //
                                    var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                    encode.string(filteredBytes, dynamicIndex);
                                }
                                if (value['$changes']) {
                                    encode.number(filteredBytes, value['$changes'].refId);
                                }
                                else {
                                    // "encodePrimitiveType" without type checking.
                                    // the type checking has been done on the first .encode() call.
                                    encode[type](filteredBytes, value);
                                }
                            }
                        }
                    }
                    else if (value['$changes'] && !isSchema) {
                        //
                        // TODO:
                        // - track ADD/REPLACE/DELETE instances on `$filterState`
                        // - do NOT always encode dynamicIndex for MapSchema.
                        //   (If client already has that key, only the first index is necessary.)
                        //
                        encode.uint8(filteredBytes, spec.OPERATION.ADD);
                        encode.number(filteredBytes, fieldIndex);
                        if (ref instanceof MapSchema_1.MapSchema) {
                            //
                            // MapSchema dynamic key
                            //
                            var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                            encode.string(filteredBytes, dynamicIndex);
                        }
                        encode.number(filteredBytes, value['$changes'].refId);
                    }
                }
            };
            for (var i = 0; i < numChangeTrees; i++) {
                _loop_1(i);
            }
            return filteredBytes;
        };
        Schema.prototype.clone = function () {
            var cloned = new (this.constructor);
            var schema = this._definition.schema;
            for (var field in schema) {
                if (typeof (this[field]) === "object" &&
                    typeof (this[field].clone) === "function") {
                    // deep clone
                    cloned[field] = this[field].clone();
                }
                else {
                    // primitive values
                    cloned[field] = this[field];
                }
            }
            return cloned;
        };
        Schema.prototype.triggerAll = function () {
            // skip if haven't received any remote refs yet.
            if (this.$changes.root.refs.size === 0) {
                return;
            }
            var allChanges = new Map();
            this._triggerAllFillChanges(this, allChanges);
            try {
                this._triggerChanges(allChanges);
            }
            catch (e) {
                Schema.onError(e);
            }
        };
        Schema.prototype.toJSON = function () {
            var schema = this._definition.schema;
            var deprecated = this._definition.deprecated;
            var obj = {};
            for (var field in schema) {
                if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== "undefined") {
                    obj[field] = (typeof (this[field]['toJSON']) === "function")
                        ? this[field]['toJSON']()
                        : this["_" + field];
                }
            }
            return obj;
        };
        Schema.prototype.discardAllChanges = function () {
            this.$changes.discardAll();
        };
        Schema.prototype.getByIndex = function (index) {
            return this[this._definition.fieldsByIndex[index]];
        };
        Schema.prototype.deleteByIndex = function (index) {
            this[this._definition.fieldsByIndex[index]] = undefined;
        };
        Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {
            if (type._typeid !== targetType._typeid) {
                encode.uint8(bytes, spec.TYPE_ID);
                encode.number(bytes, targetType._typeid);
            }
        };
        Schema.prototype.getSchemaType = function (bytes, it, defaultType) {
            var type;
            if (bytes[it.offset] === spec.TYPE_ID) {
                it.offset++;
                type = this.constructor._context.get(decode.number(bytes, it));
            }
            return type || defaultType;
        };
        Schema.prototype.createTypeInstance = function (type) {
            var instance = new type();
            // assign root on $changes
            instance.$changes.root = this.$changes.root;
            return instance;
        };
        Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {
            if (allChanges.has(ref['$changes'].refId)) {
                return;
            }
            var changes = [];
            allChanges.set(ref['$changes'].refId || 0, changes);
            if (ref instanceof Schema) {
                var schema = ref._definition.schema;
                for (var fieldName in schema) {
                    var _field = "_" + fieldName;
                    var value = ref[_field];
                    if (value !== undefined) {
                        changes.push({
                            op: spec.OPERATION.ADD,
                            field: fieldName,
                            value: value,
                            previousValue: undefined
                        });
                        if (value['$changes'] !== undefined) {
                            this._triggerAllFillChanges(value, allChanges);
                        }
                    }
                }
            }
            else {
                var entries = ref.entries();
                var iter = void 0;
                while ((iter = entries.next()) && !iter.done) {
                    var _a = __read(iter.value, 2), key = _a[0], value = _a[1];
                    changes.push({
                        op: spec.OPERATION.ADD,
                        field: key,
                        dynamicIndex: key,
                        value: value,
                        previousValue: undefined,
                    });
                    if (value['$changes'] !== undefined) {
                        this._triggerAllFillChanges(value, allChanges);
                    }
                }
            }
        };
        Schema.prototype._triggerChanges = function (allChanges) {
            var _this = this;
            allChanges.forEach(function (changes, refId) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
                if (changes.length > 0) {
                    var ref = _this.$changes.root.refs.get(refId);
                    var isSchema = ref instanceof Schema;
                    for (var i = 0; i < changes.length; i++) {
                        var change = changes[i];
                        var listener = ref['$listeners'] && ref['$listeners'][change.field];
                        if (!isSchema) {
                            if (change.op === spec.OPERATION.ADD && change.previousValue === undefined) {
                                (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);
                            }
                            else if (change.op === spec.OPERATION.DELETE) {
                                //
                                // FIXME: `previousValue` should always be avaiiable.
                                // ADD + DELETE operations are still encoding DELETE operation.
                                //
                                if (change.previousValue !== undefined) {
                                    (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);
                                }
                            }
                            else if (change.op === spec.OPERATION.DELETE_AND_ADD) {
                                if (change.previousValue !== undefined) {
                                    (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);
                                }
                                (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);
                            }
                            else if (change.op === spec.OPERATION.REPLACE ||
                                change.value !== change.previousValue) {
                                (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);
                            }
                        }
                        //
                        // trigger onRemove on child structure.
                        //
                        if ((change.op & spec.OPERATION.DELETE) === spec.OPERATION.DELETE &&
                            change.previousValue instanceof Schema &&
                            change.previousValue.onRemove) {
                            change.previousValue.onRemove();
                        }
                        if (listener) {
                            try {
                                listener.invoke(change.value, change.previousValue);
                            }
                            catch (e) {
                                Schema.onError(e);
                            }
                        }
                    }
                    if (isSchema) {
                        if (ref.onChange) {
                            try {
                                ref.onChange(changes);
                            }
                            catch (e) {
                                Schema.onError(e);
                            }
                        }
                    }
                }
            });
        };
        Schema._definition = annotations.SchemaDefinition.create();
        return Schema;
    }());
    exports.Schema = Schema;

    });

    var utils = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dumpChanges = void 0;


    function dumpChanges(schema) {
        var changeTrees = [schema['$changes']];
        var numChangeTrees = 1;
        var dump = {};
        var currentStructure = dump;
        var _loop_1 = function (i) {
            var changeTree = changeTrees[i];
            // TODO: this method doesn't work as expected.
            changeTree.changes.forEach(function (change) {
                var ref = changeTree.ref;
                var fieldIndex = change.index;
                var field = (ref instanceof lib$3.Schema)
                    ? ref['_definition'].fieldsByIndex[fieldIndex]
                    : (ref instanceof MapSchema_1.MapSchema)
                        ? ref['$indexes'].get(fieldIndex)
                        : ref['$indexes'][fieldIndex];
                currentStructure[field] = changeTree.getValue(fieldIndex);
            });
        };
        for (var i = 0; i < numChangeTrees; i++) {
            _loop_1(i);
        }
        return dump;
    }
    exports.dumpChanges = dumpChanges;

    });

    var Reflection_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __decorate = (commonjsGlobal && commonjsGlobal.__decorate) || function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reflection = exports.ReflectionType = exports.ReflectionField = void 0;




    var reflectionContext = new annotations.Context();
    /**
     * Reflection
     */
    var ReflectionField = /** @class */ (function (_super) {
        __extends(ReflectionField, _super);
        function ReflectionField() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        __decorate([
            annotations.type("string", reflectionContext)
        ], ReflectionField.prototype, "name", void 0);
        __decorate([
            annotations.type("string", reflectionContext)
        ], ReflectionField.prototype, "type", void 0);
        __decorate([
            annotations.type("number", reflectionContext)
        ], ReflectionField.prototype, "referencedType", void 0);
        return ReflectionField;
    }(Schema_1.Schema));
    exports.ReflectionField = ReflectionField;
    var ReflectionType = /** @class */ (function (_super) {
        __extends(ReflectionType, _super);
        function ReflectionType() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.fields = new ArraySchema_1.ArraySchema();
            return _this;
        }
        __decorate([
            annotations.type("number", reflectionContext)
        ], ReflectionType.prototype, "id", void 0);
        __decorate([
            annotations.type([ReflectionField], reflectionContext)
        ], ReflectionType.prototype, "fields", void 0);
        return ReflectionType;
    }(Schema_1.Schema));
    exports.ReflectionType = ReflectionType;
    var Reflection = /** @class */ (function (_super) {
        __extends(Reflection, _super);
        function Reflection() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.types = new ArraySchema_1.ArraySchema();
            return _this;
        }
        Reflection.encode = function (instance) {
            var rootSchemaType = instance.constructor;
            var reflection = new Reflection();
            reflection.rootType = rootSchemaType._typeid;
            var buildType = function (currentType, schema) {
                for (var fieldName in schema) {
                    var field = new ReflectionField();
                    field.name = fieldName;
                    var fieldType = void 0;
                    if (typeof (schema[fieldName]) === "string") {
                        fieldType = schema[fieldName];
                    }
                    else {
                        var type_1 = schema[fieldName];
                        var childTypeSchema = void 0;
                        //
                        // TODO: refactor below.
                        //
                        if (Schema_1.Schema.is(type_1)) {
                            fieldType = "ref";
                            childTypeSchema = schema[fieldName];
                        }
                        else {
                            fieldType = Object.keys(type_1)[0];
                            if (typeof (type_1[fieldType]) === "string") {
                                fieldType += ":" + type_1[fieldType]; // array:string
                            }
                            else {
                                childTypeSchema = type_1[fieldType];
                            }
                        }
                        field.referencedType = (childTypeSchema)
                            ? childTypeSchema._typeid
                            : -1;
                    }
                    field.type = fieldType;
                    currentType.fields.push(field);
                }
                reflection.types.push(currentType);
            };
            var types = rootSchemaType._context.types;
            for (var typeid in types) {
                var type_2 = new ReflectionType();
                type_2.id = Number(typeid);
                buildType(type_2, types[typeid]._definition.schema);
            }
            return reflection.encodeAll();
        };
        Reflection.decode = function (bytes, it) {
            var context = new annotations.Context();
            var reflection = new Reflection();
            reflection.decode(bytes, it);
            var schemaTypes = reflection.types.reduce(function (types, reflectionType) {
                var schema = /** @class */ (function (_super) {
                    __extends(_, _super);
                    function _() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return _;
                }(Schema_1.Schema));
                var typeid = reflectionType.id;
                types[typeid] = schema;
                context.add(schema, typeid);
                return types;
            }, {});
            reflection.types.forEach(function (reflectionType) {
                var schemaType = schemaTypes[reflectionType.id];
                reflectionType.fields.forEach(function (field) {
                    var _a;
                    if (field.referencedType !== undefined) {
                        var fieldType = field.type;
                        var refType = schemaTypes[field.referencedType];
                        // map or array of primitive type (-1)
                        if (!refType) {
                            var typeInfo = field.type.split(":");
                            fieldType = typeInfo[0];
                            refType = typeInfo[1];
                        }
                        if (fieldType === "ref") {
                            annotations.type(refType, context)(schemaType.prototype, field.name);
                        }
                        else {
                            annotations.type((_a = {}, _a[fieldType] = refType, _a), context)(schemaType.prototype, field.name);
                        }
                    }
                    else {
                        annotations.type(field.type, context)(schemaType.prototype, field.name);
                    }
                });
            });
            var rootType = schemaTypes[reflection.rootType];
            var rootInstance = new rootType();
            /**
             * auto-initialize referenced types on root type
             * to allow registering listeners immediatelly on client-side
             */
            for (var fieldName in rootType._definition.schema) {
                var fieldType = rootType._definition.schema[fieldName];
                if (typeof (fieldType) !== "string") {
                    rootInstance[fieldName] = (typeof (fieldType) === "function")
                        ? new fieldType() // is a schema reference
                        : new (types.getType(Object.keys(fieldType)[0])).constructor(); // is a "collection"
                }
            }
            return rootInstance;
        };
        __decorate([
            annotations.type([ReflectionType], reflectionContext)
        ], Reflection.prototype, "types", void 0);
        __decorate([
            annotations.type("number", reflectionContext)
        ], Reflection.prototype, "rootType", void 0);
        return Reflection;
    }(Schema_1.Schema));
    exports.Reflection = Reflection;

    });

    var lib$3 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    Object.defineProperty(exports, "Schema", { enumerable: true, get: function () { return Schema_1.Schema; } });

    Object.defineProperty(exports, "MapSchema", { enumerable: true, get: function () { return MapSchema_1.MapSchema; } });

    Object.defineProperty(exports, "ArraySchema", { enumerable: true, get: function () { return ArraySchema_1.ArraySchema; } });

    Object.defineProperty(exports, "CollectionSchema", { enumerable: true, get: function () { return CollectionSchema_1.CollectionSchema; } });

    Object.defineProperty(exports, "SetSchema", { enumerable: true, get: function () { return SetSchema_1.SetSchema; } });
    // Utils

    Object.defineProperty(exports, "dumpChanges", { enumerable: true, get: function () { return utils.dumpChanges; } });
    // Reflection

    Object.defineProperty(exports, "Reflection", { enumerable: true, get: function () { return Reflection_1.Reflection; } });
    Object.defineProperty(exports, "ReflectionType", { enumerable: true, get: function () { return Reflection_1.ReflectionType; } });
    Object.defineProperty(exports, "ReflectionField", { enumerable: true, get: function () { return Reflection_1.ReflectionField; } });

    // Annotations
    Object.defineProperty(exports, "type", { enumerable: true, get: function () { return annotations.type; } });
    Object.defineProperty(exports, "deprecated", { enumerable: true, get: function () { return annotations.deprecated; } });
    Object.defineProperty(exports, "filter", { enumerable: true, get: function () { return annotations.filter; } });
    Object.defineProperty(exports, "filterChildren", { enumerable: true, get: function () { return annotations.filterChildren; } });
    Object.defineProperty(exports, "defineTypes", { enumerable: true, get: function () { return annotations.defineTypes; } });
    Object.defineProperty(exports, "hasFilter", { enumerable: true, get: function () { return annotations.hasFilter; } });
    // Internals
    Object.defineProperty(exports, "SchemaDefinition", { enumerable: true, get: function () { return annotations.SchemaDefinition; } });
    // Types
    Object.defineProperty(exports, "Context", { enumerable: true, get: function () { return annotations.Context; } });

    Object.defineProperty(exports, "OPERATION", { enumerable: true, get: function () { return spec.OPERATION; } });

    });

    var SchemaSerializer_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaSerializer = void 0;

    var SchemaSerializer = /** @class */ (function () {
        function SchemaSerializer() {
        }
        SchemaSerializer.prototype.setState = function (rawState) {
            this.state.decode(rawState);
        };
        SchemaSerializer.prototype.getState = function () {
            return this.state;
        };
        SchemaSerializer.prototype.patch = function (patches) {
            this.state.decode(patches);
        };
        SchemaSerializer.prototype.teardown = function () {
            var _a, _b;
            (_b = (_a = this.state) === null || _a === void 0 ? void 0 : _a['$changes']) === null || _b === void 0 ? void 0 : _b.root.clearRefs();
        };
        SchemaSerializer.prototype.handshake = function (bytes, it) {
            if (this.state) {
                // validate client/server definitinos
                var reflection = new lib$3.Reflection();
                reflection.decode(bytes, it);
            }
            else {
                // initialize reflected state from server
                this.state = lib$3.Reflection.decode(bytes, it);
            }
        };
        return SchemaSerializer;
    }());
    exports.SchemaSerializer = SchemaSerializer;

    });

    var NoneSerializer_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoneSerializer = void 0;
    var NoneSerializer = /** @class */ (function () {
        function NoneSerializer() {
        }
        NoneSerializer.prototype.setState = function (rawState) { };
        NoneSerializer.prototype.getState = function () { return null; };
        NoneSerializer.prototype.patch = function (patches) { };
        NoneSerializer.prototype.teardown = function () { };
        NoneSerializer.prototype.handshake = function (bytes) { };
        return NoneSerializer;
    }());
    exports.NoneSerializer = NoneSerializer;

    });

    var lib$4 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SchemaSerializer = exports.FossilDeltaSerializer = exports.registerSerializer = void 0;


    Object.defineProperty(exports, "Client", { enumerable: true, get: function () { return Client_1.Client; } });

    Object.defineProperty(exports, "Protocol", { enumerable: true, get: function () { return Protocol_1.Protocol; } });
    Object.defineProperty(exports, "ErrorCode", { enumerable: true, get: function () { return Protocol_1.ErrorCode; } });

    Object.defineProperty(exports, "Room", { enumerable: true, get: function () { return Room_1.Room; } });

    Object.defineProperty(exports, "Auth", { enumerable: true, get: function () { return Auth_1.Auth; } });
    Object.defineProperty(exports, "Platform", { enumerable: true, get: function () { return Auth_1.Platform; } });
    /*
     * Serializers
     */

    Object.defineProperty(exports, "FossilDeltaSerializer", { enumerable: true, get: function () { return FossilDeltaSerializer_1.FossilDeltaSerializer; } });

    Object.defineProperty(exports, "SchemaSerializer", { enumerable: true, get: function () { return SchemaSerializer_1.SchemaSerializer; } });


    Object.defineProperty(exports, "registerSerializer", { enumerable: true, get: function () { return Serializer.registerSerializer; } });
    Serializer.registerSerializer('fossil-delta', FossilDeltaSerializer_1.FossilDeltaSerializer);
    Serializer.registerSerializer('schema', SchemaSerializer_1.SchemaSerializer);
    Serializer.registerSerializer('none', NoneSerializer_1.NoneSerializer);

    });

    var index = /*@__PURE__*/getDefaultExportFromCjs(lib$4);

    var Colyseus = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.assign(/*#__PURE__*/Object.create(null), lib$4, {
        'default': index
    }));

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var isArray_1 = isArray;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = _freeGlobal || freeSelf || Function('return this')();

    var _root = root;

    /** Built-in value references. */
    var Symbol$1 = _root.Symbol;

    var _Symbol = Symbol$1;

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$1.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString$1.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag$1 && symToStringTag$1 in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike_1(value) && _baseGetTag(value) == symbolTag);
    }

    var isSymbol_1 = isSymbol;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol_1(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject_1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype,
        objectProto$2 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || _MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = _MapCache;

    var memoize_1 = memoize;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize_1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = _memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray_1(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return _arrayMap(value, baseToString) + '';
      }
      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    var _baseToString = baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }
      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _toKey = toKey;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = _castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get;

    /*
    object-assign
    (c) Sindre Sorhus
    @license MIT
    */
    /* eslint-disable no-unused-vars */
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Object.assign cannot be called with null or undefined');
    	}

    	return Object(val);
    }

    function shouldUseNative() {
    	try {
    		if (!Object.assign) {
    			return false;
    		}

    		// Detect buggy property enumeration order in older V8 versions.

    		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
    		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
    		test1[5] = 'de';
    		if (Object.getOwnPropertyNames(test1)[0] === '5') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test2 = {};
    		for (var i = 0; i < 10; i++) {
    			test2['_' + String.fromCharCode(i)] = i;
    		}
    		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
    			return test2[n];
    		});
    		if (order2.join('') !== '0123456789') {
    			return false;
    		}

    		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
    		var test3 = {};
    		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
    			test3[letter] = letter;
    		});
    		if (Object.keys(Object.assign({}, test3)).join('') !==
    				'abcdefghijklmnopqrst') {
    			return false;
    		}

    		return true;
    	} catch (err) {
    		// We don't expect any of the above to throw, but better to be safe.
    		return false;
    	}
    }

    var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    	var from;
    	var to = toObject(target);
    	var symbols;

    	for (var s = 1; s < arguments.length; s++) {
    		from = Object(arguments[s]);

    		for (var key in from) {
    			if (hasOwnProperty$4.call(from, key)) {
    				to[key] = from[key];
    			}
    		}

    		if (getOwnPropertySymbols) {
    			symbols = getOwnPropertySymbols(from);
    			for (var i = 0; i < symbols.length; i++) {
    				if (propIsEnumerable.call(from, symbols[i])) {
    					to[symbols[i]] = from[symbols[i]];
    				}
    			}
    		}
    	}

    	return to;
    };

    var isFunction_1$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function isFunction(x) {
        return typeof x === 'function';
    }
    exports.isFunction = isFunction;

    });

    var config = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    exports.config = {
        Promise: undefined,
        set useDeprecatedSynchronousErrorHandling(value) {
            if (value) {
                var error = new Error();
                console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
            }
            else if (_enable_super_gross_mode_that_will_cause_bad_things) {
                console.log('RxJS: Back to a better error behavior. Thank you. <3');
            }
            _enable_super_gross_mode_that_will_cause_bad_things = value;
        },
        get useDeprecatedSynchronousErrorHandling() {
            return _enable_super_gross_mode_that_will_cause_bad_things;
        },
    };

    });

    var hostReportError_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function hostReportError(err) {
        setTimeout(function () { throw err; }, 0);
    }
    exports.hostReportError = hostReportError;

    });

    var Observer = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });


    exports.empty = {
        closed: true,
        next: function (value) { },
        error: function (err) {
            if (config.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        },
        complete: function () { }
    };

    });

    var isArray$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

    });

    var isObject_1$1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function isObject(x) {
        return x !== null && typeof x === 'object';
    }
    exports.isObject = isObject;

    });

    var UnsubscriptionError = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnsubscriptionErrorImpl = (function () {
        function UnsubscriptionErrorImpl(errors) {
            Error.call(this);
            this.message = errors ?
                errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
            this.name = 'UnsubscriptionError';
            this.errors = errors;
            return this;
        }
        UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
        return UnsubscriptionErrorImpl;
    })();
    exports.UnsubscriptionError = UnsubscriptionErrorImpl;

    });

    var Subscription_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });




    var Subscription = (function () {
        function Subscription(unsubscribe) {
            this.closed = false;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (unsubscribe) {
                this._ctorUnsubscribe = true;
                this._unsubscribe = unsubscribe;
            }
        }
        Subscription.prototype.unsubscribe = function () {
            var errors;
            if (this.closed) {
                return;
            }
            var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
            this.closed = true;
            this._parentOrParents = null;
            this._subscriptions = null;
            if (_parentOrParents instanceof Subscription) {
                _parentOrParents.remove(this);
            }
            else if (_parentOrParents !== null) {
                for (var index = 0; index < _parentOrParents.length; ++index) {
                    var parent_1 = _parentOrParents[index];
                    parent_1.remove(this);
                }
            }
            if (isFunction_1$1.isFunction(_unsubscribe)) {
                if (_ctorUnsubscribe) {
                    this._unsubscribe = undefined;
                }
                try {
                    _unsubscribe.call(this);
                }
                catch (e) {
                    errors = e instanceof UnsubscriptionError.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
                }
            }
            if (isArray$1.isArray(_subscriptions)) {
                var index = -1;
                var len = _subscriptions.length;
                while (++index < len) {
                    var sub = _subscriptions[index];
                    if (isObject_1$1.isObject(sub)) {
                        try {
                            sub.unsubscribe();
                        }
                        catch (e) {
                            errors = errors || [];
                            if (e instanceof UnsubscriptionError.UnsubscriptionError) {
                                errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                            }
                            else {
                                errors.push(e);
                            }
                        }
                    }
                }
            }
            if (errors) {
                throw new UnsubscriptionError.UnsubscriptionError(errors);
            }
        };
        Subscription.prototype.add = function (teardown) {
            var subscription = teardown;
            if (!teardown) {
                return Subscription.EMPTY;
            }
            switch (typeof teardown) {
                case 'function':
                    subscription = new Subscription(teardown);
                case 'object':
                    if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                        return subscription;
                    }
                    else if (this.closed) {
                        subscription.unsubscribe();
                        return subscription;
                    }
                    else if (!(subscription instanceof Subscription)) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                    break;
                default: {
                    throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
                }
            }
            var _parentOrParents = subscription._parentOrParents;
            if (_parentOrParents === null) {
                subscription._parentOrParents = this;
            }
            else if (_parentOrParents instanceof Subscription) {
                if (_parentOrParents === this) {
                    return subscription;
                }
                subscription._parentOrParents = [_parentOrParents, this];
            }
            else if (_parentOrParents.indexOf(this) === -1) {
                _parentOrParents.push(this);
            }
            else {
                return subscription;
            }
            var subscriptions = this._subscriptions;
            if (subscriptions === null) {
                this._subscriptions = [subscription];
            }
            else {
                subscriptions.push(subscription);
            }
            return subscription;
        };
        Subscription.prototype.remove = function (subscription) {
            var subscriptions = this._subscriptions;
            if (subscriptions) {
                var subscriptionIndex = subscriptions.indexOf(subscription);
                if (subscriptionIndex !== -1) {
                    subscriptions.splice(subscriptionIndex, 1);
                }
            }
        };
        Subscription.EMPTY = (function (empty) {
            empty.closed = true;
            return empty;
        }(new Subscription()));
        return Subscription;
    }());
    exports.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError.UnsubscriptionError) ? err.errors : err); }, []);
    }

    });

    var rxSubscriber = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.rxSubscriber = (function () {
        return typeof Symbol === 'function'
            ? Symbol('rxSubscriber')
            : '@@rxSubscriber_' + Math.random();
    })();
    exports.$$rxSubscriber = exports.rxSubscriber;

    });

    var Subscriber_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });






    var Subscriber = (function (_super) {
        __extends(Subscriber, _super);
        function Subscriber(destinationOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this.syncErrorValue = null;
            _this.syncErrorThrown = false;
            _this.syncErrorThrowable = false;
            _this.isStopped = false;
            switch (arguments.length) {
                case 0:
                    _this.destination = Observer.empty;
                    break;
                case 1:
                    if (!destinationOrNext) {
                        _this.destination = Observer.empty;
                        break;
                    }
                    if (typeof destinationOrNext === 'object') {
                        if (destinationOrNext instanceof Subscriber) {
                            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                            _this.destination = destinationOrNext;
                            destinationOrNext.add(_this);
                        }
                        else {
                            _this.syncErrorThrowable = true;
                            _this.destination = new SafeSubscriber(_this, destinationOrNext);
                        }
                        break;
                    }
                default:
                    _this.syncErrorThrowable = true;
                    _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                    break;
            }
            return _this;
        }
        Subscriber.prototype[rxSubscriber.rxSubscriber] = function () { return this; };
        Subscriber.create = function (next, error, complete) {
            var subscriber = new Subscriber(next, error, complete);
            subscriber.syncErrorThrowable = false;
            return subscriber;
        };
        Subscriber.prototype.next = function (value) {
            if (!this.isStopped) {
                this._next(value);
            }
        };
        Subscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                this.isStopped = true;
                this._error(err);
            }
        };
        Subscriber.prototype.complete = function () {
            if (!this.isStopped) {
                this.isStopped = true;
                this._complete();
            }
        };
        Subscriber.prototype.unsubscribe = function () {
            if (this.closed) {
                return;
            }
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
        };
        Subscriber.prototype._next = function (value) {
            this.destination.next(value);
        };
        Subscriber.prototype._error = function (err) {
            this.destination.error(err);
            this.unsubscribe();
        };
        Subscriber.prototype._complete = function () {
            this.destination.complete();
            this.unsubscribe();
        };
        Subscriber.prototype._unsubscribeAndRecycle = function () {
            var _parentOrParents = this._parentOrParents;
            this._parentOrParents = null;
            this.unsubscribe();
            this.closed = false;
            this.isStopped = false;
            this._parentOrParents = _parentOrParents;
            return this;
        };
        return Subscriber;
    }(Subscription_1.Subscription));
    exports.Subscriber = Subscriber;
    var SafeSubscriber = (function (_super) {
        __extends(SafeSubscriber, _super);
        function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
            var _this = _super.call(this) || this;
            _this._parentSubscriber = _parentSubscriber;
            var next;
            var context = _this;
            if (isFunction_1$1.isFunction(observerOrNext)) {
                next = observerOrNext;
            }
            else if (observerOrNext) {
                next = observerOrNext.next;
                error = observerOrNext.error;
                complete = observerOrNext.complete;
                if (observerOrNext !== Observer.empty) {
                    context = Object.create(observerOrNext);
                    if (isFunction_1$1.isFunction(context.unsubscribe)) {
                        _this.add(context.unsubscribe.bind(context));
                    }
                    context.unsubscribe = _this.unsubscribe.bind(_this);
                }
            }
            _this._context = context;
            _this._next = next;
            _this._error = error;
            _this._complete = complete;
            return _this;
        }
        SafeSubscriber.prototype.next = function (value) {
            if (!this.isStopped && this._next) {
                var _parentSubscriber = this._parentSubscriber;
                if (!config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._next, value);
                }
                else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.error = function (err) {
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                var useDeprecatedSynchronousErrorHandling = config.config.useDeprecatedSynchronousErrorHandling;
                if (this._error) {
                    if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(this._error, err);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, this._error, err);
                        this.unsubscribe();
                    }
                }
                else if (!_parentSubscriber.syncErrorThrowable) {
                    this.unsubscribe();
                    if (useDeprecatedSynchronousErrorHandling) {
                        throw err;
                    }
                    hostReportError_1.hostReportError(err);
                }
                else {
                    if (useDeprecatedSynchronousErrorHandling) {
                        _parentSubscriber.syncErrorValue = err;
                        _parentSubscriber.syncErrorThrown = true;
                    }
                    else {
                        hostReportError_1.hostReportError(err);
                    }
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.complete = function () {
            var _this = this;
            if (!this.isStopped) {
                var _parentSubscriber = this._parentSubscriber;
                if (this._complete) {
                    var wrappedComplete = function () { return _this._complete.call(_this._context); };
                    if (!config.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                        this.__tryOrUnsub(wrappedComplete);
                        this.unsubscribe();
                    }
                    else {
                        this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                        this.unsubscribe();
                    }
                }
                else {
                    this.unsubscribe();
                }
            }
        };
        SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                this.unsubscribe();
                if (config.config.useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
            }
        };
        SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
            if (!config.config.useDeprecatedSynchronousErrorHandling) {
                throw new Error('bad call');
            }
            try {
                fn.call(this._context, value);
            }
            catch (err) {
                if (config.config.useDeprecatedSynchronousErrorHandling) {
                    parent.syncErrorValue = err;
                    parent.syncErrorThrown = true;
                    return true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                    return true;
                }
            }
            return false;
        };
        SafeSubscriber.prototype._unsubscribe = function () {
            var _parentSubscriber = this._parentSubscriber;
            this._context = null;
            this._parentSubscriber = null;
            _parentSubscriber.unsubscribe();
        };
        return SafeSubscriber;
    }(Subscriber));
    exports.SafeSubscriber = SafeSubscriber;

    });

    var filter_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function filter(predicate, thisArg) {
        return function filterOperatorFunction(source) {
            return source.lift(new FilterOperator(predicate, thisArg));
        };
    }
    exports.filter = filter;
    var FilterOperator = (function () {
        function FilterOperator(predicate, thisArg) {
            this.predicate = predicate;
            this.thisArg = thisArg;
        }
        FilterOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
        };
        return FilterOperator;
    }());
    var FilterSubscriber = (function (_super) {
        __extends(FilterSubscriber, _super);
        function FilterSubscriber(destination, predicate, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.predicate = predicate;
            _this.thisArg = thisArg;
            _this.count = 0;
            return _this;
        }
        FilterSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.predicate.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            if (result) {
                this.destination.next(value);
            }
        };
        return FilterSubscriber;
    }(Subscriber_1.Subscriber));

    });

    var filter_1$1 = filter_1.filter;

    var filter = {
    	filter: filter_1$1
    };

    var map_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function map(project, thisArg) {
        return function mapOperation(source) {
            if (typeof project !== 'function') {
                throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
            }
            return source.lift(new MapOperator(project, thisArg));
        };
    }
    exports.map = map;
    var MapOperator = (function () {
        function MapOperator(project, thisArg) {
            this.project = project;
            this.thisArg = thisArg;
        }
        MapOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
        };
        return MapOperator;
    }());
    exports.MapOperator = MapOperator;
    var MapSubscriber = (function (_super) {
        __extends(MapSubscriber, _super);
        function MapSubscriber(destination, project, thisArg) {
            var _this = _super.call(this, destination) || this;
            _this.project = project;
            _this.count = 0;
            _this.thisArg = thisArg || _this;
            return _this;
        }
        MapSubscriber.prototype._next = function (value) {
            var result;
            try {
                result = this.project.call(this.thisArg, value, this.count++);
            }
            catch (err) {
                this.destination.error(err);
                return;
            }
            this.destination.next(result);
        };
        return MapSubscriber;
    }(Subscriber_1.Subscriber));

    });

    var map_1$1 = map_1.map;

    var map = {
    	map: map_1$1
    };

    var isObj = function (x) {
    	var type = typeof x;
    	return x !== null && (type === 'object' || type === 'function');
    };

    var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
    var propIsEnumerable$1 = Object.prototype.propertyIsEnumerable;

    function toObject$1(val) {
    	if (val === null || val === undefined) {
    		throw new TypeError('Sources cannot be null or undefined');
    	}

    	return Object(val);
    }

    function assignKey(to, from, key) {
    	var val = from[key];

    	if (val === undefined || val === null) {
    		return;
    	}

    	if (hasOwnProperty$5.call(to, key)) {
    		if (to[key] === undefined || to[key] === null) {
    			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
    		}
    	}

    	if (!hasOwnProperty$5.call(to, key) || !isObj(val)) {
    		to[key] = val;
    	} else {
    		to[key] = assign$1(Object(to[key]), from[key]);
    	}
    }

    function assign$1(to, from) {
    	if (to === from) {
    		return to;
    	}

    	from = Object(from);

    	for (var key in from) {
    		if (hasOwnProperty$5.call(from, key)) {
    			assignKey(to, from, key);
    		}
    	}

    	if (Object.getOwnPropertySymbols) {
    		var symbols = Object.getOwnPropertySymbols(from);

    		for (var i = 0; i < symbols.length; i++) {
    			if (propIsEnumerable$1.call(from, symbols[i])) {
    				assignKey(to, from, symbols[i]);
    			}
    		}
    	}

    	return to;
    }

    var deepAssign = function deepAssign(target) {
    	target = toObject$1(target);

    	for (var s = 1; s < arguments.length; s++) {
    		assign$1(target, arguments[s]);
    	}

    	return target;
    };

    var getSelection = function getSelection(sel) {
      if (typeof sel === 'string' || Array.isArray(sel)) {
        return {
          id: sel
        };
      }

      if (sel && sel.query) {
        return {
          query: sel.query
        };
      }

      var selectionOpts = ['* Document ID (<docId>)', '* Array of document IDs', '* Object containing `query`'].join('\n');
      throw new Error("Unknown selection - must be one of:\n\n".concat(selectionOpts));
    };

    var validators = createCommonjsModule(function (module, exports) {

    function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

    var VALID_ASSET_TYPES = ['image', 'file'];
    var VALID_INSERT_LOCATIONS = ['before', 'after', 'replace'];

    exports.dataset = function (name) {
      if (!/^[-\w]{1,128}$/.test(name)) {
        throw new Error('Datasets can only contain lowercase characters, numbers, underscores and dashes');
      }
    };

    exports.projectId = function (id) {
      if (!/^[-a-z0-9]+$/i.test(id)) {
        throw new Error('`projectId` can only contain only a-z, 0-9 and dashes');
      }
    };

    exports.validateAssetType = function (type) {
      if (VALID_ASSET_TYPES.indexOf(type) === -1) {
        throw new Error("Invalid asset type: ".concat(type, ". Must be one of ").concat(VALID_ASSET_TYPES.join(', ')));
      }
    };

    exports.validateObject = function (op, val) {
      if (val === null || _typeof(val) !== 'object' || Array.isArray(val)) {
        throw new Error("".concat(op, "() takes an object of properties"));
      }
    };

    exports.requireDocumentId = function (op, doc) {
      if (!doc._id) {
        throw new Error("".concat(op, "() requires that the document contains an ID (\"_id\" property)"));
      }

      exports.validateDocumentId(op, doc._id);
    };

    exports.validateDocumentId = function (op, id) {
      if (typeof id !== 'string' || !/^[a-z0-9_.-]+$/i.test(id)) {
        throw new Error("".concat(op, "(): \"").concat(id, "\" is not a valid document ID"));
      }
    };

    exports.validateInsert = function (at, selector, items) {
      var signature = 'insert(at, selector, items)';

      if (VALID_INSERT_LOCATIONS.indexOf(at) === -1) {
        var valid = VALID_INSERT_LOCATIONS.map(function (loc) {
          return "\"".concat(loc, "\"");
        }).join(', ');
        throw new Error("".concat(signature, " takes an \"at\"-argument which is one of: ").concat(valid));
      }

      if (typeof selector !== 'string') {
        throw new Error("".concat(signature, " takes a \"selector\"-argument which must be a string"));
      }

      if (!Array.isArray(items)) {
        throw new Error("".concat(signature, " takes an \"items\"-argument which must be an array"));
      }
    };

    exports.hasDataset = function (config) {
      if (!config.gradientMode && !config.dataset) {
        throw new Error('`dataset` must be provided to perform queries');
      }

      return config.dataset || '';
    };
    });

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









    var validateObject = validators.validateObject;
    var validateInsert = validators.validateInsert;

    function Patch(selection) {
      var operations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var client = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.selection = selection;
      this.operations = objectAssign({}, operations);
      this.client = client;
    }

    objectAssign(Patch.prototype, {
      clone: function clone() {
        return new Patch(this.selection, objectAssign({}, this.operations), this.client);
      },
      merge: function merge(props) {
        validateObject('merge', props);
        var stack = new Error().stack.toString().split('\n').filter(function (str) {
          return str.trim();
        }).slice(2);
        console.warn("The \"merge\" patch has been deprecated and will be removed in the future\n".concat(stack.join('\n')));
        return this._assign('merge', deepAssign(this.operations.merge || {}, props));
      },
      set: function set(props) {
        return this._assign('set', props);
      },
      diffMatchPatch: function diffMatchPatch(props) {
        validateObject('diffMatchPatch', props);
        return this._assign('diffMatchPatch', props);
      },
      unset: function unset(attrs) {
        if (!Array.isArray(attrs)) {
          throw new Error('unset(attrs) takes an array of attributes to unset, non-array given');
        }

        this.operations = objectAssign({}, this.operations, {
          unset: attrs
        });
        return this;
      },
      setIfMissing: function setIfMissing(props) {
        return this._assign('setIfMissing', props);
      },
      replace: function replace(props) {
        validateObject('replace', props);
        return this._set('set', {
          $: props
        }); // eslint-disable-line id-length
      },
      inc: function inc(props) {
        return this._assign('inc', props);
      },
      dec: function dec(props) {
        return this._assign('dec', props);
      },
      insert: function insert(at, selector, items) {
        var _this$_assign;

        validateInsert(at, selector, items);
        return this._assign('insert', (_this$_assign = {}, _defineProperty(_this$_assign, at, selector), _defineProperty(_this$_assign, "items", items), _this$_assign));
      },
      append: function append(selector, items) {
        return this.insert('after', "".concat(selector, "[-1]"), items);
      },
      prepend: function prepend(selector, items) {
        return this.insert('before', "".concat(selector, "[0]"), items);
      },
      splice: function splice(selector, start, deleteCount, items) {
        // Negative indexes doesn't mean the same in Sanity as they do in JS;
        // -1 means "actually at the end of the array", which allows inserting
        // at the end of the array without knowing its length. We therefore have
        // to substract negative indexes by one to match JS. If you want Sanity-
        // behaviour, just use `insert('replace', selector, items)` directly
        var delAll = typeof deleteCount === 'undefined' || deleteCount === -1;
        var startIndex = start < 0 ? start - 1 : start;
        var delCount = delAll ? -1 : Math.max(0, start + deleteCount);
        var delRange = startIndex < 0 && delCount >= 0 ? '' : delCount;
        var rangeSelector = "".concat(selector, "[").concat(startIndex, ":").concat(delRange, "]");
        return this.insert('replace', rangeSelector, items || []);
      },
      ifRevisionId: function ifRevisionId(rev) {
        this.operations.ifRevisionID = rev;
        return this;
      },
      serialize: function serialize() {
        return objectAssign(getSelection(this.selection), this.operations);
      },
      toJSON: function toJSON() {
        return this.serialize();
      },
      commit: function commit() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!this.client) {
          throw new Error('No `client` passed to patch, either provide one or pass the ' + 'patch to a clients `mutate()` method');
        }

        var returnFirst = typeof this.selection === 'string';
        var opts = objectAssign({
          returnFirst: returnFirst,
          returnDocuments: true
        }, options);
        return this.client.mutate({
          patch: this.serialize()
        }, opts);
      },
      reset: function reset() {
        this.operations = {};
        return this;
      },
      _set: function _set(op, props) {
        return this._assign(op, props, false);
      },
      _assign: function _assign(op, props) {
        var merge = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        validateObject(op, props);
        this.operations = objectAssign({}, this.operations, _defineProperty({}, op, objectAssign({}, merge && this.operations[op] || {}, props)));
        return this;
      }
    });
    var patch = Patch;

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







    var defaultMutateOptions = {
      returnDocuments: false
    };

    function Transaction() {
      var operations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var client = arguments.length > 1 ? arguments[1] : undefined;
      var transactionId = arguments.length > 2 ? arguments[2] : undefined;
      this.trxId = transactionId;
      this.operations = operations;
      this.client = client;
    }

    objectAssign(Transaction.prototype, {
      clone: function clone() {
        return new Transaction(this.operations.slice(0), this.client, this.trxId);
      },
      create: function create(doc) {
        validators.validateObject('create', doc);
        return this._add({
          create: doc
        });
      },
      createIfNotExists: function createIfNotExists(doc) {
        var op = 'createIfNotExists';
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add(_defineProperty$1({}, op, doc));
      },
      createOrReplace: function createOrReplace(doc) {
        var op = 'createOrReplace';
        validators.validateObject(op, doc);
        validators.requireDocumentId(op, doc);
        return this._add(_defineProperty$1({}, op, doc));
      },
      delete: function _delete(documentId) {
        validators.validateDocumentId('delete', documentId);
        return this._add({
          delete: {
            id: documentId
          }
        });
      },
      patch: function patch$1(documentId, patchOps) {
        var isBuilder = typeof patchOps === 'function';
        var isPatch = documentId instanceof patch; // transaction.patch(client.patch('documentId').inc({visits: 1}))

        if (isPatch) {
          return this._add({
            patch: documentId.serialize()
          });
        } // patch => patch.inc({visits: 1}).set({foo: 'bar'})


        if (isBuilder) {
          var patch$1 = patchOps(new patch(documentId, {}, this.client));

          if (!(patch$1 instanceof patch)) {
            throw new Error('function passed to `patch()` must return the patch');
          }

          return this._add({
            patch: patch$1.serialize()
          });
        }

        return this._add({
          patch: objectAssign({
            id: documentId
          }, patchOps)
        });
      },
      transactionId: function transactionId(id) {
        if (!id) {
          return this.trxId;
        }

        this.trxId = id;
        return this;
      },
      serialize: function serialize() {
        return this.operations.slice();
      },
      toJSON: function toJSON() {
        return this.serialize();
      },
      commit: function commit(options) {
        if (!this.client) {
          throw new Error('No `client` passed to transaction, either provide one or pass the ' + 'transaction to a clients `mutate()` method');
        }

        return this.client.mutate(this.serialize(), objectAssign({
          transactionId: this.trxId
        }, defaultMutateOptions, options || {}));
      },
      reset: function reset() {
        this.operations = [];
        return this;
      },
      _add: function _add(mut) {
        this.operations.push(mut);
        return this;
      }
    });
    var transaction = Transaction;

    var enc = encodeURIComponent;

    var encodeQueryString = function (_ref) {
      var query = _ref.query,
          _ref$params = _ref.params,
          params = _ref$params === void 0 ? {} : _ref$params,
          _ref$options = _ref.options,
          options = _ref$options === void 0 ? {} : _ref$options;
      var base = "?query=".concat(enc(query));
      var qString = Object.keys(params).reduce(function (qs, param) {
        return "".concat(qs, "&").concat(enc("$".concat(param)), "=").concat(enc(JSON.stringify(params[param])));
      }, base);
      return Object.keys(options).reduce(function (qs, option) {
        // Only include the option if it is truthy
        return options[option] ? "".concat(qs, "&").concat(enc(option), "=").concat(enc(options[option])) : qs;
      }, qString);
    };

    var canReportError_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    function canReportError(observer) {
        while (observer) {
            var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
            if (closed_1 || isStopped) {
                return false;
            }
            else if (destination && destination instanceof Subscriber_1.Subscriber) {
                observer = destination;
            }
            else {
                observer = null;
            }
        }
        return true;
    }
    exports.canReportError = canReportError;

    });

    var toSubscriber_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });



    function toSubscriber(nextOrObserver, error, complete) {
        if (nextOrObserver) {
            if (nextOrObserver instanceof Subscriber_1.Subscriber) {
                return nextOrObserver;
            }
            if (nextOrObserver[rxSubscriber.rxSubscriber]) {
                return nextOrObserver[rxSubscriber.rxSubscriber]();
            }
        }
        if (!nextOrObserver && !error && !complete) {
            return new Subscriber_1.Subscriber(Observer.empty);
        }
        return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    exports.toSubscriber = toSubscriber;

    });

    var observable = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

    });

    var identity_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    function identity(x) {
        return x;
    }
    exports.identity = identity;

    });

    var pipe_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
    }
    exports.pipe = pipe;
    function pipeFromArray(fns) {
        if (fns.length === 0) {
            return identity_1.identity;
        }
        if (fns.length === 1) {
            return fns[0];
        }
        return function piped(input) {
            return fns.reduce(function (prev, fn) { return fn(prev); }, input);
        };
    }
    exports.pipeFromArray = pipeFromArray;

    });

    var Observable_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });





    var Observable = (function () {
        function Observable(subscribe) {
            this._isScalar = false;
            if (subscribe) {
                this._subscribe = subscribe;
            }
        }
        Observable.prototype.lift = function (operator) {
            var observable = new Observable();
            observable.source = this;
            observable.operator = operator;
            return observable;
        };
        Observable.prototype.subscribe = function (observerOrNext, error, complete) {
            var operator = this.operator;
            var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
            if (operator) {
                sink.add(operator.call(sink, this.source));
            }
            else {
                sink.add(this.source || (config.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                    this._subscribe(sink) :
                    this._trySubscribe(sink));
            }
            if (config.config.useDeprecatedSynchronousErrorHandling) {
                if (sink.syncErrorThrowable) {
                    sink.syncErrorThrowable = false;
                    if (sink.syncErrorThrown) {
                        throw sink.syncErrorValue;
                    }
                }
            }
            return sink;
        };
        Observable.prototype._trySubscribe = function (sink) {
            try {
                return this._subscribe(sink);
            }
            catch (err) {
                if (config.config.useDeprecatedSynchronousErrorHandling) {
                    sink.syncErrorThrown = true;
                    sink.syncErrorValue = err;
                }
                if (canReportError_1.canReportError(sink)) {
                    sink.error(err);
                }
                else {
                    console.warn(err);
                }
            }
        };
        Observable.prototype.forEach = function (next, promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var subscription;
                subscription = _this.subscribe(function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        if (subscription) {
                            subscription.unsubscribe();
                        }
                    }
                }, reject, resolve);
            });
        };
        Observable.prototype._subscribe = function (subscriber) {
            var source = this.source;
            return source && source.subscribe(subscriber);
        };
        Observable.prototype[observable.observable] = function () {
            return this;
        };
        Observable.prototype.pipe = function () {
            var operations = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operations[_i] = arguments[_i];
            }
            if (operations.length === 0) {
                return this;
            }
            return pipe_1.pipeFromArray(operations)(this);
        };
        Observable.prototype.toPromise = function (promiseCtor) {
            var _this = this;
            promiseCtor = getPromiseCtor(promiseCtor);
            return new promiseCtor(function (resolve, reject) {
                var value;
                _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
            });
        };
        Observable.create = function (subscribe) {
            return new Observable(subscribe);
        };
        return Observable;
    }());
    exports.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
        if (!promiseCtor) {
            promiseCtor = config.config.Promise || Promise;
        }
        if (!promiseCtor) {
            throw new Error('no Promise impl found');
        }
        return promiseCtor;
    }

    });

    var scan_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function scan(accumulator, seed) {
        var hasSeed = false;
        if (arguments.length >= 2) {
            hasSeed = true;
        }
        return function scanOperatorFunction(source) {
            return source.lift(new ScanOperator(accumulator, seed, hasSeed));
        };
    }
    exports.scan = scan;
    var ScanOperator = (function () {
        function ScanOperator(accumulator, seed, hasSeed) {
            if (hasSeed === void 0) { hasSeed = false; }
            this.accumulator = accumulator;
            this.seed = seed;
            this.hasSeed = hasSeed;
        }
        ScanOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
        };
        return ScanOperator;
    }());
    var ScanSubscriber = (function (_super) {
        __extends(ScanSubscriber, _super);
        function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
            var _this = _super.call(this, destination) || this;
            _this.accumulator = accumulator;
            _this._seed = _seed;
            _this.hasSeed = hasSeed;
            _this.index = 0;
            return _this;
        }
        Object.defineProperty(ScanSubscriber.prototype, "seed", {
            get: function () {
                return this._seed;
            },
            set: function (value) {
                this.hasSeed = true;
                this._seed = value;
            },
            enumerable: true,
            configurable: true
        });
        ScanSubscriber.prototype._next = function (value) {
            if (!this.hasSeed) {
                this.seed = value;
                this.destination.next(value);
            }
            else {
                return this._tryNext(value);
            }
        };
        ScanSubscriber.prototype._tryNext = function (value) {
            var index = this.index++;
            var result;
            try {
                result = this.accumulator(this.seed, value, index);
            }
            catch (err) {
                this.destination.error(err);
            }
            this.seed = result;
            this.destination.next(result);
        };
        return ScanSubscriber;
    }(Subscriber_1.Subscriber));

    });

    var ArgumentOutOfRangeError = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var ArgumentOutOfRangeErrorImpl = (function () {
        function ArgumentOutOfRangeErrorImpl() {
            Error.call(this);
            this.message = 'argument out of range';
            this.name = 'ArgumentOutOfRangeError';
            return this;
        }
        ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
        return ArgumentOutOfRangeErrorImpl;
    })();
    exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

    });

    var empty_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });

    exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
    function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
    }
    exports.empty = empty;
    function emptyScheduled(scheduler) {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
    }

    });

    var takeLast_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });



    function takeLast(count) {
        return function takeLastOperatorFunction(source) {
            if (count === 0) {
                return empty_1.empty();
            }
            else {
                return source.lift(new TakeLastOperator(count));
            }
        };
    }
    exports.takeLast = takeLast;
    var TakeLastOperator = (function () {
        function TakeLastOperator(total) {
            this.total = total;
            if (this.total < 0) {
                throw new ArgumentOutOfRangeError.ArgumentOutOfRangeError;
            }
        }
        TakeLastOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
        };
        return TakeLastOperator;
    }());
    var TakeLastSubscriber = (function (_super) {
        __extends(TakeLastSubscriber, _super);
        function TakeLastSubscriber(destination, total) {
            var _this = _super.call(this, destination) || this;
            _this.total = total;
            _this.ring = new Array();
            _this.count = 0;
            return _this;
        }
        TakeLastSubscriber.prototype._next = function (value) {
            var ring = this.ring;
            var total = this.total;
            var count = this.count++;
            if (ring.length < total) {
                ring.push(value);
            }
            else {
                var index = count % total;
                ring[index] = value;
            }
        };
        TakeLastSubscriber.prototype._complete = function () {
            var destination = this.destination;
            var count = this.count;
            if (count > 0) {
                var total = this.count >= this.total ? this.total : this.count;
                var ring = this.ring;
                for (var i = 0; i < total; i++) {
                    var idx = (count++) % total;
                    destination.next(ring[idx]);
                }
            }
            destination.complete();
        };
        return TakeLastSubscriber;
    }(Subscriber_1.Subscriber));

    });

    var defaultIfEmpty_1 = createCommonjsModule(function (module, exports) {
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });

    function defaultIfEmpty(defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
    }
    exports.defaultIfEmpty = defaultIfEmpty;
    var DefaultIfEmptyOperator = (function () {
        function DefaultIfEmptyOperator(defaultValue) {
            this.defaultValue = defaultValue;
        }
        DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
            return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
        };
        return DefaultIfEmptyOperator;
    }());
    var DefaultIfEmptySubscriber = (function (_super) {
        __extends(DefaultIfEmptySubscriber, _super);
        function DefaultIfEmptySubscriber(destination, defaultValue) {
            var _this = _super.call(this, destination) || this;
            _this.defaultValue = defaultValue;
            _this.isEmpty = true;
            return _this;
        }
        DefaultIfEmptySubscriber.prototype._next = function (value) {
            this.isEmpty = false;
            this.destination.next(value);
        };
        DefaultIfEmptySubscriber.prototype._complete = function () {
            if (this.isEmpty) {
                this.destination.next(this.defaultValue);
            }
            this.destination.complete();
        };
        return DefaultIfEmptySubscriber;
    }(Subscriber_1.Subscriber));

    });

    var reduce_1 = createCommonjsModule(function (module, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });




    function reduce(accumulator, seed) {
        if (arguments.length >= 2) {
            return function reduceOperatorFunctionWithSeed(source) {
                return pipe_1.pipe(scan_1.scan(accumulator, seed), takeLast_1.takeLast(1), defaultIfEmpty_1.defaultIfEmpty(seed))(source);
            };
        }
        return function reduceOperatorFunction(source) {
            return pipe_1.pipe(scan_1.scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast_1.takeLast(1))(source);
        };
    }
    exports.reduce = reduce;

    });

    var reduce_1$1 = reduce_1.reduce;

    var reduce = {
    	reduce: reduce_1$1
    };

    var Observable = Observable_1.Observable;



    var map$1 = map.map;

    var filter$1 = filter.filter;

    var reduce$1 = reduce.reduce;
    /*
     A minimal rxjs based observable that align as closely as possible with the current es-observable spec,
     without the static factory methods
     */


    function SanityObservableMinimal() {
      Observable.apply(this, arguments); // eslint-disable-line prefer-rest-params
    }

    SanityObservableMinimal.prototype = Object.create(objectAssign(Object.create(null), Observable.prototype));
    Object.defineProperty(SanityObservableMinimal.prototype, 'constructor', {
      value: SanityObservableMinimal,
      enumerable: false,
      writable: true,
      configurable: true
    });

    SanityObservableMinimal.prototype.lift = function lift(operator) {
      var observable = new SanityObservableMinimal();
      observable.source = this;
      observable.operator = operator;
      return observable;
    };

    function createDeprecatedMemberOp(name, op) {
      var hasWarned = false;
      return function deprecatedOperator() {
        if (!hasWarned) {
          hasWarned = true;
          console.warn(new Error("Calling observable.".concat(name, "(...) is deprecated. Please use observable.pipe(").concat(name, "(...)) instead")));
        }

        return this.pipe(op.apply(this, arguments));
      };
    }

    SanityObservableMinimal.prototype.map = createDeprecatedMemberOp('map', map$1);
    SanityObservableMinimal.prototype.filter = createDeprecatedMemberOp('filter', filter$1);
    SanityObservableMinimal.prototype.reduce = createDeprecatedMemberOp('filter', reduce$1);
    var SanityObservableMinimal_1 = SanityObservableMinimal;

    var minimal = SanityObservableMinimal_1;

    var eventsource = createCommonjsModule(function (module) {
    (function (root, factory) {
      /* global define */
      if ( module.exports) {
        // CommonJS
        module.exports = factory();
      } else {
        // Browser globals (root is window)
        if (commonjsGlobal.EventSource && !commonjsGlobal._eventSourceImportPrefix) {
          return
        }

        var evsImportName = (root._eventSourceImportPrefix || '') + 'EventSource';
        root[evsImportName] = factory();
      }
    })(typeof self === 'undefined' ? commonjsGlobal : self, function () {
      var EventSource = function (url, options) {
        if (!url || typeof url != 'string') {
          throw new SyntaxError('Not enough arguments')
        }

        this.URL = url;
        this.setOptions(options);
        var evs = this;
        setTimeout(function () {
          evs.poll();
        }, 0);
      };

      EventSource.prototype = {
        CONNECTING: 0,

        OPEN: 1,

        CLOSED: 2,

        defaultOptions: {
          loggingEnabled: false,

          loggingPrefix: 'eventsource',

          interval: 500, // milliseconds

          bufferSizeLimit: 256 * 1024, // bytes

          silentTimeout: 300000, // milliseconds

          getArgs: {
            evs_buffer_size_limit: 256 * 1024,
          },

          xhrHeaders: {
            Accept: 'text/event-stream',
            'Cache-Control': 'no-cache',
            'X-Requested-With': 'XMLHttpRequest',
          },
        },

        setOptions: function (options) {
          var defaults = this.defaultOptions;
          var option;

          // set all default options...
          for (option in defaults) {
            if (defaults.hasOwnProperty(option)) {
              this[option] = defaults[option];
            }
          }

          // override with what is in options
          for (option in options) {
            if (option in defaults && options.hasOwnProperty(option)) {
              this[option] = options[option];
            }
          }

          // if getArgs option is enabled
          // ensure evs_buffer_size_limit corresponds to bufferSizeLimit
          if (this.getArgs && this.bufferSizeLimit) {
            this.getArgs.evs_buffer_size_limit = this.bufferSizeLimit;
          }

          // if console is not available, force loggingEnabled to false
          // eslint-disable-next-line no-console
          if (typeof console === 'undefined' || typeof console.log === 'undefined') {
            this.loggingEnabled = false;
          }
        },

        log: function (message) {
          if (this.loggingEnabled) {
            // eslint-disable-next-line no-console
            console.log('[' + this.loggingPrefix + ']:' + message);
          }
        },

        poll: function () {
          try {
            if (this.readyState == this.CLOSED) {
              return
            }

            this.cleanup();
            this.readyState = this.CONNECTING;
            this.cursor = 0;
            this.cache = '';
            this._xhr = new this.XHR(this);
            this.resetNoActivityTimer();
          } catch (err) {
            // in an attempt to silence the errors
            this.log('There were errors inside the pool try-catch');
            this.dispatchEvent('error', {type: 'error', data: err.message});
          }
        },

        pollAgain: function (interval) {
          // schedule poll to be called after interval milliseconds
          var evs = this;
          evs.readyState = evs.CONNECTING;
          evs.dispatchEvent('error', {
            type: 'error',
            data: 'Reconnecting ',
          });
          this._pollTimer = setTimeout(function () {
            evs.poll();
          }, interval || 0);
        },

        cleanup: function () {
          this.log('evs cleaning up');

          if (this._pollTimer) {
            clearInterval(this._pollTimer);
            this._pollTimer = null;
          }

          if (this._noActivityTimer) {
            clearInterval(this._noActivityTimer);
            this._noActivityTimer = null;
          }

          if (this._xhr) {
            this._xhr.abort();
            this._xhr = null;
          }
        },

        resetNoActivityTimer: function () {
          if (this.silentTimeout) {
            if (this._noActivityTimer) {
              clearInterval(this._noActivityTimer);
            }
            var evs = this;
            this._noActivityTimer = setTimeout(function () {
              evs.log('Timeout! silentTImeout:' + evs.silentTimeout);
              evs.pollAgain();
            }, this.silentTimeout);
          }
        },

        close: function () {
          this.readyState = this.CLOSED;
          this.log('Closing connection. readyState: ' + this.readyState);
          this.cleanup();
        },

        _onxhrdata: function () {
          var request = this._xhr;

          if (request.isReady() && !request.hasError()) {
            // reset the timer, as we have activity
            this.resetNoActivityTimer();

            // move this EventSource to OPEN state...
            if (this.readyState == this.CONNECTING) {
              this.readyState = this.OPEN;
              this.dispatchEvent('open', {type: 'open'});
            }

            var buffer = request.getBuffer();

            if (buffer.length > this.bufferSizeLimit) {
              this.log('buffer.length > this.bufferSizeLimit');
              this.pollAgain();
            }

            if (this.cursor == 0 && buffer.length > 0) {
              // skip byte order mark \uFEFF character if it starts the stream
              if (buffer.substring(0, 1) == '\uFEFF') {
                this.cursor = 1;
              }
            }

            var lastMessageIndex = this.lastMessageIndex(buffer);
            if (lastMessageIndex[0] >= this.cursor) {
              var newcursor = lastMessageIndex[1];
              var toparse = buffer.substring(this.cursor, newcursor);
              this.parseStream(toparse);
              this.cursor = newcursor;
            }

            // if request is finished, reopen the connection
            if (request.isDone()) {
              this.log('request.isDone(). reopening the connection');
              this.pollAgain(this.interval);
            }
          } else if (this.readyState !== this.CLOSED) {
            this.log('this.readyState !== this.CLOSED');
            this.pollAgain(this.interval);

            //MV: Unsure why an error was previously dispatched
          }
        },

        parseStream: function (chunk) {
          // normalize line separators (\r\n,\r,\n) to \n
          // remove white spaces that may precede \n
          chunk = this.cache + this.normalizeToLF(chunk);

          var events = chunk.split('\n\n');

          var i, j, eventType, datas, line, retry;

          for (i = 0; i < events.length - 1; i++) {
            eventType = 'message';
            datas = [];
            var parts = events[i].split('\n');

            for (j = 0; j < parts.length; j++) {
              line = this.trimWhiteSpace(parts[j]);

              if (line.indexOf('event') == 0) {
                eventType = line.replace(/event:?\s*/, '');
              } else if (line.indexOf('retry') == 0) {
                retry = parseInt(line.replace(/retry:?\s*/, ''), 10);
                if (!isNaN(retry)) {
                  this.interval = retry;
                }
              } else if (line.indexOf('data') == 0) {
                datas.push(line.replace(/data:?\s*/, ''));
              } else if (line.indexOf('id:') == 0) {
                this.lastEventId = line.replace(/id:?\s*/, '');
              } else if (line.indexOf('id') == 0) {
                // this resets the id

                this.lastEventId = null;
              }
            }

            if (datas.length && this.readyState != this.CLOSED) {
              // dispatch a new event
              var event = new MessageEvent(
                eventType,
                datas.join('\n'),
                typeof window !== 'undefined' && typeof window.location !== 'undefined'
                  ? window.location.origin
                  : null,
                this.lastEventId
              );
              this.dispatchEvent(eventType, event);
            }
          }

          this.cache = events[events.length - 1];
        },

        dispatchEvent: function (type, event) {
          var handlers = this['_' + type + 'Handlers'];

          if (handlers) {
            for (var i = 0; i < handlers.length; i++) {
              handlers[i].call(this, event);
            }
          }

          if (this['on' + type]) {
            this['on' + type].call(this, event);
          }
        },

        addEventListener: function (type, handler) {
          if (!this['_' + type + 'Handlers']) {
            this['_' + type + 'Handlers'] = [];
          }

          this['_' + type + 'Handlers'].push(handler);
        },

        removeEventListener: function (type, handler) {
          var handlers = this['_' + type + 'Handlers'];
          if (!handlers) {
            return
          }
          for (var i = handlers.length - 1; i >= 0; --i) {
            if (handlers[i] === handler) {
              handlers.splice(i, 1);
              break
            }
          }
        },

        _pollTimer: null,

        _noactivityTimer: null,

        _xhr: null,

        lastEventId: null,

        cache: '',

        cursor: 0,

        onerror: null,

        onmessage: null,

        onopen: null,

        readyState: 0,

        // ===================================================================
        // helpers functions
        // those are attached to prototype to ease reuse and testing...

        urlWithParams: function (baseURL, params) {
          var encodedArgs = [];

          if (params) {
            var key, urlarg;
            var urlize = encodeURIComponent;

            for (key in params) {
              if (params.hasOwnProperty(key)) {
                urlarg = urlize(key) + '=' + urlize(params[key]);
                encodedArgs.push(urlarg);
              }
            }
          }

          if (encodedArgs.length > 0) {
            if (baseURL.indexOf('?') == -1) return baseURL + '?' + encodedArgs.join('&')
            return baseURL + '&' + encodedArgs.join('&')
          }
          return baseURL
        },

        lastMessageIndex: function (text) {
          var ln2 = text.lastIndexOf('\n\n');
          var lr2 = text.lastIndexOf('\r\r');
          var lrln2 = text.lastIndexOf('\r\n\r\n');

          if (lrln2 > Math.max(ln2, lr2)) {
            return [lrln2, lrln2 + 4]
          }
          return [Math.max(ln2, lr2), Math.max(ln2, lr2) + 2]
        },

        trimWhiteSpace: function (str) {
          // to remove whitespaces left and right of string

          var reTrim = /^(\s|\u00A0)+|(\s|\u00A0)+$/g;
          return str.replace(reTrim, '')
        },

        normalizeToLF: function (str) {
          // replace \r and \r\n with \n
          return str.replace(/\r\n|\r/g, '\n')
        },
      };

      if (isOldIE()) {
        EventSource.isPolyfill = 'IE_8-9';

        // patch EventSource defaultOptions
        var defaults = EventSource.prototype.defaultOptions;
        defaults.xhrHeaders = null; // no headers will be sent
        defaults.getArgs.evs_preamble = 2048 + 8;

        // EventSource will send request using Internet Explorer XDomainRequest
        EventSource.prototype.XHR = function (evs) {
          /* global XDomainRequest */
          var request = new XDomainRequest();
          this._request = request;

          // set handlers
          request.onprogress = function () {
            request._ready = true;
            evs._onxhrdata();
          };

          request.onload = function () {
            this._loaded = true;
            evs._onxhrdata();
          };

          request.onerror = function () {
            this._failed = true;
            evs.readyState = evs.CLOSED;
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'XDomainRequest error',
            });
          };

          request.ontimeout = function () {
            this._failed = true;
            evs.readyState = evs.CLOSED;
            evs.dispatchEvent('error', {
              type: 'error',
              data: 'XDomainRequest timed out',
            });
          };

          // XDomainRequest does not allow setting custom headers
          // If EventSource has enabled the use of GET arguments
          // we add parameters to URL so that server can adapt the stream...
          var reqGetArgs = {};
          if (evs.getArgs) {
            // copy evs.getArgs in reqGetArgs
            var defaultArgs = evs.getArgs;
            for (var key in defaultArgs) {
              if (defaultArgs.hasOwnProperty(key)) {
                reqGetArgs[key] = defaultArgs[key];
              }
            }
            if (evs.lastEventId) {
              reqGetArgs.evs_last_event_id = evs.lastEventId;
            }
          }
          // send the request

          request.open('GET', evs.urlWithParams(evs.URL, reqGetArgs));
          request.send();
        };

        EventSource.prototype.XHR.prototype = {
          useXDomainRequest: true,

          _request: null,

          _ready: false, // true when progress events are dispatched

          _loaded: false, // true when request has been loaded

          _failed: false, // true if when request is in error

          isReady: function () {
            return this._request._ready
          },

          isDone: function () {
            return this._request._loaded
          },

          hasError: function () {
            return this._request._failed
          },

          getBuffer: function () {
            var rv = '';
            try {
              rv = this._request.responseText || '';
            } catch (err) {
              // intentional noop
            }
            return rv
          },

          abort: function () {
            if (this._request) {
              this._request.abort();
            }
          },
        };
      } else {
        EventSource.isPolyfill = 'XHR';

        // EventSource will send request using XMLHttpRequest
        EventSource.prototype.XHR = function (evs) {
          var request = new XMLHttpRequest();
          this._request = request;
          evs._xhr = this;

          // set handlers
          request.onreadystatechange = function () {
            if (request.readyState > 1 && evs.readyState != evs.CLOSED) {
              if (request.status == 200 || (request.status >= 300 && request.status < 400)) {
                evs._onxhrdata();
              } else {
                request._failed = true;
                evs.readyState = evs.CLOSED;
                evs.dispatchEvent('error', {
                  type: 'error',
                  data: 'The server responded with ' + request.status,
                });
                evs.close();
              }
            }
          };

          request.onprogress = function () {
            // intentional noop
          };

          request.open('GET', evs.urlWithParams(evs.URL, evs.getArgs), true);

          var headers = evs.xhrHeaders; // maybe null
          for (var header in headers) {
            if (headers.hasOwnProperty(header)) {
              request.setRequestHeader(header, headers[header]);
            }
          }
          if (evs.lastEventId) {
            request.setRequestHeader('Last-Event-Id', evs.lastEventId);
          }

          request.send();
        };

        EventSource.prototype.XHR.prototype = {
          useXDomainRequest: false,

          _request: null,

          _failed: false, // true if we have had errors...

          isReady: function () {
            return this._request.readyState >= 2
          },

          isDone: function () {
            return this._request.readyState == 4
          },

          hasError: function () {
            return this._failed || this._request.status >= 400
          },

          getBuffer: function () {
            var rv = '';
            try {
              rv = this._request.responseText || '';
            } catch (err) {
              // intentional noop
            }
            return rv
          },

          abort: function () {
            if (this._request) {
              this._request.abort();
            }
          },
        };
      }

      function MessageEvent(type, data, origin, lastEventId) {
        this.bubbles = false;
        this.cancelBubble = false;
        this.cancelable = false;
        this.data = data || null;
        this.origin = origin || '';
        this.lastEventId = lastEventId || '';
        this.type = type || 'message';
      }

      function isOldIE() {
        //return true if we are in IE8 or IE9
        return Boolean(
          typeof window !== 'undefined' &&
            window.XDomainRequest &&
            window.XMLHttpRequest &&
            new XMLHttpRequest().responseType === undefined
        )
      }

      return EventSource
    });
    });

    /* eslint-disable no-var */


    var browser = window.EventSource || eventsource.EventSource;

    var pick = function (obj, props) {
      return props.reduce(function (selection, prop) {
        if (typeof obj[prop] === 'undefined') {
          return selection;
        }

        selection[prop] = obj[prop];
        return selection;
      }, {});
    };

    var defaults = function (obj, defaults) {
      return Object.keys(defaults).concat(Object.keys(obj)).reduce(function (target, prop) {
        target[prop] = typeof obj[prop] === 'undefined' ? defaults[prop] : obj[prop];
        return target;
      }, {});
    };

    var baseUrl = 'https://docs.sanity.io/help/';

    var generateHelpUrl = function generateHelpUrl(slug) {
      return baseUrl + slug
    };

    var once = function (fn) {
      var didCall = false;
      var returnValue;
      return function () {
        if (didCall) {
          return returnValue;
        }

        returnValue = fn.apply(void 0, arguments);
        didCall = true;
        return returnValue;
      };
    };

    var tokenWarning = ['Using token with listeners is not supported in browsers. ', "For more info, see ".concat(generateHelpUrl('js-client-listener-tokens-browser'), ".")]; // eslint-disable-next-line no-console

    var printTokenWarning = once(function () {
      return console.warn(tokenWarning.join(' '));
    });
    var isWindowEventSource = Boolean(typeof window !== 'undefined' && window.EventSource);
    var EventSource = isWindowEventSource ? window.EventSource // Native browser EventSource
    : browser; // Node.js, IE etc

    var possibleOptions = ['includePreviousRevision', 'includeResult', 'visibility', 'effectFormat'];
    var defaultOptions = {
      includeResult: true
    };

    var listen$1 = function listen(query, params) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var options = defaults(opts, defaultOptions);
      var listenOpts = pick(options, possibleOptions);
      var qs = encodeQueryString({
        query: query,
        params: params,
        options: listenOpts
      });
      var _this$clientConfig = this.clientConfig,
          url = _this$clientConfig.url,
          token = _this$clientConfig.token,
          withCredentials = _this$clientConfig.withCredentials;
      var uri = "".concat(url).concat(this.getDataUrl('listen', qs));
      var listenFor = options.events ? options.events : ['mutation'];
      var shouldEmitReconnect = listenFor.indexOf('reconnect') !== -1;

      if (token && isWindowEventSource) {
        printTokenWarning();
      }

      var esOptions = {};

      if (token || withCredentials) {
        esOptions.withCredentials = true;
      }

      if (token) {
        esOptions.headers = {
          Authorization: "Bearer ".concat(token)
        };
      }

      return new minimal(function (observer) {
        var es = getEventSource();
        var reconnectTimer;
        var stopped = false;

        function onError() {
          if (stopped) {
            return;
          }

          emitReconnect(); // Allow event handlers of `emitReconnect` to cancel/close the reconnect attempt

          if (stopped) {
            return;
          } // Unless we've explicitly stopped the ES (in which case `stopped` should be true),
          // we should never be in a disconnected state. By default, EventSource will reconnect
          // automatically, in which case it sets readyState to `CONNECTING`, but in some cases
          // (like when a laptop lid is closed), it closes the connection. In these cases we need
          // to explicitly reconnect.


          if (es.readyState === EventSource.CLOSED) {
            unsubscribe();
            clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(open, 100);
          }
        }

        function onChannelError(err) {
          observer.error(cooerceError(err));
        }

        function onMessage(evt) {
          var event = parseEvent(evt);
          return event instanceof Error ? observer.error(event) : observer.next(event);
        }

        function onDisconnect(evt) {
          stopped = true;
          unsubscribe();
          observer.complete();
        }

        function unsubscribe() {
          es.removeEventListener('error', onError, false);
          es.removeEventListener('channelError', onChannelError, false);
          es.removeEventListener('disconnect', onDisconnect, false);
          listenFor.forEach(function (type) {
            return es.removeEventListener(type, onMessage, false);
          });
          es.close();
        }

        function emitReconnect() {
          if (shouldEmitReconnect) {
            observer.next({
              type: 'reconnect'
            });
          }
        }

        function getEventSource() {
          var evs = new EventSource(uri, esOptions);
          evs.addEventListener('error', onError, false);
          evs.addEventListener('channelError', onChannelError, false);
          evs.addEventListener('disconnect', onDisconnect, false);
          listenFor.forEach(function (type) {
            return evs.addEventListener(type, onMessage, false);
          });
          return evs;
        }

        function open() {
          es = getEventSource();
        }

        function stop() {
          stopped = true;
          unsubscribe();
        }

        return stop;
      });
    };

    function parseEvent(event) {
      try {
        var data = event.data && JSON.parse(event.data) || {};
        return objectAssign({
          type: event.type
        }, data);
      } catch (err) {
        return err;
      }
    }

    function cooerceError(err) {
      if (err instanceof Error) {
        return err;
      }

      var evt = parseEvent(err);
      return evt instanceof Error ? evt : new Error(extractErrorMessage(evt));
    }

    function extractErrorMessage(err) {
      if (!err.error) {
        return err.message || 'Unknown listener error';
      }

      if (err.error.description) {
        return err.error.description;
      }

      return typeof err.error === 'string' ? err.error : JSON.stringify(err.error, null, 2);
    }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



    var filter$2 = filter.filter;

    var map$2 = map.map;













    var excludeFalsey = function excludeFalsey(param, defValue) {
      var value = typeof param === 'undefined' ? defValue : param;
      return param === false ? undefined : value;
    };

    var getMutationQuery = function getMutationQuery() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return {
        returnIds: true,
        returnDocuments: excludeFalsey(options.returnDocuments, true),
        visibility: options.visibility || 'sync'
      };
    };

    var isResponse = function isResponse(event) {
      return event.type === 'response';
    };

    var getBody = function getBody(event) {
      return event.body;
    };

    var indexBy = function indexBy(docs, attr) {
      return docs.reduce(function (indexed, doc) {
        indexed[attr(doc)] = doc;
        return indexed;
      }, Object.create(null));
    };

    var toPromise = function toPromise(observable) {
      return observable.toPromise();
    };

    var getQuerySizeLimit = 11264;
    var dataMethods = {
      listen: listen$1,
      getDataUrl: function getDataUrl(operation, path) {
        var config = this.clientConfig;
        var catalog = config.gradientMode ? config.namespace : validators.hasDataset(config);
        var baseUri = "/".concat(operation, "/").concat(catalog);
        var uri = path ? "".concat(baseUri, "/").concat(path) : baseUri;
        return (this.clientConfig.gradientMode ? uri : "/data".concat(uri)).replace(/\/($|\?)/, '$1');
      },
      fetch: function fetch(query, params) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var mapResponse = options.filterResponse === false ? function (res) {
          return res;
        } : function (res) {
          return res.result;
        };

        var observable = this._dataRequest('query', {
          query: query,
          params: params
        }, options).pipe(map$2(mapResponse));

        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      getDocument: function getDocument(id) {
        var options = {
          uri: this.getDataUrl('doc', id),
          json: true
        };

        var observable = this._requestObservable(options).pipe(filter$2(isResponse), map$2(function (event) {
          return event.body.documents && event.body.documents[0];
        }));

        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      getDocuments: function getDocuments(ids) {
        var options = {
          uri: this.getDataUrl('doc', ids.join(',')),
          json: true
        };

        var observable = this._requestObservable(options).pipe(filter$2(isResponse), map$2(function (event) {
          var indexed = indexBy(event.body.documents || [], function (doc) {
            return doc._id;
          });
          return ids.map(function (id) {
            return indexed[id] || null;
          });
        }));

        return this.isPromiseAPI() ? toPromise(observable) : observable;
      },
      create: function create(doc, options) {
        return this._create(doc, 'create', options);
      },
      createIfNotExists: function createIfNotExists(doc, options) {
        validators.requireDocumentId('createIfNotExists', doc);
        return this._create(doc, 'createIfNotExists', options);
      },
      createOrReplace: function createOrReplace(doc, options) {
        validators.requireDocumentId('createOrReplace', doc);
        return this._create(doc, 'createOrReplace', options);
      },
      patch: function patch$1(selector, operations) {
        return new patch(selector, operations, this);
      },
      delete: function _delete(selection, options) {
        return this.dataRequest('mutate', {
          mutations: [{
            delete: getSelection(selection)
          }]
        }, options);
      },
      mutate: function mutate(mutations, options) {
        var mut = mutations instanceof patch || mutations instanceof transaction ? mutations.serialize() : mutations;
        var muts = Array.isArray(mut) ? mut : [mut];
        var transactionId = options && options.transactionId;
        return this.dataRequest('mutate', {
          mutations: muts,
          transactionId: transactionId
        }, options);
      },
      transaction: function transaction$1(operations) {
        return new transaction(operations, this);
      },
      dataRequest: function dataRequest(endpoint, body) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var request = this._dataRequest(endpoint, body, options);

        return this.isPromiseAPI() ? toPromise(request) : request;
      },
      _dataRequest: function _dataRequest(endpoint, body) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        var isMutation = endpoint === 'mutate'; // Check if the query string is within a configured threshold,
        // in which case we can use GET. Otherwise, use POST.

        var strQuery = !isMutation && encodeQueryString(body);
        var useGet = !isMutation && strQuery.length < getQuerySizeLimit;
        var stringQuery = useGet ? strQuery : '';
        var returnFirst = options.returnFirst;
        var timeout = options.timeout,
            token = options.token;
        var uri = this.getDataUrl(endpoint, stringQuery);
        var reqOptions = {
          method: useGet ? 'GET' : 'POST',
          uri: uri,
          json: true,
          body: useGet ? undefined : body,
          query: isMutation && getMutationQuery(options),
          timeout: timeout,
          token: token
        };
        return this._requestObservable(reqOptions).pipe(filter$2(isResponse), map$2(getBody), map$2(function (res) {
          if (!isMutation) {
            return res;
          } // Should we return documents?


          var results = res.results || [];

          if (options.returnDocuments) {
            return returnFirst ? results[0] && results[0].document : results.map(function (mut) {
              return mut.document;
            });
          } // Return a reduced subset


          var key = returnFirst ? 'documentId' : 'documentIds';
          var ids = returnFirst ? results[0] && results[0].id : results.map(function (mut) {
            return mut.id;
          });
          return _defineProperty$2({
            transactionId: res.transactionId,
            results: results
          }, key, ids);
        }));
      },
      _create: function _create(doc, op) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var mutation = _defineProperty$2({}, op, doc);

        var opts = objectAssign({
          returnFirst: true,
          returnDocuments: true
        }, options);
        return this.dataRequest('mutate', {
          mutations: [mutation]
        }, opts);
      }
    };

    function DatasetsClient(client) {
      this.request = client.request.bind(client);
    }

    objectAssign(DatasetsClient.prototype, {
      create: function create(name, options) {
        return this._modify('PUT', name, options);
      },
      edit: function edit(name, options) {
        return this._modify('PATCH', name, options);
      },
      delete: function _delete(name) {
        return this._modify('DELETE', name);
      },
      list: function list() {
        return this.request({
          uri: '/datasets'
        });
      },
      _modify: function _modify(method, name, body) {
        validators.dataset(name);
        return this.request({
          method: method,
          uri: "/datasets/".concat(name),
          body: body
        });
      }
    });
    var datasetsClient = DatasetsClient;

    function ProjectsClient(client) {
      this.client = client;
    }

    objectAssign(ProjectsClient.prototype, {
      list: function list() {
        return this.client.request({
          uri: '/projects'
        });
      },
      getById: function getById(id) {
        return this.client.request({
          uri: "/projects/".concat(id)
        });
      }
    });
    var projectsClient = ProjectsClient;

    var queryString = function (params) {
      var qs = [];

      for (var key in params) {
        if (params.hasOwnProperty(key)) {
          qs.push("".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(params[key])));
        }
      }

      return qs.length > 0 ? "?".concat(qs.join('&')) : '';
    };

    function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

    function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

    function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

    function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

    function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

    function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



    var map$3 = map.map;

    var filter$3 = filter.filter;





    function AssetsClient(client) {
      this.client = client;
    }

    function toDocument(body) {
      // todo: rewrite to just return body.document in a while
      var document = body.document;
      Object.defineProperty(document, 'document', {
        enumerable: false,
        get: function get() {
          // eslint-disable-next-line no-console
          console.warn('The promise returned from client.asset.upload(...) now resolves with the asset document');
          return document;
        }
      });
      return document;
    }

    function optionsFromFile(opts, file) {
      if (typeof window === 'undefined' || !(file instanceof window.File)) {
        return opts;
      }

      return objectAssign({
        filename: opts.preserveFilename === false ? undefined : file.name,
        contentType: file.type
      }, opts);
    }

    objectAssign(AssetsClient.prototype, {
      /**
       * Upload an asset
       *
       * @param  {String} assetType `image` or `file`
       * @param  {File|Blob|Buffer|ReadableStream} body File to upload
       * @param  {Object}  opts Options for the upload
       * @param  {Boolean} opts.preserveFilename Whether or not to preserve the original filename (default: true)
       * @param  {String}  opts.filename Filename for this file (optional)
       * @param  {Number}  opts.timeout  Milliseconds to wait before timing the request out (default: 0)
       * @param  {String}  opts.contentType Mime type of the file
       * @param  {Array}   opts.extract Array of metadata parts to extract from image.
       *                                 Possible values: `location`, `exif`, `image`, `palette`
       * @param  {String}  opts.label Label
       * @param  {String}  opts.title Title
       * @param  {String}  opts.description Description
       * @param  {String}  opts.creditLine The credit to person(s) and/or organization(s) required by the supplier of the image to be used when published
       * @param  {Object}  opts.source Source data (when the asset is from an external service)
       * @param  {String}  opts.source.id The (u)id of the asset within the source, i.e. 'i-f323r1E'
       *                                  Required if source is defined
       * @param  {String}  opts.source.name The name of the source, i.e. 'unsplash'
       *                                  Required if source is defined
       * @param  {String}  opts.source.url A url to where to find the asset, or get more info about it in the source
       *                                  Optional
       * @return {Promise} Resolves with the created asset document
       */
      upload: function upload(assetType, body) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        validators.validateAssetType(assetType); // If an empty array is given, explicitly set `none` to override API defaults

        var meta = opts.extract || undefined;

        if (meta && !meta.length) {
          meta = ['none'];
        }

        var dataset = validators.hasDataset(this.client.clientConfig);
        var assetEndpoint = assetType === 'image' ? 'images' : 'files';
        var options = optionsFromFile(opts, body);
        var label = options.label,
            title = options.title,
            description = options.description,
            creditLine = options.creditLine,
            filename = options.filename,
            source = options.source;
        var query = {
          label: label,
          title: title,
          description: description,
          filename: filename,
          meta: meta,
          creditLine: creditLine
        };

        if (source) {
          query.sourceId = source.id;
          query.sourceName = source.name;
          query.sourceUrl = source.url;
        }

        var observable = this.client._requestObservable({
          method: 'POST',
          timeout: options.timeout || 0,
          uri: "/assets/".concat(assetEndpoint, "/").concat(dataset),
          headers: options.contentType ? {
            'Content-Type': options.contentType
          } : {},
          query: query,
          body: body
        });

        return this.client.isPromiseAPI() ? observable.pipe(filter$3(function (event) {
          return event.type === 'response';
        }), map$3(function (event) {
          return toDocument(event.body);
        })).toPromise() : observable;
      },
      delete: function _delete(type, id) {
        // eslint-disable-next-line no-console
        console.warn('client.assets.delete() is deprecated, please use client.delete(<document-id>)');
        var docId = id || '';

        if (!/^(image|file)-/.test(docId)) {
          docId = "".concat(type, "-").concat(docId);
        } else if (type._id) {
          // We could be passing an entire asset document instead of an ID
          docId = type._id;
        }

        validators.hasDataset(this.client.clientConfig);
        return this.client.delete(docId);
      },
      getImageUrl: function getImageUrl(ref, query) {
        var id = ref._ref || ref;

        if (typeof id !== 'string') {
          throw new Error('getImageUrl() needs either an object with a _ref, or a string with an asset document ID');
        }

        if (!/^image-[A-Za-z0-9_]+-\d+x\d+-[a-z]{1,5}$/.test(id)) {
          throw new Error("Unsupported asset ID \"".concat(id, "\". URL generation only works for auto-generated IDs."));
        }

        var _id$split = id.split('-'),
            _id$split2 = _slicedToArray(_id$split, 4),
            assetId = _id$split2[1],
            size = _id$split2[2],
            format = _id$split2[3];

        validators.hasDataset(this.client.clientConfig);
        var _this$client$clientCo = this.client.clientConfig,
            projectId = _this$client$clientCo.projectId,
            dataset = _this$client$clientCo.dataset;
        var qs = query ? queryString(query) : '';
        return "https://cdn.sanity.io/images/".concat(projectId, "/").concat(dataset, "/").concat(assetId, "-").concat(size, ".").concat(format).concat(qs);
      }
    });
    var assetsClient = AssetsClient;

    function UsersClient(client) {
      this.client = client;
    }

    objectAssign(UsersClient.prototype, {
      getById: function getById(id) {
        return this.client.request({
          uri: "/users/".concat(id)
        });
      }
    });
    var usersClient = UsersClient;

    function AuthClient(client) {
      this.client = client;
    }

    objectAssign(AuthClient.prototype, {
      getLoginProviders: function getLoginProviders() {
        return this.client.request({
          uri: '/auth/providers'
        });
      },
      logout: function logout() {
        return this.client.request({
          uri: '/auth/logout',
          method: 'POST'
        });
      }
    });
    var authClient = AuthClient;

    var nanoPubsub = function Pubsub() {
      var subscribers = [];
      return {
        subscribe: subscribe,
        publish: publish
      }
      function subscribe(subscriber) {
        subscribers.push(subscriber);
        return function unsubscribe() {
          var idx = subscribers.indexOf(subscriber);
          if (idx > -1) {
            subscribers.splice(idx, 1);
          }
        }
      }
      function publish() {
        for (var i = 0; i < subscribers.length; i++) {
          subscribers[i].apply(null, arguments);
        }
      }
    };

    var middlewareReducer = function (middleware) {
      var applyMiddleware = function applyMiddleware(hook, defaultValue) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        var bailEarly = hook === 'onError';

        var value = defaultValue;
        for (var i = 0; i < middleware[hook].length; i++) {
          var handler = middleware[hook][i];
          value = handler.apply(undefined, [value].concat(args));

          if (bailEarly && !value) {
            break;
          }
        }

        return value;
      };

      return applyMiddleware;
    };

    /**
     * Check if we're required to add a port number.
     *
     * @see https://url.spec.whatwg.org/#default-port
     * @param {Number|String} port Port number we need to check
     * @param {String} protocol Protocol we need to check against.
     * @returns {Boolean} Is it a default port for the given protocol
     * @api private
     */
    var requiresPort = function required(port, protocol) {
      protocol = protocol.split(':')[0];
      port = +port;

      if (!port) return false;

      switch (protocol) {
        case 'http':
        case 'ws':
        return port !== 80;

        case 'https':
        case 'wss':
        return port !== 443;

        case 'ftp':
        return port !== 21;

        case 'gopher':
        return port !== 70;

        case 'file':
        return false;
      }

      return port !== 0;
    };

    var has = Object.prototype.hasOwnProperty
      , undef;

    /**
     * Decode a URI encoded string.
     *
     * @param {String} input The URI encoded string.
     * @returns {String|Null} The decoded string.
     * @api private
     */
    function decode$1(input) {
      try {
        return decodeURIComponent(input.replace(/\+/g, ' '));
      } catch (e) {
        return null;
      }
    }

    /**
     * Attempts to encode a given input.
     *
     * @param {String} input The string that needs to be encoded.
     * @returns {String|Null} The encoded string.
     * @api private
     */
    function encode$1(input) {
      try {
        return encodeURIComponent(input);
      } catch (e) {
        return null;
      }
    }

    /**
     * Simple query string parser.
     *
     * @param {String} query The query string that needs to be parsed.
     * @returns {Object}
     * @api public
     */
    function querystring(query) {
      var parser = /([^=?#&]+)=?([^&]*)/g
        , result = {}
        , part;

      while (part = parser.exec(query)) {
        var key = decode$1(part[1])
          , value = decode$1(part[2]);

        //
        // Prevent overriding of existing properties. This ensures that build-in
        // methods like `toString` or __proto__ are not overriden by malicious
        // querystrings.
        //
        // In the case if failed decoding, we want to omit the key/value pairs
        // from the result.
        //
        if (key === null || value === null || key in result) continue;
        result[key] = value;
      }

      return result;
    }

    /**
     * Transform a query string to an object.
     *
     * @param {Object} obj Object that should be transformed.
     * @param {String} prefix Optional prefix.
     * @returns {String}
     * @api public
     */
    function querystringify(obj, prefix) {
      prefix = prefix || '';

      var pairs = []
        , value
        , key;

      //
      // Optionally prefix with a '?' if needed
      //
      if ('string' !== typeof prefix) prefix = '?';

      for (key in obj) {
        if (has.call(obj, key)) {
          value = obj[key];

          //
          // Edge cases where we actually want to encode the value to an empty
          // string instead of the stringified value.
          //
          if (!value && (value === null || value === undef || isNaN(value))) {
            value = '';
          }

          key = encode$1(key);
          value = encode$1(value);

          //
          // If we failed to encode the strings, we should bail out as we don't
          // want to add invalid strings to the query.
          //
          if (key === null || value === null) continue;
          pairs.push(key +'='+ value);
        }
      }

      return pairs.length ? prefix + pairs.join('&') : '';
    }

    //
    // Expose the module.
    //
    var stringify = querystringify;
    var parse = querystring;

    var querystringify_1 = {
    	stringify: stringify,
    	parse: parse
    };

    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
      , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
      , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
      , left = new RegExp('^'+ whitespace +'+');

    /**
     * Trim a given string.
     *
     * @param {String} str String to trim.
     * @public
     */
    function trimLeft(str) {
      return (str ? str : '').toString().replace(left, '');
    }

    /**
     * These are the parse rules for the URL parser, it informs the parser
     * about:
     *
     * 0. The char it Needs to parse, if it's a string it should be done using
     *    indexOf, RegExp using exec and NaN means set as current value.
     * 1. The property we should set when parsing this value.
     * 2. Indication if it's backwards or forward parsing, when set as number it's
     *    the value of extra chars that should be split off.
     * 3. Inherit from location if non existing in the parser.
     * 4. `toLowerCase` the resulting value.
     */
    var rules = [
      ['#', 'hash'],                        // Extract from the back.
      ['?', 'query'],                       // Extract from the back.
      function sanitize(address) {          // Sanitize what is left of the address
        return address.replace('\\', '/');
      },
      ['/', 'pathname'],                    // Extract from the back.
      ['@', 'auth', 1],                     // Extract from the front.
      [NaN, 'host', undefined, 1, 1],       // Set left over value.
      [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
      [NaN, 'hostname', undefined, 1, 1]    // Set left over.
    ];

    /**
     * These properties should not be copied or inherited from. This is only needed
     * for all non blob URL's as a blob URL does not include a hash, only the
     * origin.
     *
     * @type {Object}
     * @private
     */
    var ignore = { hash: 1, query: 1 };

    /**
     * The location object differs when your code is loaded through a normal page,
     * Worker or through a worker using a blob. And with the blobble begins the
     * trouble as the location object will contain the URL of the blob, not the
     * location of the page where our code is loaded in. The actual origin is
     * encoded in the `pathname` so we can thankfully generate a good "default"
     * location from it so we can generate proper relative URL's again.
     *
     * @param {Object|String} loc Optional default location object.
     * @returns {Object} lolcation object.
     * @public
     */
    function lolcation(loc) {
      var globalVar;

      if (typeof window !== 'undefined') globalVar = window;
      else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;
      else if (typeof self !== 'undefined') globalVar = self;
      else globalVar = {};

      var location = globalVar.location || {};
      loc = loc || location;

      var finaldestination = {}
        , type = typeof loc
        , key;

      if ('blob:' === loc.protocol) {
        finaldestination = new Url(unescape(loc.pathname), {});
      } else if ('string' === type) {
        finaldestination = new Url(loc, {});
        for (key in ignore) delete finaldestination[key];
      } else if ('object' === type) {
        for (key in loc) {
          if (key in ignore) continue;
          finaldestination[key] = loc[key];
        }

        if (finaldestination.slashes === undefined) {
          finaldestination.slashes = slashes.test(loc.href);
        }
      }

      return finaldestination;
    }

    /**
     * @typedef ProtocolExtract
     * @type Object
     * @property {String} protocol Protocol matched in the URL, in lowercase.
     * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
     * @property {String} rest Rest of the URL that is not part of the protocol.
     */

    /**
     * Extract protocol information from a URL with/without double slash ("//").
     *
     * @param {String} address URL we want to extract from.
     * @return {ProtocolExtract} Extracted information.
     * @private
     */
    function extractProtocol(address) {
      address = trimLeft(address);
      var match = protocolre.exec(address);

      return {
        protocol: match[1] ? match[1].toLowerCase() : '',
        slashes: !!match[2],
        rest: match[3]
      };
    }

    /**
     * Resolve a relative URL pathname against a base URL pathname.
     *
     * @param {String} relative Pathname of the relative URL.
     * @param {String} base Pathname of the base URL.
     * @return {String} Resolved pathname.
     * @private
     */
    function resolve(relative, base) {
      if (relative === '') return base;

      var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
        , i = path.length
        , last = path[i - 1]
        , unshift = false
        , up = 0;

      while (i--) {
        if (path[i] === '.') {
          path.splice(i, 1);
        } else if (path[i] === '..') {
          path.splice(i, 1);
          up++;
        } else if (up) {
          if (i === 0) unshift = true;
          path.splice(i, 1);
          up--;
        }
      }

      if (unshift) path.unshift('');
      if (last === '.' || last === '..') path.push('');

      return path.join('/');
    }

    /**
     * The actual URL instance. Instead of returning an object we've opted-in to
     * create an actual constructor as it's much more memory efficient and
     * faster and it pleases my OCD.
     *
     * It is worth noting that we should not use `URL` as class name to prevent
     * clashes with the global URL instance that got introduced in browsers.
     *
     * @constructor
     * @param {String} address URL we want to parse.
     * @param {Object|String} [location] Location defaults for relative paths.
     * @param {Boolean|Function} [parser] Parser for the query string.
     * @private
     */
    function Url(address, location, parser) {
      address = trimLeft(address);

      if (!(this instanceof Url)) {
        return new Url(address, location, parser);
      }

      var relative, extracted, parse, instruction, index, key
        , instructions = rules.slice()
        , type = typeof location
        , url = this
        , i = 0;

      //
      // The following if statements allows this module two have compatibility with
      // 2 different API:
      //
      // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
      //    where the boolean indicates that the query string should also be parsed.
      //
      // 2. The `URL` interface of the browser which accepts a URL, object as
      //    arguments. The supplied object will be used as default values / fall-back
      //    for relative paths.
      //
      if ('object' !== type && 'string' !== type) {
        parser = location;
        location = null;
      }

      if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;

      location = lolcation(location);

      //
      // Extract protocol information before running the instructions.
      //
      extracted = extractProtocol(address || '');
      relative = !extracted.protocol && !extracted.slashes;
      url.slashes = extracted.slashes || relative && location.slashes;
      url.protocol = extracted.protocol || location.protocol || '';
      address = extracted.rest;

      //
      // When the authority component is absent the URL starts with a path
      // component.
      //
      if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

      for (; i < instructions.length; i++) {
        instruction = instructions[i];

        if (typeof instruction === 'function') {
          address = instruction(address);
          continue;
        }

        parse = instruction[0];
        key = instruction[1];

        if (parse !== parse) {
          url[key] = address;
        } else if ('string' === typeof parse) {
          if (~(index = address.indexOf(parse))) {
            if ('number' === typeof instruction[2]) {
              url[key] = address.slice(0, index);
              address = address.slice(index + instruction[2]);
            } else {
              url[key] = address.slice(index);
              address = address.slice(0, index);
            }
          }
        } else if ((index = parse.exec(address))) {
          url[key] = index[1];
          address = address.slice(0, index.index);
        }

        url[key] = url[key] || (
          relative && instruction[3] ? location[key] || '' : ''
        );

        //
        // Hostname, host and protocol should be lowercased so they can be used to
        // create a proper `origin`.
        //
        if (instruction[4]) url[key] = url[key].toLowerCase();
      }

      //
      // Also parse the supplied query string in to an object. If we're supplied
      // with a custom parser as function use that instead of the default build-in
      // parser.
      //
      if (parser) url.query = parser(url.query);

      //
      // If the URL is relative, resolve the pathname against the base URL.
      //
      if (
          relative
        && location.slashes
        && url.pathname.charAt(0) !== '/'
        && (url.pathname !== '' || location.pathname !== '')
      ) {
        url.pathname = resolve(url.pathname, location.pathname);
      }

      //
      // We should not add port numbers if they are already the default port number
      // for a given protocol. As the host also contains the port number we're going
      // override it with the hostname which contains no port number.
      //
      if (!requiresPort(url.port, url.protocol)) {
        url.host = url.hostname;
        url.port = '';
      }

      //
      // Parse down the `auth` for the username and password.
      //
      url.username = url.password = '';
      if (url.auth) {
        instruction = url.auth.split(':');
        url.username = instruction[0] || '';
        url.password = instruction[1] || '';
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      //
      // The href is just the compiled result.
      //
      url.href = url.toString();
    }

    /**
     * This is convenience method for changing properties in the URL instance to
     * insure that they all propagate correctly.
     *
     * @param {String} part          Property we need to adjust.
     * @param {Mixed} value          The newly assigned value.
     * @param {Boolean|Function} fn  When setting the query, it will be the function
     *                               used to parse the query.
     *                               When setting the protocol, double slash will be
     *                               removed from the final url if it is true.
     * @returns {URL} URL instance for chaining.
     * @public
     */
    function set(part, value, fn) {
      var url = this;

      switch (part) {
        case 'query':
          if ('string' === typeof value && value.length) {
            value = (fn || querystringify_1.parse)(value);
          }

          url[part] = value;
          break;

        case 'port':
          url[part] = value;

          if (!requiresPort(value, url.protocol)) {
            url.host = url.hostname;
            url[part] = '';
          } else if (value) {
            url.host = url.hostname +':'+ value;
          }

          break;

        case 'hostname':
          url[part] = value;

          if (url.port) value += ':'+ url.port;
          url.host = value;
          break;

        case 'host':
          url[part] = value;

          if (/:\d+$/.test(value)) {
            value = value.split(':');
            url.port = value.pop();
            url.hostname = value.join(':');
          } else {
            url.hostname = value;
            url.port = '';
          }

          break;

        case 'protocol':
          url.protocol = value.toLowerCase();
          url.slashes = !fn;
          break;

        case 'pathname':
        case 'hash':
          if (value) {
            var char = part === 'pathname' ? '/' : '#';
            url[part] = value.charAt(0) !== char ? char + value : value;
          } else {
            url[part] = value;
          }
          break;

        default:
          url[part] = value;
      }

      for (var i = 0; i < rules.length; i++) {
        var ins = rules[i];

        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
      }

      url.origin = url.protocol && url.host && url.protocol !== 'file:'
        ? url.protocol +'//'+ url.host
        : 'null';

      url.href = url.toString();

      return url;
    }

    /**
     * Transform the properties back in to a valid and full URL string.
     *
     * @param {Function} stringify Optional query stringify function.
     * @returns {String} Compiled version of the URL.
     * @public
     */
    function toString$1(stringify) {
      if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;

      var query
        , url = this
        , protocol = url.protocol;

      if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

      var result = protocol + (url.slashes ? '//' : '');

      if (url.username) {
        result += url.username;
        if (url.password) result += ':'+ url.password;
        result += '@';
      }

      result += url.host + url.pathname;

      query = 'object' === typeof url.query ? stringify(url.query) : url.query;
      if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

      if (url.hash) result += url.hash;

      return result;
    }

    Url.prototype = { set: set, toString: toString$1 };

    //
    // Expose the URL parser and some additional properties that might be useful for
    // others or testing.
    //
    Url.extractProtocol = extractProtocol;
    Url.location = lolcation;
    Url.trimLeft = trimLeft;
    Url.qs = querystringify_1;

    var urlParse = Url;

    var isReactNative = typeof navigator === 'undefined' ? false : navigator.product === 'ReactNative';

    var has$1 = Object.prototype.hasOwnProperty;
    var defaultOptions$1 = { timeout: isReactNative ? 60000 : 120000 };

    var defaultOptionsProcessor = function (opts) {
      var options = typeof opts === 'string' ? objectAssign({ url: opts }, defaultOptions$1) : objectAssign({}, defaultOptions$1, opts);

      // Parse URL into parts
      var url = urlParse(options.url, {}, // Don't use current browser location
      true // Parse query strings
      );

      // Normalize timeouts
      options.timeout = normalizeTimeout(options.timeout);

      // Shallow-merge (override) existing query params
      if (options.query) {
        url.query = objectAssign({}, url.query, removeUndefined(options.query));
      }

      // Implicit POST if we have not specified a method but have a body
      options.method = options.body && !options.method ? 'POST' : (options.method || 'GET').toUpperCase();

      // Stringify URL
      options.url = url.toString(stringifyQueryString);

      return options;
    };

    function stringifyQueryString(obj) {
      var pairs = [];
      for (var key in obj) {
        if (has$1.call(obj, key)) {
          push(key, obj[key]);
        }
      }

      return pairs.length ? pairs.join('&') : '';

      function push(key, val) {
        if (Array.isArray(val)) {
          val.forEach(function (item) {
            return push(key, item);
          });
        } else {
          pairs.push([key, val].map(encodeURIComponent).join('='));
        }
      }
    }

    function normalizeTimeout(time) {
      if (time === false || time === 0) {
        return false;
      }

      if (time.connect || time.socket) {
        return time;
      }

      var delay = Number(time);
      if (isNaN(delay)) {
        return normalizeTimeout(defaultOptions$1.timeout);
      }

      return { connect: delay, socket: delay };
    }

    function removeUndefined(obj) {
      var target = {};
      for (var key in obj) {
        if (obj[key] !== undefined) {
          target[key] = obj[key];
        }
      }
      return target;
    }

    var validUrl = /^https?:\/\//i;

    var defaultOptionsValidator = function (options) {
      if (!validUrl.test(options.url)) {
        throw new Error("\"" + options.url + "\" is not a valid URL");
      }
    };

    /*! https://mths.be/punycode v1.4.1 by @mathias */


    /** Highest positive signed 32-bit float value */
    var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

    /** Bootstring parameters */
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128; // 0x80
    var delimiter = '-'; // '\x2D'
    var regexNonASCII = /[^\x20-\x7E]/; // unprintable ASCII chars + non-ASCII chars
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

    /** Error messages */
    var errors = {
      'overflow': 'Overflow: input needs wider integers to process',
      'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
      'invalid-input': 'Invalid input'
    };

    /** Convenience shortcuts */
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;

    /*--------------------------------------------------------------------------*/

    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    function error(type) {
      throw new RangeError(errors[type]);
    }

    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    function map$4(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }

    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    function mapDomain(string, fn) {
      var parts = string.split('@');
      var result = '';
      if (parts.length > 1) {
        // In email addresses, only the domain name should be punycoded. Leave
        // the local part (i.e. everything up to `@`) intact.
        result = parts[0] + '@';
        string = parts[1];
      }
      // Avoid `split(regex)` for IE8 compatibility. See #17.
      string = string.replace(regexSeparators, '\x2E');
      var labels = string.split('.');
      var encoded = map$4(labels, fn).join('.');
      return result + encoded;
    }

    /**
     * Creates an array containing the numeric code points of each Unicode
     * character in the string. While JavaScript uses UCS-2 internally,
     * this function will convert a pair of surrogate halves (each of which
     * UCS-2 exposes as separate characters) into a single code point,
     * matching UTF-16.
     * @see `punycode.ucs2.encode`
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode.ucs2
     * @name decode
     * @param {String} string The Unicode input string (UCS-2).
     * @returns {Array} The new array of code points.
     */
    function ucs2decode(string) {
      var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xFC00) == 0xDC00) { // low surrogate
            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }

    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    function digitToBasic(digit, flag) {
      //  0..25 map to ASCII a..z or A..Z
      // 26..35 map to ASCII 0..9
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }

    /**
     * Bias adaptation function as per section 3.4 of RFC 3492.
     * https://tools.ietf.org/html/rfc3492#section-3.4
     * @private
     */
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for ( /* no initialization */ ; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }

    /**
     * Converts a string of Unicode symbols (e.g. a domain name label) to a
     * Punycode string of ASCII-only symbols.
     * @memberOf punycode
     * @param {String} input The string of Unicode symbols.
     * @returns {String} The resulting Punycode string of ASCII-only symbols.
     */
    function encode$2(input) {
      var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength,
        /** Cached calculation results */
        handledCPCountPlusOne,
        baseMinusT,
        qMinusT;

      // Convert the input in UCS-2 to Unicode
      input = ucs2decode(input);

      // Cache the length
      inputLength = input.length;

      // Initialize the state
      n = initialN;
      delta = 0;
      bias = initialBias;

      // Handle the basic code points
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 0x80) {
          output.push(stringFromCharCode(currentValue));
        }
      }

      handledCPCount = basicLength = output.length;

      // `handledCPCount` is the number of code points that have been handled;
      // `basicLength` is the number of basic code points.

      // Finish the basic string - if it is not empty - with a delimiter
      if (basicLength) {
        output.push(delimiter);
      }

      // Main encoding loop:
      while (handledCPCount < inputLength) {

        // All non-basic code points < n have been handled already. Find the next
        // larger one:
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }

        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        // but guard against overflow
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error('overflow');
        }

        delta += (m - n) * handledCPCountPlusOne;
        n = m;

        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];

          if (currentValue < n && ++delta > maxInt) {
            error('overflow');
          }

          if (currentValue == n) {
            // Represent delta as a generalized variable-length integer
            for (q = delta, k = base; /* no condition */ ; k += base) {
              t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
              );
              q = floor(qMinusT / baseMinusT);
            }

            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }

        ++delta;
        ++n;

      }
      return output.join('');
    }

    /**
     * Converts a Unicode string representing a domain name or an email address to
     * Punycode. Only the non-ASCII parts of the domain name will be converted,
     * i.e. it doesn't matter if you call it with a domain that's already in
     * ASCII.
     * @memberOf punycode
     * @param {String} input The domain name or email address to convert, as a
     * Unicode string.
     * @returns {String} The Punycode representation of the given domain name or
     * email address.
     */
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ?
          'xn--' + encode$2(string) :
          string;
      });
    }

    // Copyright Joyent, Inc. and other Node contributors.

    function isNull(arg) {
      return arg === null;
    }

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    function isString(arg) {
      return typeof arg === 'string';
    }

    function isObject$1(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.


    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707
    function hasOwnProperty$6(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var isArray$2 = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
    function stringifyPrimitive(v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    }

    function stringify$1 (obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return map$5(objectKeys(obj), function(k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray$2(obj[k])) {
            return map$5(obj[k], function(v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);

      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq +
             encodeURIComponent(stringifyPrimitive(obj));
    }
    function map$5 (xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }

    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };

    function parse$1(qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr, vstr, k, v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty$6(obj, k)) {
          obj[k] = v;
        } else if (isArray$2(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    }

    // Copyright Joyent, Inc. and other Node contributors.
    var url = {
      parse: urlParse$1,
      resolve: urlResolve,
      resolveObject: urlResolveObject,
      format: urlFormat,
      Url: Url$1
    };
    function Url$1() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
      portPattern = /:[0-9]*$/,

      // Special case for a simple path URL
      simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

      // RFC 2396: characters reserved for delimiting URLs.
      // We actually just auto-escape these.
      delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

      // RFC 2396: characters not allowed for various reasons.
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

      // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
      autoEscape = ['\''].concat(unwise),
      // Characters that are never ever allowed in a hostname.
      // Note that any invalid chars are also handled, but these
      // are the ones that are *expected* to be seen, so we fast-path
      // them.
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
      hostEndingChars = ['/', '?', '#'],
      hostnameMaxLen = 255,
      hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
      hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      // protocols that can allow "unsafe" and "unwise" chars.
      unsafeProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that never have a hostname.
      hostlessProtocol = {
        'javascript': true,
        'javascript:': true
      },
      // protocols that always contain a // bit.
      slashedProtocol = {
        'http': true,
        'https': true,
        'ftp': true,
        'gopher': true,
        'file': true,
        'http:': true,
        'https:': true,
        'ftp:': true,
        'gopher:': true,
        'file:': true
      };

    function urlParse$1(url, parseQueryString, slashesDenoteHost) {
      if (url && isObject$1(url) && url instanceof Url$1) return url;

      var u = new Url$1;
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }
    Url$1.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
      return parse$2(this, url, parseQueryString, slashesDenoteHost);
    };

    function parse$2(self, url, parseQueryString, slashesDenoteHost) {
      if (!isString(url)) {
        throw new TypeError('Parameter \'url\' must be a string, not ' + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
        splitter =
        (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
        uSplit = url.split(splitter),
        slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          self.path = rest;
          self.href = rest;
          self.pathname = simplePath[1];
          if (simplePath[2]) {
            self.search = simplePath[2];
            if (parseQueryString) {
              self.query = parse$1(self.search.substr(1));
            } else {
              self.query = self.search.substr(1);
            }
          } else if (parseQueryString) {
            self.search = '';
            self.query = {};
          }
          return self;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        self.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          self.slashes = true;
        }
      }
      var i, hec, l, p;
      if (!hostlessProtocol[proto] &&
        (slashes || (proto && !slashedProtocol[proto]))) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          self.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
            hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1)
          hostEnd = rest.length;

        self.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        parseHost(self);

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        self.hostname = self.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = self.hostname[0] === '[' &&
          self.hostname[self.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = self.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                self.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (self.hostname.length > hostnameMaxLen) {
          self.hostname = '';
        } else {
          // hostnames are always lower case.
          self.hostname = self.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          self.hostname = toASCII(self.hostname);
        }

        p = self.port ? ':' + self.port : '';
        var h = self.hostname || '';
        self.host = h + p;
        self.href += self.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          self.hostname = self.hostname.substr(1, self.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1)
            continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }


      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        self.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        self.search = rest.substr(qm);
        self.query = rest.substr(qm + 1);
        if (parseQueryString) {
          self.query = parse$1(self.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        self.search = '';
        self.query = {};
      }
      if (rest) self.pathname = rest;
      if (slashedProtocol[lowerProto] &&
        self.hostname && !self.pathname) {
        self.pathname = '/';
      }

      //to support http.request
      if (self.pathname || self.search) {
        p = self.pathname || '';
        var s = self.search || '';
        self.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      self.href = format(self);
      return self;
    }

    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (isString(obj)) obj = parse$2({}, obj);
      return format(obj);
    }

    function format(self) {
      var auth = self.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = self.protocol || '',
        pathname = self.pathname || '',
        hash = self.hash || '',
        host = false,
        query = '';

      if (self.host) {
        host = auth + self.host;
      } else if (self.hostname) {
        host = auth + (self.hostname.indexOf(':') === -1 ?
          self.hostname :
          '[' + this.hostname + ']');
        if (self.port) {
          host += ':' + self.port;
        }
      }

      if (self.query &&
        isObject$1(self.query) &&
        Object.keys(self.query).length) {
        query = stringify$1(self.query);
      }

      var search = self.search || (query && ('?' + query)) || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (self.slashes ||
        (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function(match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    }

    Url$1.prototype.format = function() {
      return format(this);
    };

    function urlResolve(source, relative) {
      return urlParse$1(source, false, true).resolve(relative);
    }

    Url$1.prototype.resolve = function(relative) {
      return this.resolveObject(urlParse$1(relative, false, true)).format();
    };

    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse$1(source, false, true).resolveObject(relative);
    }

    Url$1.prototype.resolveObject = function(relative) {
      if (isString(relative)) {
        var rel = new Url$1();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url$1();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol')
            result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] &&
          result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }
      var relPath;
      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
        isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
        ),
        mustEndAbs = (isRelAbs || isSourceAbs ||
          (result.host && relative.pathname)),
        removeAllDots = mustEndAbs,
        srcPath = result.pathname && result.pathname.split('/') || [],
        psychotic = result.protocol && !slashedProtocol[result.protocol];
      relPath = relative.pathname && relative.pathname.split('/') || [];
      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;
          else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;
            else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }
      var authInHost;
      if (isRelAbs) {
        // it's absolute.
        result.host = (relative.host || relative.host === '') ?
          relative.host : result.host;
        result.hostname = (relative.hostname || relative.hostname === '') ?
          relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          authInHost = result.host && result.host.indexOf('@') > 0 ?
            result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!isNull(result.pathname) || !isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') +
            (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (
        (result.host || relative.host || srcPath.length > 1) &&
        (last === '.' || last === '..') || last === '');

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' &&
        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' ||
        (srcPath[0] && srcPath[0].charAt(0) === '/');

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' :
          srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        authInHost = result.host && result.host.indexOf('@') > 0 ?
          result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || (result.host && srcPath.length);

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!isNull(result.pathname) || !isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') +
          (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url$1.prototype.parseHost = function() {
      return parseHost(this);
    };

    function parseHost(self) {
      var host = self.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          self.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) self.hostname = host;
    }

    var url$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        parse: urlParse$1,
        resolve: urlResolve,
        resolveObject: urlResolveObject,
        format: urlFormat,
        'default': url,
        Url: Url$1
    });

    var url$2 = /*@__PURE__*/getAugmentedNamespace(url$1);

    var sameOrigin = function(uri1, uri2, ieMode) {
        if (uri1 === uri2) {
            return true;
        }

        var url1 = url$2.parse(uri1, false, true);
        var url2 = url$2.parse(uri2, false, true);

        var url1Port = url1.port|0 || (url1.protocol === 'https' ? 443 : 80);
        var url2Port = url2.port|0 || (url2.protocol === 'https' ? 443 : 80);

        var match = {
            proto: url1.protocol === url2.protocol,
            hostname: url1.hostname === url2.hostname,
            port: url1Port === url2Port
        };

        return ((match.proto && match.hostname) && (match.port || ieMode));
    };

    var trim = function(string) {
      return string.replace(/^\s+|\s+$/g, '');
    }
      , isArray$3 = function(arg) {
          return Object.prototype.toString.call(arg) === '[object Array]';
        };

    var parseHeaders = function (headers) {
      if (!headers)
        return {}

      var result = {};

      var headersArr = trim(headers).split('\n');

      for (var i = 0; i < headersArr.length; i++) {
        var row = headersArr[i];
        var index = row.indexOf(':')
        , key = trim(row.slice(0, index)).toLowerCase()
        , value = trim(row.slice(index + 1));

        if (typeof(result[key]) === 'undefined') {
          result[key] = value;
        } else if (isArray$3(result[key])) {
          result[key].push(value);
        } else {
          result[key] = [ result[key], value ];
        }
      }

      return result
    };

    /* eslint max-depth: ["error", 4] */


    var noop$1 = function noop() {
      /* intentional noop */
    };

    var win = window;
    var XmlHttpRequest = win.XMLHttpRequest || noop$1;
    var hasXhr2 = 'withCredentials' in new XmlHttpRequest();
    var XDomainRequest$1 = hasXhr2 ? XmlHttpRequest : win.XDomainRequest;
    var adapter = 'xhr';

    var browserRequest = function (context, callback) {
      var opts = context.options;
      var options = context.applyMiddleware('finalizeOptions', opts);
      var timers = {};

      // Deep-checking window.location because of react native, where `location` doesn't exist
      var cors = win && win.location && !sameOrigin(win.location.href, options.url);

      // Allow middleware to inject a response, for instance in the case of caching or mocking
      var injectedResponse = context.applyMiddleware('interceptRequest', undefined, {
        adapter: adapter,
        context: context
      });

      // If middleware injected a response, treat it as we normally would and return it
      // Do note that the injected response has to be reduced to a cross-environment friendly response
      if (injectedResponse) {
        var cbTimer = setTimeout(callback, 0, null, injectedResponse);
        var cancel = function cancel() {
          return clearTimeout(cbTimer);
        };
        return { abort: cancel };
      }

      // We'll want to null out the request on success/failure
      var xhr = cors ? new XDomainRequest$1() : new XmlHttpRequest();

      var isXdr = win.XDomainRequest && xhr instanceof win.XDomainRequest;
      var headers = options.headers;

      // Request state
      var aborted = false;
      var loaded = false;
      var timedOut = false;

      // Apply event handlers
      xhr.onerror = onError;
      xhr.ontimeout = onError;
      xhr.onabort = function () {
        aborted = true;
      };

      // IE9 must have onprogress be set to a unique function
      xhr.onprogress = function () {
        /* intentional noop */
      };

      var loadEvent = isXdr ? 'onload' : 'onreadystatechange';
      xhr[loadEvent] = function () {
        // Prevent request from timing out
        resetTimers();

        if (aborted || xhr.readyState !== 4 && !isXdr) {
          return;
        }

        // Will be handled by onError
        if (xhr.status === 0) {
          return;
        }

        onLoad();
      };

      // @todo two last options to open() is username/password
      xhr.open(options.method, options.url, true // Always async
      );

      // Some options need to be applied after open
      xhr.withCredentials = !!options.withCredentials;

      // Set headers
      if (headers && xhr.setRequestHeader) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            xhr.setRequestHeader(key, headers[key]);
          }
        }
      } else if (headers && isXdr) {
        throw new Error('Headers cannot be set on an XDomainRequest object');
      }

      if (options.rawBody) {
        xhr.responseType = 'arraybuffer';
      }

      // Let middleware know we're about to do a request
      context.applyMiddleware('onRequest', { options: options, adapter: adapter, request: xhr, context: context });

      xhr.send(options.body || null);

      // Figure out which timeouts to use (if any)
      var delays = options.timeout;
      if (delays) {
        timers.connect = setTimeout(function () {
          return timeoutRequest('ETIMEDOUT');
        }, delays.connect);
      }

      return { abort: abort };

      function abort() {
        aborted = true;

        if (xhr) {
          xhr.abort();
        }
      }

      function timeoutRequest(code) {
        timedOut = true;
        xhr.abort();
        var error = new Error(code === 'ESOCKETTIMEDOUT' ? 'Socket timed out on request to ' + options.url : 'Connection timed out on request to ' + options.url);
        error.code = code;
        context.channels.error.publish(error);
      }

      function resetTimers() {
        if (!delays) {
          return;
        }

        stopTimers();
        timers.socket = setTimeout(function () {
          return timeoutRequest('ESOCKETTIMEDOUT');
        }, delays.socket);
      }

      function stopTimers() {
        // Only clear the connect timeout if we've got a connection
        if (aborted || xhr.readyState >= 2 && timers.connect) {
          clearTimeout(timers.connect);
        }

        if (timers.socket) {
          clearTimeout(timers.socket);
        }
      }

      function onError() {
        if (loaded) {
          return;
        }

        // Clean up
        stopTimers();
        loaded = true;
        xhr = null;

        // Annoyingly, details are extremely scarce and hidden from us.
        // We only really know that it is a network error
        var err = new Error('Network error while attempting to reach ' + options.url);
        err.isNetworkError = true;
        err.request = options;
        callback(err);
      }

      function reduceResponse() {
        var statusCode = xhr.status;
        var statusMessage = xhr.statusText;

        if (isXdr && statusCode === undefined) {
          // IE8 CORS GET successful response doesn't have a status field, but body is fine
          statusCode = 200;
        } else if (statusCode > 12000 && statusCode < 12156) {
          // Yet another IE quirk where it emits weird status codes on network errors
          // https://support.microsoft.com/en-us/kb/193625
          return onError();
        } else {
          // Another IE bug where HTTP 204 somehow ends up as 1223
          statusCode = xhr.status === 1223 ? 204 : xhr.status;
          statusMessage = xhr.status === 1223 ? 'No Content' : statusMessage;
        }

        return {
          body: xhr.response || xhr.responseText,
          url: options.url,
          method: options.method,
          headers: isXdr ? {} : parseHeaders(xhr.getAllResponseHeaders()),
          statusCode: statusCode,
          statusMessage: statusMessage
        };
      }

      function onLoad() {
        if (aborted || loaded || timedOut) {
          return;
        }

        if (xhr.status === 0) {
          onError();
          return;
        }

        // Prevent being called twice
        stopTimers();
        loaded = true;
        callback(null, reduceResponse());
      }
    };

    var request = browserRequest;

    // node-request in node, browser-request in browsers

    var channelNames = ['request', 'response', 'progress', 'error', 'abort'];
    var middlehooks = ['processOptions', 'validateOptions', 'interceptRequest', 'finalizeOptions', 'onRequest', 'onResponse', 'onError', 'onReturn', 'onHeaders'];

    var lib$5 = function createRequester() {
      var initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      var loadedMiddleware = [];
      var middleware = middlehooks.reduce(function (ware, name) {
        ware[name] = ware[name] || [];
        return ware;
      }, {
        processOptions: [defaultOptionsProcessor],
        validateOptions: [defaultOptionsValidator]
      });

      function request$1(opts) {
        var channels = channelNames.reduce(function (target, name) {
          target[name] = nanoPubsub();
          return target;
        }, {});

        // Prepare a middleware reducer that can be reused throughout the lifecycle
        var applyMiddleware = middlewareReducer(middleware);

        // Parse the passed options
        var options = applyMiddleware('processOptions', opts);

        // Validate the options
        applyMiddleware('validateOptions', options);

        // Build a context object we can pass to child handlers
        var context = { options: options, channels: channels, applyMiddleware: applyMiddleware

          // We need to hold a reference to the current, ongoing request,
          // in order to allow cancellation. In the case of the retry middleware,
          // a new request might be triggered
        };var ongoingRequest = null;
        var unsubscribe = channels.request.subscribe(function (ctx) {
          // Let request adapters (node/browser) perform the actual request
          ongoingRequest = request(ctx, function (err, res) {
            return onResponse(err, res, ctx);
          });
        });

        // If we abort the request, prevent further requests from happening,
        // and be sure to cancel any ongoing request (obviously)
        channels.abort.subscribe(function () {
          unsubscribe();
          if (ongoingRequest) {
            ongoingRequest.abort();
          }
        });

        // See if any middleware wants to modify the return value - for instance
        // the promise or observable middlewares
        var returnValue = applyMiddleware('onReturn', channels, context);

        // If return value has been modified by a middleware, we expect the middleware
        // to publish on the 'request' channel. If it hasn't been modified, we want to
        // trigger it right away
        if (returnValue === channels) {
          channels.request.publish(context);
        }

        return returnValue;

        function onResponse(reqErr, res, ctx) {
          var error = reqErr;
          var response = res;

          // We're processing non-errors first, in case a middleware converts the
          // response into an error (for instance, status >= 400 == HttpError)
          if (!error) {
            try {
              response = applyMiddleware('onResponse', res, ctx);
            } catch (err) {
              response = null;
              error = err;
            }
          }

          // Apply error middleware - if middleware return the same (or a different) error,
          // publish as an error event. If we *don't* return an error, assume it has been handled
          error = error && applyMiddleware('onError', error, ctx);

          // Figure out if we should publish on error/response channels
          if (error) {
            channels.error.publish(error);
          } else if (response) {
            channels.response.publish(response);
          }
        }
      }

      request$1.use = function use(newMiddleware) {
        if (!newMiddleware) {
          throw new Error('Tried to add middleware that resolved to falsey value');
        }

        if (typeof newMiddleware === 'function') {
          throw new Error('Tried to add middleware that was a function. It probably expects you to pass options to it.');
        }

        if (newMiddleware.onReturn && middleware.onReturn.length > 0) {
          throw new Error('Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event');
        }

        middlehooks.forEach(function (key) {
          if (newMiddleware[key]) {
            middleware[key].push(newMiddleware[key]);
          }
        });

        loadedMiddleware.push(newMiddleware);
        return request$1;
      };

      request$1.clone = function clone() {
        return createRequester(loadedMiddleware);
      };

      initMiddleware.forEach(request$1.use);

      return request$1;
    };

    var getIt = lib$5;

    var global_1 = createCommonjsModule(function (module) {

    /* eslint-disable no-negated-condition */
    if (typeof window !== 'undefined') {
      module.exports = window;
    } else if (typeof commonjsGlobal !== 'undefined') {
      module.exports = commonjsGlobal;
    } else if (typeof self !== 'undefined') {
      module.exports = self;
    } else {
      module.exports = {};
    }

    });

    var observable$1 = function () {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var Observable = opts.implementation || global_1.Observable;
      if (!Observable) {
        throw new Error('`Observable` is not available in global scope, and no implementation was passed');
      }

      return {
        onReturn: function onReturn(channels, context) {
          return new Observable(function (observer) {
            channels.error.subscribe(function (err) {
              return observer.error(err);
            });
            channels.progress.subscribe(function (event) {
              return observer.next(objectAssign({ type: 'progress' }, event));
            });
            channels.response.subscribe(function (response) {
              observer.next(objectAssign({ type: 'response' }, response));
              observer.complete();
            });

            channels.request.publish(context);
            return function () {
              return channels.abort.publish();
            };
          });
        }
      };
    };

    /*!
     * isobject <https://github.com/jonschlinkert/isobject>
     *
     * Copyright (c) 2014-2017, Jon Schlinkert.
     * Released under the MIT License.
     */

    var isobject = function isObject(val) {
      return val != null && typeof val === 'object' && Array.isArray(val) === false;
    };

    function isObjectObject(o) {
      return isobject(o) === true
        && Object.prototype.toString.call(o) === '[object Object]';
    }

    var isPlainObject = function isPlainObject(o) {
      var ctor,prot;

      if (isObjectObject(o) === false) return false;

      // If has modified constructor
      ctor = o.constructor;
      if (typeof ctor !== 'function') return false;

      // If has modified prototype
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;

      // If constructor does not have an Object-specific method
      if (prot.hasOwnProperty('isPrototypeOf') === false) {
        return false;
      }

      // Most likely a plain Object
      return true;
    };

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




    var serializeTypes = ['boolean', 'string', 'number'];
    var isBuffer = function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
    };

    var jsonRequest = function () {
      return {
        processOptions: function processOptions(options) {
          var body = options.body;
          if (!body) {
            return options;
          }

          var isStream = typeof body.pipe === 'function';
          var shouldSerialize = !isStream && !isBuffer(body) && (serializeTypes.indexOf(typeof body === 'undefined' ? 'undefined' : _typeof(body)) !== -1 || Array.isArray(body) || isPlainObject(body));

          if (!shouldSerialize) {
            return options;
          }

          return objectAssign({}, options, {
            body: JSON.stringify(options.body),
            headers: objectAssign({}, options.headers, {
              'Content-Type': 'application/json'
            })
          });
        }
      };
    };

    var jsonResponse = function (opts) {
      return {
        onResponse: function onResponse(response) {
          var contentType = response.headers['content-type'] || '';
          var shouldDecode = opts && opts.force || contentType.indexOf('application/json') !== -1;
          if (!response.body || !contentType || !shouldDecode) {
            return response;
          }

          return objectAssign({}, response, { body: tryParse(response.body) });
        },

        processOptions: function processOptions(options) {
          return objectAssign({}, options, {
            headers: objectAssign({ Accept: 'application/json' }, options.headers)
          });
        }
      };
    };

    function tryParse(body) {
      try {
        return JSON.parse(body);
      } catch (err) {
        err.message = 'Failed to parsed response body as JSON: ' + err.message;
        throw err;
      }
    }

    var browserProgress = function () {
      return {
        onRequest: function onRequest(evt) {
          if (evt.adapter !== 'xhr') {
            return;
          }

          var xhr = evt.request;
          var context = evt.context;

          if ('upload' in xhr && 'onprogress' in xhr.upload) {
            xhr.upload.onprogress = handleProgress('upload');
          }

          if ('onprogress' in xhr) {
            xhr.onprogress = handleProgress('download');
          }

          function handleProgress(stage) {
            return function (event) {
              var percent = event.lengthComputable ? event.loaded / event.total * 100 : -1;
              context.channels.progress.publish({
                stage: stage,
                percent: percent,
                total: event.total,
                loaded: event.loaded,
                lengthComputable: event.lengthComputable
              });
            };
          }
        }
      };
    };

    var progress = browserProgress;

    var makeError_1 = createCommonjsModule(function (module, exports) {

    // ===================================================================

    var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
    var defineProperty = Object.defineProperty;

    // -------------------------------------------------------------------

    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === undefined) {
      captureStackTrace = function captureStackTrace(error) {
        var container = new Error();

        defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;

            // Replace property with value for faster future accesses.
            defineProperty(this, "stack", {
              configurable: true,
              value: stack,
              writable: true,
            });

            return stack;
          },
          set: function setStack(stack) {
            defineProperty(error, "stack", {
              configurable: true,
              value: stack,
              writable: true,
            });
          },
        });
      };
    }

    // -------------------------------------------------------------------

    function BaseError(message) {
      if (message !== undefined) {
        defineProperty(this, "message", {
          configurable: true,
          value: message,
          writable: true,
        });
      }

      var cname = this.constructor.name;
      if (cname !== undefined && cname !== this.name) {
        defineProperty(this, "name", {
          configurable: true,
          value: cname,
          writable: true,
        });
      }

      captureStackTrace(this, this.constructor);
    }

    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true,
      },
    });

    // -------------------------------------------------------------------

    // Sets the name of a function if possible (depends of the JS engine).
    var setFunctionName = (function() {
      function setFunctionName(fn, name) {
        return defineProperty(fn, "name", {
          configurable: true,
          value: name,
        });
      }
      try {
        var f = function() {};
        setFunctionName(f, "foo");
        if (f.name === "foo") {
          return setFunctionName;
        }
      } catch (_) {}
    })();

    // -------------------------------------------------------------------

    function makeError(constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== "function") {
        throw new TypeError("super_ should be a function");
      }

      var name;
      if (typeof constructor === "string") {
        name = constructor;
        constructor =
          construct !== undefined
            ? function() {
                return construct(super_, arguments, this.constructor);
              }
            : function() {
                super_.apply(this, arguments);
              };

        // If the name can be set, do it once and for all.
        if (setFunctionName !== undefined) {
          setFunctionName(constructor, name);
          name = undefined;
        }
      } else if (typeof constructor !== "function") {
        throw new TypeError("constructor should be either a string or a function");
      }

      // Also register the super constructor also as `constructor.super_` just
      // like Node's `util.inherits()`.
      //
      // eslint-disable-next-line dot-notation
      constructor.super_ = constructor["super"] = super_;

      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true,
        },
      };

      // If the name could not be set on the constructor, set it on the
      // prototype.
      if (name !== undefined) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true,
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);

      return constructor;
    }
    exports = module.exports = makeError;
    exports.BaseError = BaseError;
    });

    function ClientError(res) {
      var props = extractErrorProps(res);
      ClientError.super.call(this, props.message);
      objectAssign(this, props);
    }

    function ServerError(res) {
      var props = extractErrorProps(res);
      ServerError.super.call(this, props.message);
      objectAssign(this, props);
    }

    function extractErrorProps(res) {
      var body = res.body;
      var props = {
        response: res,
        statusCode: res.statusCode,
        responseBody: stringifyBody(body, res)
      }; // API/Boom style errors ({statusCode, error, message})

      if (body.error && body.message) {
        props.message = "".concat(body.error, " - ").concat(body.message);
        return props;
      } // Query/database errors ({error: {description, other, arb, props}})


      if (body.error && body.error.description) {
        props.message = body.error.description;
        props.details = body.error;
        return props;
      } // Other, more arbitrary errors


      props.message = body.error || body.message || httpErrorMessage(res);
      return props;
    }

    function httpErrorMessage(res) {
      var statusMessage = res.statusMessage ? " ".concat(res.statusMessage) : '';
      return "".concat(res.method, "-request to ").concat(res.url, " resulted in HTTP ").concat(res.statusCode).concat(statusMessage);
    }

    function stringifyBody(body, res) {
      var contentType = (res.headers['content-type'] || '').toLowerCase();
      var isJson = contentType.indexOf('application/json') !== -1;
      return isJson ? JSON.stringify(body, null, 2) : body;
    }

    makeError_1(ClientError);
    makeError_1(ServerError);
    var ClientError_1 = ClientError;
    var ServerError_1$1 = ServerError;

    var errors$1 = {
    	ClientError: ClientError_1,
    	ServerError: ServerError_1$1
    };

    var browserMiddleware = [];

    /* eslint-disable no-empty-function, no-process-env */














    var ClientError$1 = errors$1.ClientError,
        ServerError$1 = errors$1.ServerError;

    var httpError = {
      onResponse: function onResponse(res) {
        if (res.statusCode >= 500) {
          throw new ServerError$1(res);
        } else if (res.statusCode >= 400) {
          throw new ClientError$1(res);
        }

        return res;
      }
    }; // Environment-specific middleware.



    var middleware = browserMiddleware.concat([jsonRequest(), jsonResponse(), progress(), httpError, observable$1({
      implementation: minimal
    })]);
    var request$1 = getIt(middleware);

    function httpRequest(options) {
      var requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : request$1;
      return requester(objectAssign({
        maxRedirects: 0
      }, options));
    }

    httpRequest.defaultRequester = request$1;
    httpRequest.ClientError = ClientError$1;
    httpRequest.ServerError = ServerError$1;
    var request_1 = httpRequest;

    var projectHeader = 'X-Sanity-Project-ID';

    var requestOptions = function (config) {
      var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var headers = {};
      var token = overrides.token || config.token;

      if (token) {
        headers.Authorization = "Bearer ".concat(token);
      }

      if (!overrides.useGlobalApi && !config.useProjectHostname && config.projectId) {
        headers[projectHeader] = config.projectId;
      }

      var withCredentials = Boolean(typeof overrides.withCredentials === 'undefined' ? config.token || config.withCredentials : overrides.withCredentials);
      var timeout = typeof overrides.timeout === 'undefined' ? config.timeout : overrides.timeout;
      return objectAssign({}, overrides, {
        headers: objectAssign({}, headers, overrides.headers || {}),
        timeout: typeof timeout === 'undefined' ? 5 * 60 * 1000 : timeout,
        json: true,
        withCredentials: withCredentials
      });
    };

    var defaultCdnHost = 'apicdn.sanity.io';
    var defaultConfig = {
      apiHost: 'https://api.sanity.io',
      useProjectHostname: true,
      gradientMode: false,
      isPromiseAPI: true
    };
    var LOCALHOSTS = ['localhost', '127.0.0.1', '0.0.0.0'];

    var isLocal = function isLocal(host) {
      return LOCALHOSTS.indexOf(host) !== -1;
    }; // eslint-disable-next-line no-console


    var createWarningPrinter = function createWarningPrinter(message) {
      return once(function () {
        return console.warn(message.join(' '));
      });
    };

    var printCdnWarning = createWarningPrinter(['You are not using the Sanity CDN. That means your data is always fresh, but the CDN is faster and', "cheaper. Think about it! For more info, see ".concat(generateHelpUrl('js-client-cdn-configuration'), "."), 'To hide this warning, please set the `useCdn` option to either `true` or `false` when creating', 'the client.']);
    var printBrowserTokenWarning = createWarningPrinter(['You have configured Sanity client to use a token in the browser. This may cause unintentional security issues.', "See ".concat(generateHelpUrl('js-client-browser-token'), " for more information and how to hide this warning.")]);
    var printCdnTokenWarning = createWarningPrinter(['You have set `useCdn` to `true` while also specifying a token. This is usually not what you', 'want. The CDN cannot be used with an authorization token, since private data cannot be cached.', "See ".concat(generateHelpUrl('js-client-usecdn-token'), " for more information.")]);
    var defaultConfig_1 = defaultConfig;

    var initConfig = function (config, prevConfig) {
      var newConfig = objectAssign({}, defaultConfig, prevConfig, config);
      var gradientMode = newConfig.gradientMode;
      var projectBased = !gradientMode && newConfig.useProjectHostname;

      if (typeof Promise === 'undefined') {
        var helpUrl = generateHelpUrl('js-client-promise-polyfill');
        throw new Error("No native Promise-implementation found, polyfill needed - see ".concat(helpUrl));
      }

      if (gradientMode && !newConfig.namespace) {
        throw new Error('Configuration must contain `namespace` when running in gradient mode');
      }

      if (projectBased && !newConfig.projectId) {
        throw new Error('Configuration must contain `projectId`');
      }

      var isBrowser = typeof window !== 'undefined' && window.location && window.location.hostname;
      var isLocalhost = isBrowser && isLocal(window.location.hostname);

      if (isBrowser && isLocalhost && newConfig.token && newConfig.ignoreBrowserTokenWarning !== true) {
        printBrowserTokenWarning();
      } else if ((!isBrowser || isLocalhost) && newConfig.useCdn && newConfig.token) {
        printCdnTokenWarning();
      } else if (typeof newConfig.useCdn === 'undefined') {
        printCdnWarning();
      }

      if (projectBased) {
        validators.projectId(newConfig.projectId);
      }

      if (!gradientMode && newConfig.dataset) {
        validators.dataset(newConfig.dataset, newConfig.gradientMode);
      }

      newConfig.isDefaultApi = newConfig.apiHost === defaultConfig.apiHost;
      newConfig.useCdn = Boolean(newConfig.useCdn) && !newConfig.token && !newConfig.withCredentials;

      if (newConfig.gradientMode) {
        newConfig.url = newConfig.apiHost;
        newConfig.cdnUrl = newConfig.apiHost;
      } else {
        var hostParts = newConfig.apiHost.split('://', 2);
        var protocol = hostParts[0];
        var host = hostParts[1];
        var cdnHost = newConfig.isDefaultApi ? defaultCdnHost : host;

        if (newConfig.useProjectHostname) {
          newConfig.url = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(host, "/v1");
          newConfig.cdnUrl = "".concat(protocol, "://").concat(newConfig.projectId, ".").concat(cdnHost, "/v1");
        } else {
          newConfig.url = "".concat(newConfig.apiHost, "/v1");
          newConfig.cdnUrl = newConfig.url;
        }
      }

      return newConfig;
    };

    var config$1 = {
    	defaultConfig: defaultConfig_1,
    	initConfig: initConfig
    };

    var filter$4 = filter.filter;

    var map$6 = map.map;





















    var defaultConfig$1 = config$1.defaultConfig,
        initConfig$1 = config$1.initConfig;

    var toPromise$1 = function toPromise(observable) {
      return observable.toPromise();
    };

    function SanityClient() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultConfig$1;

      if (!(this instanceof SanityClient)) {
        return new SanityClient(config);
      }

      this.config(config);
      this.assets = new assetsClient(this);
      this.datasets = new datasetsClient(this);
      this.projects = new projectsClient(this);
      this.users = new usersClient(this);
      this.auth = new authClient(this);

      if (this.clientConfig.isPromiseAPI) {
        var observableConfig = objectAssign({}, this.clientConfig, {
          isPromiseAPI: false
        });
        this.observable = new SanityClient(observableConfig);
      }
    }

    objectAssign(SanityClient.prototype, dataMethods);
    objectAssign(SanityClient.prototype, {
      clone: function clone() {
        return new SanityClient(this.config());
      },
      config: function config(newConfig) {
        if (typeof newConfig === 'undefined') {
          return objectAssign({}, this.clientConfig);
        }

        if (this.observable) {
          var observableConfig = objectAssign({}, newConfig, {
            isPromiseAPI: false
          });
          this.observable.config(observableConfig);
        }

        this.clientConfig = initConfig$1(newConfig, this.clientConfig || {});
        return this;
      },
      getUrl: function getUrl(uri) {
        var canUseCdn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var base = canUseCdn ? this.clientConfig.cdnUrl : this.clientConfig.url;
        return "".concat(base, "/").concat(uri.replace(/^\//, ''));
      },
      isPromiseAPI: function isPromiseAPI() {
        return this.clientConfig.isPromiseAPI;
      },
      _requestObservable: function _requestObservable(options) {
        var uri = options.url || options.uri;
        var canUseCdn = this.clientConfig.useCdn && ['GET', 'HEAD'].indexOf(options.method || 'GET') >= 0 && uri.indexOf('/data/') === 0;
        var reqOptions = requestOptions(this.clientConfig, objectAssign({}, options, {
          url: this.getUrl(uri, canUseCdn)
        }));
        return request_1(reqOptions, this.clientConfig.requester);
      },
      request: function request(options) {
        var observable = this._requestObservable(options).pipe(filter$4(function (event) {
          return event.type === 'response';
        }), map$6(function (event) {
          return event.body;
        }));

        return this.isPromiseAPI() ? toPromise$1(observable) : observable;
      }
    });
    SanityClient.Patch = patch;
    SanityClient.Transaction = transaction;
    SanityClient.ClientError = request_1.ClientError;
    SanityClient.ServerError = request_1.ServerError;
    SanityClient.requester = request_1.defaultRequester;
    var sanityClient = SanityClient;

    /*!
     * Cross-Browser Split 1.1.1
     * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
     * Available under the MIT License
     * ECMAScript compliant, uniform cross-browser split method
     */

    /**
     * Splits a string into an array of strings using a regex or string separator. Matches of the
     * separator are not included in the result array. However, if `separator` is a regex that contains
     * capturing groups, backreferences are spliced into the result each time `separator` is matched.
     * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
     * cross-browser.
     * @param {String} str String to split.
     * @param {RegExp|String} separator Regex or string to use for separating the string.
     * @param {Number} [limit] Maximum number of items to include in the result array.
     * @returns {Array} Array of substrings.
     * @example
     *
     * // Basic use
     * split('a b c d', ' ');
     * // -> ['a', 'b', 'c', 'd']
     *
     * // With limit
     * split('a b c d', ' ', 2);
     * // -> ['a', 'b']
     *
     * // Backreferences in result array
     * split('..word1 word2..', /([a-z]+)(\d+)/i);
     * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
     */
    var browserSplit = (function split(undef) {

      var nativeSplit = String.prototype.split,
        compliantExecNpcg = /()??/.exec("")[1] === undef,
        // NPCG: nonparticipating capturing group
        self;

      self = function(str, separator, limit) {
        // If `separator` is not a regex, use `nativeSplit`
        if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
          return nativeSplit.call(str, separator, limit);
        }
        var output = [],
          flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
          (separator.sticky ? "y" : ""),
          // Firefox 3+
          lastLastIndex = 0,
          // Make `global` and avoid `lastIndex` issues by working with a copy
          separator = new RegExp(separator.source, flags + "g"),
          separator2, match, lastIndex, lastLength;
        str += ""; // Type-convert
        if (!compliantExecNpcg) {
          // Doesn't need flags gy, but they don't hurt
          separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
        }
        /* Values for `limit`, per the spec:
         * If undefined: 4294967295 // Math.pow(2, 32) - 1
         * If 0, Infinity, or NaN: 0
         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
         * If negative number: 4294967296 - Math.floor(Math.abs(limit))
         * If other: Type-convert, then use the above rules
         */
        limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
        limit >>> 0; // ToUint32(limit)
        while (match = separator.exec(str)) {
          // `separator.lastIndex` is not reliable cross-browser
          lastIndex = match.index + match[0].length;
          if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1) {
              match[0].replace(separator2, function() {
                for (var i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === undef) {
                    match[i] = undef;
                  }
                }
              });
            }
            if (match.length > 1 && match.index < str.length) {
              Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= limit) {
              break;
            }
          }
          if (separator.lastIndex === match.index) {
            separator.lastIndex++; // Avoid an infinite loop
          }
        }
        if (lastLastIndex === str.length) {
          if (lastLength || !separator.test("")) {
            output.push("");
          }
        } else {
          output.push(str.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
      };

      return self;
    })();

    var indexOf = [].indexOf;

    var indexof = function(arr, obj){
      if (indexOf) return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj) return i;
      }
      return -1;
    };

    // contains, add, remove, toggle


    var classList = ClassList;

    function ClassList(elem) {
        var cl = elem.classList;

        if (cl) {
            return cl
        }

        var classList = {
            add: add
            , remove: remove
            , contains: contains
            , toggle: toggle
            , toString: $toString
            , length: 0
            , item: item
        };

        return classList

        function add(token) {
            var list = getTokens();
            if (indexof(list, token) > -1) {
                return
            }
            list.push(token);
            setTokens(list);
        }

        function remove(token) {
            var list = getTokens()
                , index = indexof(list, token);

            if (index === -1) {
                return
            }

            list.splice(index, 1);
            setTokens(list);
        }

        function contains(token) {
            return indexof(getTokens(), token) > -1
        }

        function toggle(token) {
            if (contains(token)) {
                remove(token);
                return false
            } else {
                add(token);
                return true
            }
        }

        function $toString() {
            return elem.className
        }

        function item(index) {
            var tokens = getTokens();
            return tokens[index] || null
        }

        function getTokens() {
            var className = elem.className;

            return filter$5(className.split(" "), isTruthy)
        }

        function setTokens(list) {
            var length = list.length;

            elem.className = list.join(" ");
            classList.length = length;

            for (var i = 0; i < list.length; i++) {
                classList[i] = list[i];
            }

            delete list[length];
        }
    }

    function filter$5 (arr, fn) {
        var ret = [];
        for (var i = 0; i < arr.length; i++) {
            if (fn(arr[i])) ret.push(arr[i]);
        }
        return ret
    }

    function isTruthy(value) {
        return !!value
    }

    var hyperscript = createCommonjsModule(function (module) {
    var w = typeof window === 'undefined' ? require$$0 : window;
    var document = w.document;
    var Text = w.Text;

    function context () {

      var cleanupFuncs = [];

      function h() {
        var args = [].slice.call(arguments), e = null;
        function item (l) {
          var r;
          function parseClass (string) {
            // Our minimal parser doesn’t understand escaping CSS special
            // characters like `#`. Don’t use them. More reading:
            // https://mathiasbynens.be/notes/css-escapes .

            var m = browserSplit(string, /([\.#]?[^\s#.]+)/);
            if(/^\.|#/.test(m[1]))
              e = document.createElement('div');
            forEach(m, function (v) {
              var s = v.substring(1,v.length);
              if(!v) return
              if(!e)
                e = document.createElement(v);
              else if (v[0] === '.')
                classList(e).add(s);
              else if (v[0] === '#')
                e.setAttribute('id', s);
            });
          }

          if(l == null)
            ;
          else if('string' === typeof l) {
            if(!e)
              parseClass(l);
            else
              e.appendChild(r = document.createTextNode(l));
          }
          else if('number' === typeof l
            || 'boolean' === typeof l
            || l instanceof Date
            || l instanceof RegExp ) {
              e.appendChild(r = document.createTextNode(l.toString()));
          }
          //there might be a better way to handle this...
          else if (isArray(l))
            forEach(l, item);
          else if(isNode(l))
            e.appendChild(r = l);
          else if(l instanceof Text)
            e.appendChild(r = l);
          else if ('object' === typeof l) {
            for (var k in l) {
              if('function' === typeof l[k]) {
                if(/^on\w+/.test(k)) {
                  (function (k, l) { // capture k, l in the closure
                    if (e.addEventListener){
                      e.addEventListener(k.substring(2), l[k], false);
                      cleanupFuncs.push(function(){
                        e.removeEventListener(k.substring(2), l[k], false);
                      });
                    }else {
                      e.attachEvent(k, l[k]);
                      cleanupFuncs.push(function(){
                        e.detachEvent(k, l[k]);
                      });
                    }
                  })(k, l);
                } else {
                  // observable
                  e[k] = l[k]();
                  cleanupFuncs.push(l[k](function (v) {
                    e[k] = v;
                  }));
                }
              }
              else if(k === 'style') {
                if('string' === typeof l[k]) {
                  e.style.cssText = l[k];
                }else {
                  for (var s in l[k]) (function(s, v) {
                    if('function' === typeof v) {
                      // observable
                      e.style.setProperty(s, v());
                      cleanupFuncs.push(v(function (val) {
                        e.style.setProperty(s, val);
                      }));
                    } else
                      var match = l[k][s].match(/(.*)\W+!important\W*$/);
                      if (match) {
                        e.style.setProperty(s, match[1], 'important');
                      } else {
                        e.style.setProperty(s, l[k][s]);
                      }
                  })(s, l[k][s]);
                }
              } else if(k === 'attrs') {
                for (var v in l[k]) {
                  e.setAttribute(v, l[k][v]);
                }
              }
              else if (k.substr(0, 5) === "data-") {
                e.setAttribute(k, l[k]);
              } else {
                e[k] = l[k];
              }
            }
          } else if ('function' === typeof l) {
            //assume it's an observable!
            var v = l();
            e.appendChild(r = isNode(v) ? v : document.createTextNode(v));

            cleanupFuncs.push(l(function (v) {
              if(isNode(v) && r.parentElement)
                r.parentElement.replaceChild(v, r), r = v;
              else
                r.textContent = v;
            }));
          }

          return r
        }
        while(args.length)
          item(args.shift());

        return e
      }

      h.cleanup = function () {
        for (var i = 0; i < cleanupFuncs.length; i++){
          cleanupFuncs[i]();
        }
        cleanupFuncs.length = 0;
      };

      return h
    }

    var h = module.exports = context();
    h.context = context;

    function isNode (el) {
      return el && el.nodeName && el.nodeType
    }

    function forEach (arr, fn) {
      if (arr.forEach) return arr.forEach(fn)
      for (var i = 0; i < arr.length; i++) fn(arr[i], i);
    }

    function isArray (arr) {
      return Object.prototype.toString.call(arr) == '[object Array]'
    }
    });

    var baseUrl$1 = 'https://docs.sanity.io/help/';

    var generateHelpUrl$1 = function generateHelpUrl(slug) {
      return baseUrl$1 + slug
    };

    var imageUrl_umd = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
       module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function _extends() {
        _extends = Object.assign || function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];

            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }

          return target;
        };

        return _extends.apply(this, arguments);
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _createForOfIteratorHelperLoose(o) {
        var i = 0;

        if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
          if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          };
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        i = o[Symbol.iterator]();
        return i.next.bind(i);
      }

      var example = 'image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg';
      function parseAssetId(ref) {
        var _ref$split = ref.split('-'),
            id = _ref$split[1],
            dimensionString = _ref$split[2],
            format = _ref$split[3];

        if (!id || !dimensionString || !format) {
          throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }

        var _dimensionString$spli = dimensionString.split('x'),
            imgWidthStr = _dimensionString$spli[0],
            imgHeightStr = _dimensionString$spli[1];

        var width = +imgWidthStr;
        var height = +imgHeightStr;
        var isValidAssetId = isFinite(width) && isFinite(height);

        if (!isValidAssetId) {
          throw new Error("Malformed asset _ref '" + ref + "'. Expected an id like \"" + example + "\".");
        }

        return {
          id: id,
          width: width,
          height: height,
          format: format
        };
      }

      var isRef = function isRef(src) {
        var source = src;
        return source ? typeof source._ref === 'string' : false;
      };

      var isAsset = function isAsset(src) {
        var source = src;
        return source ? typeof source._id === 'string' : false;
      };

      var isAssetStub = function isAssetStub(src) {
        var source = src;
        return source && source.asset ? typeof source.asset.url === 'string' : false;
      };

      function parseSource(source) {
        if (!source) {
          return null;
        }

        var image;

        if (typeof source === 'string' && isUrl(source)) {
          image = {
            asset: {
              _ref: urlToId(source)
            }
          };
        } else if (typeof source === 'string') {
          image = {
            asset: {
              _ref: source
            }
          };
        } else if (isRef(source)) {
          image = {
            asset: source
          };
        } else if (isAsset(source)) {
          image = {
            asset: {
              _ref: source._id || ''
            }
          };
        } else if (isAssetStub(source)) {
          image = {
            asset: {
              _ref: urlToId(source.asset.url)
            }
          };
        } else if (typeof source.asset === 'object') {
          image = source;
        } else {
          return null;
        }

        var img = source;

        if (img.crop) {
          image.crop = img.crop;
        }

        if (img.hotspot) {
          image.hotspot = img.hotspot;
        }

        return applyDefaults(image);
      }

      function isUrl(url) {
        return /^https?:\/\//.test("" + url);
      }

      function urlToId(url) {
        var parts = url.split('/').slice(-1);
        return ("image-" + parts[0]).replace(/\.([a-z]+)$/, '-$1');
      }

      function applyDefaults(image) {
        if (image.crop && image.hotspot) {
          return image;
        }

        var result = _extends({}, image);

        if (!result.crop) {
          result.crop = {
            left: 0,
            top: 0,
            bottom: 0,
            right: 0
          };
        }

        if (!result.hotspot) {
          result.hotspot = {
            x: 0.5,
            y: 0.5,
            height: 1.0,
            width: 1.0
          };
        }

        return result;
      }

      var SPEC_NAME_TO_URL_NAME_MAPPINGS = [['width', 'w'], ['height', 'h'], ['format', 'fm'], ['download', 'dl'], ['blur', 'blur'], ['sharpen', 'sharp'], ['invert', 'invert'], ['orientation', 'or'], ['minHeight', 'min-h'], ['maxHeight', 'max-h'], ['minWidth', 'min-w'], ['maxWidth', 'max-w'], ['quality', 'q'], ['fit', 'fit'], ['crop', 'crop'], ['saturation', 'sat'], ['auto', 'auto'], ['dpr', 'dpr']];
      function urlForImage(options) {
        var spec = _extends({}, options || {});

        var source = spec.source;
        delete spec.source;
        var image = parseSource(source);

        if (!image) {
          return null;
        }

        var id = image.asset._ref || image.asset._id || '';
        var asset = parseAssetId(id);
        var cropLeft = Math.round(image.crop.left * asset.width);
        var cropTop = Math.round(image.crop.top * asset.height);
        var crop = {
          left: cropLeft,
          top: cropTop,
          width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),
          height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)
        };
        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;
        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;
        var hotSpotCenterX = image.hotspot.x * asset.width;
        var hotSpotCenterY = image.hotspot.y * asset.height;
        var hotspot = {
          left: hotSpotCenterX - hotSpotHorizontalRadius,
          top: hotSpotCenterY - hotSpotVerticalRadius,
          right: hotSpotCenterX + hotSpotHorizontalRadius,
          bottom: hotSpotCenterY + hotSpotVerticalRadius
        };

        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {
          spec = _extends(_extends({}, spec), fit({
            crop: crop,
            hotspot: hotspot
          }, spec));
        }

        return specToImageUrl(_extends(_extends({}, spec), {}, {
          asset: asset
        }));
      }

      function specToImageUrl(spec) {
        var cdnUrl = spec.baseUrl || 'https://cdn.sanity.io';
        var filename = spec.asset.id + "-" + spec.asset.width + "x" + spec.asset.height + "." + spec.asset.format;
        var baseUrl = cdnUrl + "/images/" + spec.projectId + "/" + spec.dataset + "/" + filename;
        var params = [];

        if (spec.rect) {
          var _spec$rect = spec.rect,
              left = _spec$rect.left,
              top = _spec$rect.top,
              width = _spec$rect.width,
              height = _spec$rect.height;
          var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;

          if (isEffectiveCrop) {
            params.push("rect=" + left + "," + top + "," + width + "," + height);
          }
        }

        if (spec.bg) {
          params.push("bg=" + spec.bg);
        }

        if (spec.focalPoint) {
          params.push("fp-x=" + spec.focalPoint.x);
          params.push("fp-y=" + spec.focalPoint.y);
        }

        var flip = [spec.flipHorizontal && 'h', spec.flipVertical && 'v'].filter(Boolean).join('');

        if (flip) {
          params.push("flip=" + flip);
        }

        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function (mapping) {
          var specName = mapping[0],
              param = mapping[1];

          if (typeof spec[specName] !== 'undefined') {
            params.push(param + "=" + encodeURIComponent(spec[specName]));
          } else if (typeof spec[param] !== 'undefined') {
            params.push(param + "=" + encodeURIComponent(spec[param]));
          }
        });

        if (params.length === 0) {
          return baseUrl;
        }

        return baseUrl + "?" + params.join('&');
      }

      function fit(source, spec) {
        var cropRect;
        var imgWidth = spec.width;
        var imgHeight = spec.height;

        if (!(imgWidth && imgHeight)) {
          return {
            width: imgWidth,
            height: imgHeight,
            rect: source.crop
          };
        }

        var crop = source.crop;
        var hotspot = source.hotspot;
        var desiredAspectRatio = imgWidth / imgHeight;
        var cropAspectRatio = crop.width / crop.height;

        if (cropAspectRatio > desiredAspectRatio) {
          var height = crop.height;
          var width = height * desiredAspectRatio;
          var top = crop.top;
          var hotspotXCenter = (hotspot.right - hotspot.left) / 2 + hotspot.left;
          var left = hotspotXCenter - width / 2;

          if (left < crop.left) {
            left = crop.left;
          } else if (left + width > crop.left + crop.width) {
            left = crop.left + crop.width - width;
          }

          cropRect = {
            left: Math.round(left),
            top: Math.round(top),
            width: Math.round(width),
            height: Math.round(height)
          };
        } else {
          var _width = crop.width;

          var _height = _width / desiredAspectRatio;

          var _left = crop.left;
          var hotspotYCenter = (hotspot.bottom - hotspot.top) / 2 + hotspot.top;

          var _top = hotspotYCenter - _height / 2;

          if (_top < crop.top) {
            _top = crop.top;
          } else if (_top + _height > crop.top + crop.height) {
            _top = crop.top + crop.height - _height;
          }

          cropRect = {
            left: Math.max(0, Math.floor(_left)),
            top: Math.max(0, Math.floor(_top)),
            width: Math.round(_width),
            height: Math.round(_height)
          };
        }

        return {
          width: imgWidth,
          height: imgHeight,
          rect: cropRect
        };
      }

      var validFits = ['clip', 'crop', 'fill', 'fillmax', 'max', 'scale', 'min'];
      var validCrops = ['top', 'bottom', 'left', 'right', 'center', 'focalpoint', 'entropy'];
      var validAutoModes = ['format'];

      function isSanityClient(client) {
        return client ? typeof client.clientConfig === 'object' : false;
      }

      function rewriteSpecName(key) {
        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;

        for (var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;) {
          var entry = _step.value;
          var specName = entry[0],
              param = entry[1];

          if (key === specName || key === param) {
            return specName;
          }
        }

        return key;
      }

      function urlBuilder(options) {
        var client = options;

        if (isSanityClient(client)) {
          var _client$clientConfig = client.clientConfig,
              apiUrl = _client$clientConfig.apiHost,
              projectId = _client$clientConfig.projectId,
              dataset = _client$clientConfig.dataset;
          var apiHost = apiUrl || 'https://api.sanity.io';
          return new ImageUrlBuilder(null, {
            baseUrl: apiHost.replace(/^https:\/\/api\./, 'https://cdn.'),
            projectId: projectId,
            dataset: dataset
          });
        }

        return new ImageUrlBuilder(null, options);
      }
      var ImageUrlBuilder = /*#__PURE__*/function () {
        function ImageUrlBuilder(parent, options) {
          this.options = parent ? _extends(_extends({}, parent.options || {}), options || {}) : _extends({}, options || {});
        }

        var _proto = ImageUrlBuilder.prototype;

        _proto.withOptions = function withOptions(options) {
          var baseUrl = options.baseUrl || this.options.baseUrl;
          var newOptions = {
            baseUrl: baseUrl
          };

          for (var key in options) {
            if (options.hasOwnProperty(key)) {
              var specKey = rewriteSpecName(key);
              newOptions[specKey] = options[key];
            }
          }

          return new ImageUrlBuilder(this, _extends({
            baseUrl: baseUrl
          }, newOptions));
        };

        _proto.image = function image(source) {
          return this.withOptions({
            source: source
          });
        };

        _proto.dataset = function dataset(_dataset) {
          return this.withOptions({
            dataset: _dataset
          });
        };

        _proto.projectId = function projectId(_projectId) {
          return this.withOptions({
            projectId: _projectId
          });
        };

        _proto.bg = function bg(_bg) {
          return this.withOptions({
            bg: _bg
          });
        };

        _proto.dpr = function dpr(_dpr) {
          return this.withOptions({
            dpr: _dpr
          });
        };

        _proto.width = function width(_width) {
          return this.withOptions({
            width: _width
          });
        };

        _proto.height = function height(_height) {
          return this.withOptions({
            height: _height
          });
        };

        _proto.focalPoint = function focalPoint(x, y) {
          return this.withOptions({
            focalPoint: {
              x: x,
              y: y
            }
          });
        };

        _proto.maxWidth = function maxWidth(_maxWidth) {
          return this.withOptions({
            maxWidth: _maxWidth
          });
        };

        _proto.minWidth = function minWidth(_minWidth) {
          return this.withOptions({
            minWidth: _minWidth
          });
        };

        _proto.maxHeight = function maxHeight(_maxHeight) {
          return this.withOptions({
            maxHeight: _maxHeight
          });
        };

        _proto.minHeight = function minHeight(_minHeight) {
          return this.withOptions({
            minHeight: _minHeight
          });
        };

        _proto.size = function size(width, height) {
          return this.withOptions({
            width: width,
            height: height
          });
        };

        _proto.blur = function blur(_blur) {
          return this.withOptions({
            blur: _blur
          });
        };

        _proto.sharpen = function sharpen(_sharpen) {
          return this.withOptions({
            sharpen: _sharpen
          });
        };

        _proto.rect = function rect(left, top, width, height) {
          return this.withOptions({
            rect: {
              left: left,
              top: top,
              width: width,
              height: height
            }
          });
        };

        _proto.format = function format(_format) {
          return this.withOptions({
            format: _format
          });
        };

        _proto.invert = function invert(_invert) {
          return this.withOptions({
            invert: _invert
          });
        };

        _proto.orientation = function orientation(_orientation) {
          return this.withOptions({
            orientation: _orientation
          });
        };

        _proto.quality = function quality(_quality) {
          return this.withOptions({
            quality: _quality
          });
        };

        _proto.forceDownload = function forceDownload(download) {
          return this.withOptions({
            download: download
          });
        };

        _proto.flipHorizontal = function flipHorizontal() {
          return this.withOptions({
            flipHorizontal: true
          });
        };

        _proto.flipVertical = function flipVertical() {
          return this.withOptions({
            flipVertical: true
          });
        };

        _proto.ignoreImageParams = function ignoreImageParams() {
          return this.withOptions({
            ignoreImageParams: true
          });
        };

        _proto.fit = function fit(value) {
          if (validFits.indexOf(value) === -1) {
            throw new Error("Invalid fit mode \"" + value + "\"");
          }

          return this.withOptions({
            fit: value
          });
        };

        _proto.crop = function crop(value) {
          if (validCrops.indexOf(value) === -1) {
            throw new Error("Invalid crop mode \"" + value + "\"");
          }

          return this.withOptions({
            crop: value
          });
        };

        _proto.saturation = function saturation(_saturation) {
          return this.withOptions({
            saturation: _saturation
          });
        };

        _proto.auto = function auto(value) {
          if (validAutoModes.indexOf(value) === -1) {
            throw new Error("Invalid auto mode \"" + value + "\"");
          }

          return this.withOptions({
            auto: value
          });
        };

        _proto.url = function url() {
          return urlForImage(this.options);
        };

        _proto.toString = function toString() {
          return this.url();
        };

        return ImageUrlBuilder;
      }();

      return urlBuilder;

    })));

    });

    var enc$1 = encodeURIComponent;
    var materializeError = "You must either:\n  - Pass `projectId` and `dataset` to the block renderer\n  - Materialize images to include the `url` field.\n\nFor more information, see ".concat(generateHelpUrl$1('block-content-image-materializing'));

    var getQueryString = function getQueryString(options) {
      var query = options.imageOptions;
      var keys = Object.keys(query);

      if (!keys.length) {
        return '';
      }

      var params = keys.map(function (key) {
        return "".concat(enc$1(key), "=").concat(enc$1(query[key]));
      });
      return "?".concat(params.join('&'));
    };

    var buildUrl = function buildUrl(props) {
      var node = props.node,
          options = props.options;
      var projectId = options.projectId,
          dataset = options.dataset;
      var asset = node.asset;

      if (!asset) {
        throw new Error('Image does not have required `asset` property');
      }

      if (asset.url) {
        return asset.url + getQueryString(options);
      }

      if (!projectId || !dataset) {
        throw new Error(materializeError);
      }

      var ref = asset._ref;

      if (!ref) {
        throw new Error('Invalid image reference in block, no `_ref` found on `asset`');
      }

      return imageUrl_umd(objectAssign({
        projectId: projectId,
        dataset: dataset
      }, options.imageOptions || {})).image(node).toString();
    };

    var getImageUrl = buildUrl;

    var serializers = function (h, serializerOpts) {
      var serializeOptions = serializerOpts || {
        useDashedStyles: false // Low-level block serializer

      };

      function BlockSerializer(props) {
        var node = props.node,
            serializers = props.serializers,
            options = props.options,
            isInline = props.isInline,
            children = props.children;
        var blockType = node._type;
        var serializer = serializers.types[blockType];

        if (!serializer) {
          throw new Error("Unknown block type \"".concat(blockType, "\", please specify a serializer for it in the `serializers.types` prop"));
        }

        return h(serializer, {
          node: node,
          options: options,
          isInline: isInline
        }, children);
      } // Low-level span serializer


      function SpanSerializer(props) {
        var _props$node = props.node,
            mark = _props$node.mark,
            children = _props$node.children;
        var isPlain = typeof mark === 'string';
        var markType = isPlain ? mark : mark._type;
        var serializer = props.serializers.marks[markType];

        if (!serializer) {
          // @todo Revert back to throwing errors?
          // eslint-disable-next-line no-console
          console.warn("Unknown mark type \"".concat(markType, "\", please specify a serializer for it in the `serializers.marks` prop"));
          return h(props.serializers.markFallback, null, children);
        }

        return h(serializer, props.node, children);
      } // Low-level list serializer


      function ListSerializer(props) {
        var tag = props.type === 'bullet' ? 'ul' : 'ol';
        return h(tag, null, props.children);
      } // Low-level list item serializer


      function ListItemSerializer(props) {
        var children = !props.node.style || props.node.style === 'normal' ? // Don't wrap plain text in paragraphs inside of a list item
        props.children : // But wrap any other style in whatever the block serializer says to use
        h(props.serializers.types.block, props, props.children);
        return h('li', null, children);
      } // Renderer of an actual block of type `block`. Confusing, we know.


      function BlockTypeSerializer(props) {
        var style = props.node.style || 'normal';

        if (/^h\d/.test(style)) {
          return h(style, null, props.children);
        }

        return style === 'blockquote' ? h('blockquote', null, props.children) : h('p', null, props.children);
      } // Serializers for things that can be directly attributed to a tag without any props
      // We use partial application to do this, passing the tag name as the first argument


      function RawMarkSerializer(tag, props) {
        return h(tag, null, props.children);
      }

      function UnderlineSerializer(props) {
        var style = serializeOptions.useDashedStyles ? {
          'text-decoration': 'underline'
        } : {
          textDecoration: 'underline'
        };
        return h('span', {
          style: style
        }, props.children);
      }

      function StrikeThroughSerializer(props) {
        return h('del', null, props.children);
      }

      function LinkSerializer(props) {
        return h('a', {
          href: props.mark.href
        }, props.children);
      }

      function ImageSerializer(props) {
        if (!props.node.asset) {
          return null;
        }

        var img = h('img', {
          src: getImageUrl(props)
        });
        return props.isInline ? img : h('figure', null, img);
      } // Serializer that recursively calls itself, producing a hyperscript tree of spans


      function serializeSpan(span, serializers, index, options) {
        if (span === '\n' && serializers.hardBreak) {
          return h(serializers.hardBreak, {
            key: "hb-".concat(index)
          });
        }

        if (typeof span === 'string') {
          return serializers.text ? h(serializers.text, {
            key: "text-".concat(index)
          }, span) : span;
        }

        var children;

        if (span.children) {
          children = {
            children: span.children.map(function (child, i) {
              return options.serializeNode(child, i, span.children, true);
            })
          };
        }

        var serializedNode = objectAssign({}, span, children);
        return h(serializers.span, {
          key: span._key || "span-".concat(index),
          node: serializedNode,
          serializers: serializers
        });
      }

      var HardBreakSerializer = function HardBreakSerializer() {
        return h('br');
      };

      var defaultMarkSerializers = {
        strong: RawMarkSerializer.bind(null, 'strong'),
        em: RawMarkSerializer.bind(null, 'em'),
        code: RawMarkSerializer.bind(null, 'code'),
        underline: UnderlineSerializer,
        'strike-through': StrikeThroughSerializer,
        link: LinkSerializer
      };
      var defaultSerializers = {
        // Common overrides
        types: {
          block: BlockTypeSerializer,
          image: ImageSerializer
        },
        marks: defaultMarkSerializers,
        // Less common overrides
        list: ListSerializer,
        listItem: ListItemSerializer,
        block: BlockSerializer,
        span: SpanSerializer,
        hardBreak: HardBreakSerializer,
        // Container element
        container: 'div',
        // When we can't resolve the mark properly, use this renderer as the container
        markFallback: 'span',
        // Allow overriding text renderer, but leave undefined to just use plain strings by default
        text: undefined,
        // Empty nodes (React uses null, hyperscript with empty strings)
        empty: ''
      };
      return {
        defaultSerializers: defaultSerializers,
        serializeSpan: serializeSpan
      };
    };

    var renderNode = function renderNode(serializer, properties, children) {
      var props = properties || {};

      if (typeof serializer === 'function') {
        return serializer(objectAssign({}, props, {
          children: children
        }));
      }

      var tag = serializer;
      var childNodes = props.children || children;
      return hyperscript(tag, props, childNodes);
    };

    var _getSerializers = serializers(renderNode, {
      useDashedStyles: true
    });

    var getSrc = function (input) {
    	if (typeof input !== 'string') {
    		throw new TypeError('get-src expected a string');
    	}
    	var re = /src="(.*?)"/gm;
    	var url = re.exec(input);

    	if (url && url.length >= 2) {
    		return url[1];
    	}
    };

    var getVideoId = function (str) {
    	if (typeof str !== 'string') {
    		throw new TypeError('get-video-id expects a string');
    	}

    	if (/<iframe/gi.test(str)) {
    		str = getSrc(str);
    	}

    	// remove surrounding whitespaces or linefeeds
    	str = str.trim();

    	// remove the '-nocookie' flag from youtube urls
    	str = str.replace('-nocookie', '');

    	// remove any leading `www.`
    	str = str.replace('/www.', '/');

    	var metadata = {};

    	// Try to handle google redirection uri
    	if (/\/\/google/.test(str)) {
    		// Find the redirection uri
    		var matches = str.match(/url=([^&]+)&/);

    		// Decode the found uri and replace current url string - continue with final link
    		if (matches) {
    			// Javascript can get encoded URI
    			str = decodeURIComponent(matches[1]);
    		}
    	}

    	if (/youtube|youtu\.be|y2u\.be|i.ytimg\./.test(str)) {
    		metadata = {
    			id: youtube(str),
    			service: 'youtube'
    		};
    	} else if (/vimeo/.test(str)) {
    		metadata = {
    			id: vimeo(str),
    			service: 'vimeo'
    		};
    	} else if (/vine/.test(str)) {
    		metadata = {
    			id: vine(str),
    			service: 'vine'
    		};
    	} else if (/videopress/.test(str)) {
    		metadata = {
    			id: videopress(str),
    			service: 'videopress'
    		};
    	}
    	return metadata;
    };

    /**
     * Get the vimeo id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function vimeo(str) {
    	if (str.indexOf('#') > -1) {
    		str = str.split('#')[0];
    	}
    	if (str.indexOf('?') > -1 && str.indexOf('clip_id=') === -1) {
    		str = str.split('?')[0];
    	}

    	var id;
    	var arr;

    	var vimeoPipe = [
    		'https?:\/\/vimeo\.com\/[0-9]+$',
    		'https?:\/\/player\.vimeo\.com\/video\/[0-9]+$',
    		'https?:\/\/vimeo\.com\/channels',
    		'groups',
    		'album'
    	].join('|');

    	var vimeoRegex = new RegExp(vimeoPipe, 'gim');

    	if (vimeoRegex.test(str)) {
    		arr = str.split('/');
    		if (arr && arr.length) {
    			id = arr.pop();
    		}
    	} else if (/clip_id=/gim.test(str)) {
    		arr = str.split('clip_id=');
    		if (arr && arr.length) {
    			id = arr[1].split('&')[0];
    		}
    	}

    	return id;
    }

    /**
     * Get the vine id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function vine(str) {
    	var regex = /https:\/\/vine\.co\/v\/([a-zA-Z0-9]*)\/?/;
    	var matches = regex.exec(str);
    	return matches && matches[1];
    }

    /**
     * Get the Youtube Video id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function youtube(str) {
    	// shortcode
    	var shortcode = /youtube:\/\/|https?:\/\/youtu\.be\/|http:\/\/y2u\.be\//g;

    	if (shortcode.test(str)) {
    		var shortcodeid = str.split(shortcode)[1];
    		return stripParameters(shortcodeid);
    	}

    	// /v/ or /vi/
    	var inlinev = /\/v\/|\/vi\//g;

    	if (inlinev.test(str)) {
    		var inlineid = str.split(inlinev)[1];
    		return stripParameters(inlineid);
    	}

    	// v= or vi=
    	var parameterv = /v=|vi=/g;

    	if (parameterv.test(str)) {
    		var arr = str.split(parameterv);
    		return arr[1].split('&')[0];
    	}

    	// v= or vi=
    	var parameterwebp = /\/an_webp\//g;

    	if (parameterwebp.test(str)) {
    		var webp = str.split(parameterwebp)[1];
    		return stripParameters(webp);
    	}

    	// embed
    	var embedreg = /\/embed\//g;

    	if (embedreg.test(str)) {
    		var embedid = str.split(embedreg)[1];
    		return stripParameters(embedid);
    	}

    	// ignore /user/username pattern
    	var usernamereg = /\/user\/([a-zA-Z0-9]*)$/g;

    	if (usernamereg.test(str)) {
    		return undefined;
    	}

    	// user
    	var userreg = /\/user\/(?!.*videos)/g;

    	if (userreg.test(str)) {
    		var elements = str.split('/');
    		return stripParameters(elements.pop());
    	}

    	// attribution_link
    	var attrreg = /\/attribution_link\?.*v%3D([^%&]*)(%26|&|$)/;

    	if (attrreg.test(str)) {
    		return str.match(attrreg)[1];
    	}
    }

    /**
     * Get the VideoPress id.
     * @param {string} str - the url from which you want to extract the id
     * @returns {string|undefined}
     */
    function videopress(str) {
    	var idRegex;
    	if (str.indexOf('embed') > -1) {
    		idRegex = /embed\/(\w{8})/;
    		return str.match(idRegex)[1];
    	}

    	idRegex = /\/v\/(\w{8})/;

    	var match = str.match(idRegex);

    	if (match && match.length > 0) {
    		return str.match(idRegex)[1];
    	}
    	return undefined;
    }

    /**
     * Strip away any parameters following `?` or `/`
     * @param str
     * @returns {*}
     */
    function stripParameters(str) {
    	// Split parameters or split folder separator
    	if (str.indexOf('?') > -1) {
    		return str.split('?')[0];
    	} else if (str.indexOf('/') > -1) {
    		return str.split('/')[0];
    	}
    	return str;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$5.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$7.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    function toInteger(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    function requiredArgs(required, args) {
      if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
      }
    }

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */

    function toDate(argument) {
      requiredArgs(1, arguments);
      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger(dirtyAmount);
      return new Date(timestamp + amount);
    }

    var MILLISECONDS_IN_MINUTE = 60000;

    function getDateMillisecondsPart(date) {
      return date.getTime() % MILLISECONDS_IN_MINUTE;
    }
    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */


    function getTimezoneOffsetInMilliseconds(dirtyDate) {
      var date = new Date(dirtyDate.getTime());
      var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
      date.setSeconds(0, 0);
      var hasNegativeUTCOffset = baseTimezoneOffset > 0;
      var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date);
      return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - Now `isValid` doesn't throw an exception
     *   if the first argument is not an instance of Date.
     *   Instead, argument is converted beforehand using `toDate`.
     *
     *   Examples:
     *
     *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
     *   |---------------------------|---------------|---------------|
     *   | `new Date()`              | `true`        | `true`        |
     *   | `new Date('2016-01-01')`  | `true`        | `true`        |
     *   | `new Date('')`            | `false`       | `false`       |
     *   | `new Date(1488370835081)` | `true`        | `true`        |
     *   | `new Date(NaN)`           | `false`       | `false`       |
     *   | `'2016-01-01'`            | `TypeError`   | `false`       |
     *   | `''`                      | `TypeError`   | `false`       |
     *   | `1488370835081`           | `TypeError`   | `true`        |
     *   | `NaN`                     | `TypeError`   | `false`       |
     *
     *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
     *   that try to coerce arguments to the expected type
     *   (which is also the case with other *date-fns* functions).
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * var result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * var result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * var result = isValid(new Date(''))
     * //=> false
     */

    function isValid(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      return !isNaN(date);
    }

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXWeeks: {
        one: 'about 1 week',
        other: 'about {{count}} weeks'
      },
      xWeeks: {
        one: '1 week',
        other: '{{count}} weeks'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };
    function formatDistance(token, count, options) {
      options = options || {};
      var result;

      if (typeof formatDistanceLocale[token] === 'string') {
        result = formatDistanceLocale[token];
      } else if (count === 1) {
        result = formatDistanceLocale[token].one;
      } else {
        result = formatDistanceLocale[token].other.replace('{{count}}', count);
      }

      if (options.addSuffix) {
        if (options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    }

    function buildFormatLongFn(args) {
      return function (dirtyOptions) {
        var options = dirtyOptions || {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };
    function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    }

    function buildLocalizeFn(args) {
      return function (dirtyIndex, dirtyOptions) {
        var options = dirtyOptions || {};
        var context = options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }

    var eraValues = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
      // If you are making a new locale based on this one, check if the same is true for the language you're working on.
      // Generally, formatted dates should look like they are in the middle of a sentence,
      // e.g. in Spanish language the weekdays and months should be in the lowercase.

    };
    var monthValues = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    function ordinalNumber(dirtyNumber, _dirtyOptions) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`:
      //
      //   var options = dirtyOptions || {}
      //   var unit = String(options.unit)
      //
      // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    }

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchPatternFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var matchResult = string.match(args.matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);

        if (!parseResult) {
          return null;
        }

        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function buildMatchFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var value;

        if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
          value = findIndex(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        } else {
          value = findKey(parsePatterns, function (pattern) {
            return pattern.test(matchedString);
          });
        }

        value = args.valueCallback ? args.valueCallback(value) : value;
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
    }

    function findIndex(array, predicate) {
      for (var key = 0; key < array.length; key++) {
        if (predicate(array[key])) {
          return key;
        }
      }
    }

    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale = {
      code: 'en-US',
      formatDistance: formatDistance,
      formatLong: formatLong,
      formatRelative: formatRelative,
      localize: localize,
      match: match,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds(dirtyDate, dirtyAmount) {
      requiredArgs(2, arguments);
      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters = {
      // Year
      y: function (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function (date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function (date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function (date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function (date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function (date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function (date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function (date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function (date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };

    var MILLISECONDS_IN_DAY = 86400000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCDayOfYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeekYear(dirtyDate) {
      requiredArgs(1, arguments);
      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeek(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeek(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeekYear(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate, dirtyOptions);
      var year = date.getUTCFullYear();
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
      requiredArgs(1, arguments);
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
      var year = getUTCWeekYear(dirtyDate, dirtyOptions);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, dirtyOptions);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeek(dirtyDate, options) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
      /*
       * |     | Unit                           |     | Unit                           |
       * |-----|--------------------------------|-----|--------------------------------|
       * |  a  | AM, PM                         |  A* | Milliseconds in day            |
       * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
       * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
       * |  d  | Day of month                   |  D  | Day of year                    |
       * |  e  | Local day of week              |  E  | Day of week                    |
       * |  f  |                                |  F* | Day of week in month           |
       * |  g* | Modified Julian day            |  G  | Era                            |
       * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
       * |  i! | ISO day of week                |  I! | ISO week of year               |
       * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
       * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
       * |  l* | (deprecated)                   |  L  | Stand-alone month              |
       * |  m  | Minute                         |  M  | Month                          |
       * |  n  |                                |  N  |                                |
       * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
       * |  p! | Long localized time            |  P! | Long localized date            |
       * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
       * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
       * |  s  | Second                         |  S  | Fraction of second             |
       * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
       * |  u  | Extended year                  |  U* | Cyclic year                    |
       * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
       * |  w  | Local week of year             |  W* | Week of month                  |
       * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
       * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
       * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
       *
       * Letters marked by * are not implemented but reserved by Unicode standard.
       *
       * Letters marked by ! are non-standard, but implemented by date-fns:
       * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
       * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
       *   i.e. 7 for Sunday, 1 for Monday, etc.
       * - `I` is ISO week of year, as opposed to `w` which is local week of year.
       * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
       *   `R` is supposed to be used in conjunction with `I` and `i`
       *   for universal ISO week-numbering date, whereas
       *   `Y` is supposed to be used in conjunction with `w` and `e`
       *   for week-numbering date specific to the locale.
       * - `P` is long localized date format
       * - `p` is long localized time format
       */

    };
    var formatters$1 = {
      // Era
      G: function (date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function (date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters.y(date, token);
      },
      // Local week-numbering year
      Y: function (date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function (date, token) {
        var isoWeekYear = getUTCISOWeekYear(date); // Padding

        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function (date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function (date, token, localize, options) {
        var week = getUTCWeek(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function (date, token, localize) {
        var isoWeek = getUTCISOWeek(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function (date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters.d(date, token);
      },
      // Day of year
      D: function (date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function (date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters.h(date, token);
      },
      // Hour [0-23]
      H: function (date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters.H(date, token);
      },
      // Hour [0-11]
      K: function (date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function (date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function (date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters.m(date, token);
      },
      // Second
      s: function (date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters.s(date, token);
      },
      // Fraction of second
      S: function (date, token) {
        return formatters.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    function dateLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    }

    function timeLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    }

    function dateTimeLongFormatter(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/);
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    }

    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token, format, input) {
      if (token === 'YYYY') {
        throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'YY') {
        throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'D') {
        throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      } else if (token === 'DD') {
        throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://git.io/fxCyr"));
      }
    }

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'([^]*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://git.io/fxCyr
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | AM, PM                          | a..aaa  | AM, PM                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 01, 02, ..., 11, 00               |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 0001, ..., 999               |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 05/29/1453                        | 7     |
     * |                                 | PP      | May 29, 1453                      | 7     |
     * |                                 | PPP     | May 29th, 1453                    | 7     |
     * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
     * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
     *
     * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The second argument is now required for the sake of explicitness.
     *
     *   ```javascript
     *   // Before v2.0.0
     *   format(new Date(2016, 0, 1))
     *
     *   // v2.0.0 onward
     *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
     *   ```
     *
     * - New format string API for `format` function
     *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
     *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
     *
     * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://git.io/fxCyr
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://git.io/fxCyr
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `date` must not be Invalid Date
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://git.io/fxCyr
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format$1(dirtyDate, dirtyFormatStr, dirtyOptions) {
      requiredArgs(2, arguments);
      var formatStr = String(dirtyFormatStr);
      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;
      var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale$1.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale$1.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate(dirtyDate);

      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale$1,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale$1.formatLong, formatterOptions);
        }

        return substring;
      }).join('').match(formattingTokensRegExp).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }

        var formatter = formatters$1[firstCharacter];

        if (formatter) {
          if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, dirtyDate);
          }

          if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring, dirtyFormatStr, dirtyDate);
          }

          return formatter(utcDate, substring, locale$1.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    /**
     * @name getYear
     * @category Year Helpers
     * @summary Get the year of the given date.
     *
     * @description
     * Get the year of the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the given date
     * @returns {Number} the year
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Which year is 2 July 2014?
     * var result = getYear(new Date(2014, 6, 2))
     * //=> 2014
     */

    function getYear(dirtyDate) {
      requiredArgs(1, arguments);
      var date = toDate(dirtyDate);
      var year = date.getFullYear();
      return year;
    }

    const SANITY_PROJECT_ID = "bu5rnal5";

    const QUERY = {
      GRAPHICS_SETTINGS:
        "*[_id == 'graphics-settings']{..., mapLink->{'mainImage': mainImage,'miniImage': miniImage,'pathfindingGridUrl': pathfindingGrid.asset->url}, activeAvatars[]->{title, _id, 'spriteJsonURL': spriteJson.asset->url}}[0]",
      EVENTS:
        "*[_type == 'event']{..., participants[]->{slug,name,username}, connectedCaseStudies[]->{...,participants[]->{slug,name,username}},}",
      USERS: "*[_type == 'participant']{...,avatarLink->{'iconUrl': rest[0].asset->url}} | order(name asc) ",
      PAGES: "*[_type == 'page']",
      SEMINAR: "*[_type == 'seminar' && slug.current == $slug][0]",
      SEMINAR_PARTICIPANTS: "*[_type == 'participant' && seminarLink._ref == $id]",
      AUTH_USER_INFO:
        "*[_type == 'participant' && username == $username]{..., seminarLink->{...}}[0]",
      AUDIO_INSTALLATIONS:
        "*[_type == 'audioInstallation']{..., participants[]->{slug,name,username}, 'audioURL': soundFile.asset->url,spriteLink->{spritesheet, 'spriteJsonURL': spriteJson.asset->url}}",
      CASE_STUDIES:
        "*[_type in ['caseStudyEmergent', 'caseStudyExhibition']]{..., connectedEvents[]->{...,participants[]->{slug,name,username}}, participants[]->{slug,name,username}, spriteLink->{spritesheet, 'spriteJsonURL': spriteJson.asset->url}}",
      LAND_MARKS:
        "*[_type == 'landmark']{..., 'spriteJsonURL': spriteJson.asset->url}",
      ACTIVE_STREAMS:
        "*[_id == 'active-streams']{..., mainStream->{..., participants[]->{slug,name,username}}}[0]",
      CONNECTED_TO_USER: "*[participants[]._ref == $id]{...,participants[]->{...}}",
      GLOBAL_SETTINGS: "*[_id == 'global-settings']{..., welcomeCard->{...}}[0]",
      AREAS: "*[_type == 'area']",
      TARGET_STREAM: 
      "*[_id == $id]{..., participants[]->{slug,name,username}}[0]",
      PINNED_MESSAGE: "*[_id == 'pinned-message'][0]",
      AUDIOROOM_NAMES: "*[_id == 'audioroom-names'][0]",
    };


    // const mainFormat = "MMM dd yyyy – HH:mm"
    // const mainFormat = "MMM dd – HH:mm"
    const mainFormat = "HH:mm 'CET,' EEE MMM dd";

    const formattedDate = (start, end) => {
      try {
        if (!start) {
          return false
        }
        const startDate = start;

        if (!startDate) {
          return false
        }

        if (!end) {
          return format$1(startDate, mainFormat)
        }

        const endDate = Date.parse(end);

        if (format$1(startDate, "dd.MM.yyyy") == format$1(endDate, "dd.MM.yyyy")) {
          return format$1(startDate, "dd.MM.yyyy")
        }

        const startFormat =
          getYear(startDate) == getYear(endDate) ? "dd.MM" : "dd.MM.yyyy";
        const endFormat = "dd.MM.yyyy";

        return format$1(startDate, startFormat) + " – " + format$1(endDate, endFormat)
      } catch (err) {
        console.dir(err);
      }
    };

    // export const formattedDate = (start, end) => {

    //     const startDate = start ? start : Date.now();

    //     if (!end) {
    //         return format(startDate, "HH:mm:ss / dd.MM.yyy");
    //     }

    //     const endDate = Date.parse(end);

    //     if (format(startDate, "dd.MM.yyyy") == format(endDate, "dd.MM.yyyy")) {
    //         return format(startDate, "dd.MM.yyyy");
    //     }

    //     const startFormat =
    //         getYear(startDate) == getYear(endDate) ? "dd.MM" : "dd.MM.yyyy";
    //     const endFormat = "dd.MM.yyyy";

    //     return format(startDate, startFormat) + " – " + format(endDate, endFormat);
    // };

    const client = sanityClient({
      projectId: SANITY_PROJECT_ID,
      dataset: "production",
      token: "", // or leave blank to be anonymous user
      useCdn: false, // `false` if you want to ensure fresh data
    });

    const builder = imageUrl_umd(client);

    const loadData = async (query, params) => {
      try {
        const res = await client.fetch(query, params);
        if (res === null) {
          return Promise.reject(new Error(404))
        }
        return res
      } catch (err) {
        return Promise.reject(new Error(404))
      }
    };

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const LOCATION = {};
    const ROUTER = {};

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    function getLocation(source) {
      return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial"
      };
    }

    function createHistory(source, options) {
      const listeners = [];
      let location = getLocation(source);

      return {
        get location() {
          return location;
        },

        listen(listener) {
          listeners.push(listener);

          const popstateListener = () => {
            location = getLocation(source);
            listener({ location, action: "POP" });
          };

          source.addEventListener("popstate", popstateListener);

          return () => {
            source.removeEventListener("popstate", popstateListener);

            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
          };
        },

        navigate(to, { state, replace = false } = {}) {
          state = { ...state, key: Date.now() + "" };
          // try...catch iOS Safari limits to 100 pushState calls
          try {
            if (replace) {
              source.history.replaceState(state, null, to);
            } else {
              source.history.pushState(state, null, to);
            }
          } catch (e) {
            source.location[replace ? "replace" : "assign"](to);
          }

          location = getLocation(source);
          listeners.forEach(listener => listener({ location, action: "PUSH" }));
        }
      };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
      let index = 0;
      const stack = [{ pathname: initialPathname, search: "" }];
      const states = [];

      return {
        get location() {
          return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
          get entries() {
            return stack;
          },
          get index() {
            return index;
          },
          get state() {
            return states[index];
          },
          pushState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            index++;
            stack.push({ pathname, search });
            states.push(state);
          },
          replaceState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            stack[index] = { pathname, search };
            states[index] = state;
          }
        }
      };
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = Boolean(
      typeof window !== "undefined" &&
        window.document &&
        window.document.createElement
    );
    const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
    const { navigate } = globalHistory;

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    const paramRe = /^:(.+)/;

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    function isRootSegment(segment) {
      return segment === "";
    }

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    function isDynamic(segment) {
      return paramRe.test(segment);
    }

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    function isSplat(segment) {
      return segment[0] === "*";
    }

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri) {
      return (
        uri
          // Strip starting/ending `/`
          .replace(/(^\/+|\/+$)/g, "")
          .split("/")
      );
    }

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    function stripSlashes(str) {
      return str.replace(/(^\/+|\/+$)/g, "");
    }

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
      const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
            score += SEGMENT_POINTS;

            if (isRootSegment(segment)) {
              score += ROOT_POINTS;
            } else if (isDynamic(segment)) {
              score += DYNAMIC_POINTS;
            } else if (isSplat(segment)) {
              score -= SEGMENT_POINTS + SPLAT_PENALTY;
            } else {
              score += STATIC_POINTS;
            }

            return score;
          }, 0);

      return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
      return (
        routes
          .map(rankRoute)
          // If two routes have the exact same score, we go by index instead
          .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
          )
      );
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { path, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick$1(routes, uri) {
      let match;
      let default_;

      const [uriPathname] = uri.split("?");
      const uriSegments = segmentize(uriPathname);
      const isRootUri = uriSegments[0] === "";
      const ranked = rankRoutes(routes);

      for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
          default_ = {
            route,
            params: {},
            uri
          };
          continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
          const routeSegment = routeSegments[index];
          const uriSegment = uriSegments[index];

          if (routeSegment !== undefined && isSplat(routeSegment)) {
            // Hit a splat, just grab the rest, and return a match
            // uri:   /files/documents/work
            // route: /files/* or /files/*splatname
            const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

            params[splatName] = uriSegments
              .slice(index)
              .map(decodeURIComponent)
              .join("/");
            break;
          }

          if (uriSegment === undefined) {
            // URI is shorter than the route, no match
            // uri:   /users
            // route: /users/:userId
            missed = true;
            break;
          }

          let dynamicMatch = paramRe.exec(routeSegment);

          if (dynamicMatch && !isRootUri) {
            const value = decodeURIComponent(uriSegment);
            params[dynamicMatch[1]] = value;
          } else if (routeSegment !== uriSegment) {
            // Current segments don't match, not dynamic, not splat, so no match
            // uri:   /users/123/settings
            // route: /users/:id/profile
            missed = true;
            break;
          }
        }

        if (!missed) {
          match = {
            route,
            params,
            uri: "/" + uriSegments.slice(0, index).join("/")
          };
          break;
        }
      }

      return match || default_ || null;
    }

    /**
     * Check if the `path` matches the `uri`.
     * @param {string} path
     * @param {string} uri
     * @return {?object}
     */
    function match$1(route, uri) {
      return pick$1([route], uri);
    }

    /**
     * Combines the `basepath` and the `path` into one path.
     * @param {string} basepath
     * @param {string} path
     */
    function combinePaths(basepath, path) {
      return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
    }

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
      return (
        !event.defaultPrevented &&
        event.button === 0 &&
        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
      );
    }

    function hostMatches(anchor) {
      const host = location.host;
      return (
        anchor.host == host ||
        // svelte seems to kill anchor.host value in ie11, so fall back to checking href
        anchor.href.indexOf(`https://${host}`) === 0 ||
        anchor.href.indexOf(`http://${host}`) === 0
      )
    }

    /* node_modules/svelte-routing/src/Router.svelte generated by Svelte v3.29.0 */

    function create_fragment(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let $routes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { basepath = "/" } = $$props;
    	let { url = null } = $$props;
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate(10, $routes = value));
    	const activeRoute = writable(null);
    	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

    	// If locationContext is not set, this is the topmost Router in the tree.
    	// If the `url` prop is given we force the location to it.
    	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(9, $location = value));

    	// If routerContext is set, the routerBase of the parent Router
    	// will be the base for this Router's descendants.
    	// If routerContext is not set, the path and resolved uri will both
    	// have the value of the basepath prop.
    	const base = routerContext
    	? routerContext.routerBase
    	: writable({ path: basepath, uri: basepath });

    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(8, $base = value));

    	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    		// If there is no activeRoute, the routerBase will be identical to the base.
    		if (activeRoute === null) {
    			return base;
    		}

    		const { path: basepath } = base;
    		const { route, uri } = activeRoute;

    		// Remove the potential /* or /*splatname from
    		// the end of the child Routes relative paths.
    		const path = route.default
    		? basepath
    		: route.path.replace(/\*.*$/, "");

    		return { path, uri };
    	});

    	function registerRoute(route) {
    		const { path: basepath } = $base;
    		let { path } = route;

    		// We store the original path in the _path property so we can reuse
    		// it when the basepath changes. The only thing that matters is that
    		// the route reference is intact, so mutation is fine.
    		route._path = path;

    		route.path = combinePaths(basepath, path);

    		if (typeof window === "undefined") {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match$1(route, $location.pathname);

    			if (matchingRoute) {
    				activeRoute.set(matchingRoute);
    				hasActiveRoute = true;
    			}
    		} else {
    			routes.update(rs => {
    				rs.push(route);
    				return rs;
    			});
    		}
    	}

    	function unregisterRoute(route) {
    		routes.update(rs => {
    			const index = rs.indexOf(route);
    			rs.splice(index, 1);
    			return rs;
    		});
    	}

    	if (!locationContext) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = globalHistory.listen(history => {
    				location.set(history.location);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute
    	});

    	const writable_props = ["basepath", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		derived,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		pick: pick$1,
    		match: match$1,
    		stripSlashes,
    		combinePaths,
    		basepath,
    		url,
    		locationContext,
    		routerContext,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		location,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute,
    		$base,
    		$location,
    		$routes
    	});

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$base*/ 256) {
    			// This reactive statement will update all the Routes' path when
    			// the basepath changes.
    			 {
    				const { path: basepath } = $base;

    				routes.update(rs => {
    					rs.forEach(r => r.path = combinePaths(basepath, r._path));
    					return rs;
    				});
    			}
    		}

    		if ($$self.$$.dirty & /*$routes, $location*/ 1536) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			 {
    				const bestMatch = pick$1($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}
    	};

    	return [routes, location, base, basepath, url, $$scope, slots];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { basepath: 3, url: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/svelte-routing/src/Route.svelte generated by Svelte v3.29.0 */

    const get_default_slot_changes = dirty => ({
    	params: dirty & /*routeParams*/ 2,
    	location: dirty & /*$location*/ 16
    });

    const get_default_slot_context = ctx => ({
    	params: /*routeParams*/ ctx[1],
    	location: /*$location*/ ctx[4]
    });

    // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
    function create_if_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {:else}
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 530) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(43:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if component !== null}
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[4] },
    		/*routeParams*/ ctx[1],
    		/*routeProps*/ ctx[2]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 22)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
    					dirty & /*routeParams*/ 2 && get_spread_object(/*routeParams*/ ctx[1]),
    					dirty & /*routeProps*/ 4 && get_spread_object(/*routeProps*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(41:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activeRoute*/ ctx[3] !== null && /*$activeRoute*/ ctx[3].route === /*route*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activeRoute*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Route", slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(3, $activeRoute = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

    	const route = {
    		path,
    		// If no path prop is given, this Route will act as the default Route
    		// that is rendered if no other Route in the Router is a match.
    		default: path === ""
    	};

    	let routeParams = {};
    	let routeProps = {};
    	registerRoute(route);

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway.
    	if (typeof window !== "undefined") {
    		onDestroy(() => {
    			unregisterRoute(route);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onDestroy,
    		ROUTER,
    		LOCATION,
    		path,
    		component,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		location,
    		route,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
    		if ("routeParams" in $$props) $$invalidate(1, routeParams = $$new_props.routeParams);
    		if ("routeProps" in $$props) $$invalidate(2, routeProps = $$new_props.routeProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeRoute*/ 8) {
    			 if ($activeRoute && $activeRoute.route === route) {
    				$$invalidate(1, routeParams = $activeRoute.params);
    			}
    		}

    		 {
    			const { path, component, ...rest } = $$props;
    			$$invalidate(2, routeProps = rest);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location,
    		activeRoute,
    		location,
    		route,
    		path,
    		$$scope,
    		slots
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { path: 8, component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * An action to be added at a root element of your application to
     * capture all relative links and push them onto the history stack.
     *
     * Example:
     * ```html
     * <div use:links>
     *   <Router>
     *     <Route path="/" component={Home} />
     *     <Route path="/p/:projectId/:docId?" component={ProjectScreen} />
     *     {#each projects as project}
     *       <a href="/p/{project.id}">{project.title}</a>
     *     {/each}
     *   </Router>
     * </div>
     * ```
     */
    function links(node) {
      function findClosest(tagName, el) {
        while (el && el.tagName !== tagName) {
          el = el.parentNode;
        }
        return el;
      }

      function onClick(event) {
        const anchor = findClosest("A", event.target);

        if (
          anchor &&
          anchor.target === "" &&
          hostMatches(anchor) &&
          shouldNavigate(event) &&
          !anchor.hasAttribute("noroute")
        ) {
          event.preventDefault();
          navigate(anchor.pathname + anchor.search, { replace: anchor.hasAttribute("replace") });
        }
      }

      node.addEventListener("click", onClick);

      return {
        destroy() {
          node.removeEventListener("click", onClick);
        }
      };
    }

    /* node_modules/carbon-components-svelte/src/Button/Button.Skeleton.svelte generated by Svelte v3.29.0 */

    const file = "node_modules/carbon-components-svelte/src/Button/Button.Skeleton.svelte";

    // (38:0) {:else}
    function create_else_block$1(ctx) {
    	let div;
    	let mounted;
    	let dispose;
    	let div_levels = [/*$$restProps*/ ctx[3]];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_attributes(div, div_data);
    			toggle_class(div, "bx--skeleton", true);
    			toggle_class(div, "bx--btn", true);
    			toggle_class(div, "bx--btn--field", /*size*/ ctx[1] === "field");
    			toggle_class(div, "bx--btn--sm", /*size*/ ctx[1] === "small" || /*small*/ ctx[2]);
    			add_location(div, file, 38, 2, 803);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler_1*/ ctx[8], false, false, false),
    					listen_dev(div, "mouseover", /*mouseover_handler_1*/ ctx[9], false, false, false),
    					listen_dev(div, "mouseenter", /*mouseenter_handler_1*/ ctx[10], false, false, false),
    					listen_dev(div, "mouseleave", /*mouseleave_handler_1*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]]));
    			toggle_class(div, "bx--skeleton", true);
    			toggle_class(div, "bx--btn", true);
    			toggle_class(div, "bx--btn--field", /*size*/ ctx[1] === "field");
    			toggle_class(div, "bx--btn--sm", /*size*/ ctx[1] === "small" || /*small*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(38:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (21:0) {#if href}
    function create_if_block$1(ctx) {
    	let a;
    	let t_value = "" + "";
    	let t;
    	let a_rel_value;
    	let mounted;
    	let dispose;

    	let a_levels = [
    		{ href: /*href*/ ctx[0] },
    		{
    			rel: a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    			? "noopener noreferrer"
    			: undefined
    		},
    		{ role: "button" },
    		/*$$restProps*/ ctx[3]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			set_attributes(a, a_data);
    			toggle_class(a, "bx--skeleton", true);
    			toggle_class(a, "bx--btn", true);
    			toggle_class(a, "bx--btn--field", /*size*/ ctx[1] === "field");
    			toggle_class(a, "bx--btn--sm", /*size*/ ctx[1] === "small" || /*small*/ ctx[2]);
    			add_location(a, file, 21, 2, 410);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(a, "mouseover", /*mouseover_handler*/ ctx[5], false, false, false),
    					listen_dev(a, "mouseenter", /*mouseenter_handler*/ ctx[6], false, false, false),
    					listen_dev(a, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				dirty & /*href*/ 1 && { href: /*href*/ ctx[0] },
    				dirty & /*$$restProps*/ 8 && a_rel_value !== (a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    				? "noopener noreferrer"
    				: undefined) && { rel: a_rel_value },
    				{ role: "button" },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));

    			toggle_class(a, "bx--skeleton", true);
    			toggle_class(a, "bx--btn", true);
    			toggle_class(a, "bx--btn--field", /*size*/ ctx[1] === "field");
    			toggle_class(a, "bx--btn--sm", /*size*/ ctx[1] === "small" || /*small*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(21:0) {#if href}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*href*/ ctx[0]) return create_if_block$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	const omit_props_names = ["href","size","small"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Button_Skeleton", slots, []);
    	let { href = undefined } = $$props;
    	let { size = "default" } = $$props;
    	let { small = false } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ("small" in $$new_props) $$invalidate(2, small = $$new_props.small);
    	};

    	$$self.$capture_state = () => ({ href, size, small });

    	$$self.$inject_state = $$new_props => {
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    		if ("small" in $$props) $$invalidate(2, small = $$new_props.small);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		href,
    		size,
    		small,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_1,
    		mouseover_handler_1,
    		mouseenter_handler_1,
    		mouseleave_handler_1
    	];
    }

    class Button_Skeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { href: 0, size: 1, small: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button_Skeleton",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get href() {
    		throw new Error("<Button_Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button_Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button_Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button_Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get small() {
    		throw new Error("<Button_Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set small(value) {
    		throw new Error("<Button_Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Button/Button.svelte generated by Svelte v3.29.0 */
    const file$1 = "node_modules/carbon-components-svelte/src/Button/Button.svelte";
    const get_default_slot_changes$1 = dirty => ({ props: dirty[0] & /*buttonProps*/ 512 });
    const get_default_slot_context$1 = ctx => ({ props: /*buttonProps*/ ctx[9] });

    // (160:2) {:else}
    function create_else_block$2(ctx) {
    	let button;
    	let t0;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*hasIconOnly*/ ctx[2] && create_if_block_6(ctx);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let if_block1 = /*icon*/ ctx[3] && create_if_block_5(ctx);
    	let button_levels = [/*buttonProps*/ ctx[9]];
    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_attributes(button, button_data);
    			add_location(button, file$1, 160, 4, 3886);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			if (if_block0) if_block0.m(button, null);
    			append_dev(button, t0);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			append_dev(button, t1);
    			if (if_block1) if_block1.m(button, null);
    			/*button_binding*/ ctx[31](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler_2*/ ctx[22], false, false, false),
    					listen_dev(button, "mouseover", /*mouseover_handler_2*/ ctx[23], false, false, false),
    					listen_dev(button, "mouseenter", /*mouseenter_handler_2*/ ctx[24], false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler_2*/ ctx[25], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasIconOnly*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_6(ctx);
    					if_block0.c();
    					if_block0.m(button, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}

    			if (/*icon*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_5(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(button, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [dirty[0] & /*buttonProps*/ 512 && /*buttonProps*/ ctx[9]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			/*button_binding*/ ctx[31](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(160:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (137:30) 
    function create_if_block_2(ctx) {
    	let a;
    	let t0;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*hasIconOnly*/ ctx[2] && create_if_block_4(ctx);
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], null);
    	let if_block1 = /*icon*/ ctx[3] && create_if_block_3(ctx);
    	let a_levels = [/*buttonProps*/ ctx[9]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			set_attributes(a, a_data);
    			add_location(a, file$1, 138, 4, 3417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t0);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			append_dev(a, t1);
    			if (if_block1) if_block1.m(a, null);
    			/*a_binding*/ ctx[30](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler_1*/ ctx[18], false, false, false),
    					listen_dev(a, "mouseover", /*mouseover_handler_1*/ ctx[19], false, false, false),
    					listen_dev(a, "mouseenter", /*mouseenter_handler_1*/ ctx[20], false, false, false),
    					listen_dev(a, "mouseleave", /*mouseleave_handler_1*/ ctx[21], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*hasIconOnly*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4(ctx);
    					if_block0.c();
    					if_block0.m(a, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 65536) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, null, null);
    				}
    			}

    			if (/*icon*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*icon*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(a, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [dirty[0] & /*buttonProps*/ 512 && /*buttonProps*/ ctx[9]]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block0) if_block0.d();
    			if (default_slot) default_slot.d(detaching);
    			if (if_block1) if_block1.d();
    			/*a_binding*/ ctx[30](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(137:30) ",
    		ctx
    	});

    	return block;
    }

    // (135:2) {#if as}
    function create_if_block_1$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[17].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[16], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope, buttonProps*/ 66048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[16], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(135:2) {#if as}",
    		ctx
    	});

    	return block;
    }

    // (123:0) {#if skeleton}
    function create_if_block$2(ctx) {
    	let buttonskeleton;
    	let current;

    	const buttonskeleton_spread_levels = [
    		{ href: /*href*/ ctx[8] },
    		{ size: /*size*/ ctx[1] },
    		/*$$restProps*/ ctx[10],
    		{
    			style: /*hasIconOnly*/ ctx[2] && "width: 3rem;"
    		}
    	];

    	let buttonskeleton_props = {};

    	for (let i = 0; i < buttonskeleton_spread_levels.length; i += 1) {
    		buttonskeleton_props = assign(buttonskeleton_props, buttonskeleton_spread_levels[i]);
    	}

    	buttonskeleton = new Button_Skeleton({
    			props: buttonskeleton_props,
    			$$inline: true
    		});

    	buttonskeleton.$on("click", /*click_handler*/ ctx[26]);
    	buttonskeleton.$on("mouseover", /*mouseover_handler*/ ctx[27]);
    	buttonskeleton.$on("mouseenter", /*mouseenter_handler*/ ctx[28]);
    	buttonskeleton.$on("mouseleave", /*mouseleave_handler*/ ctx[29]);

    	const block = {
    		c: function create() {
    			create_component(buttonskeleton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(buttonskeleton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const buttonskeleton_changes = (dirty[0] & /*href, size, $$restProps, hasIconOnly*/ 1286)
    			? get_spread_update(buttonskeleton_spread_levels, [
    					dirty[0] & /*href*/ 256 && { href: /*href*/ ctx[8] },
    					dirty[0] & /*size*/ 2 && { size: /*size*/ ctx[1] },
    					dirty[0] & /*$$restProps*/ 1024 && get_spread_object(/*$$restProps*/ ctx[10]),
    					dirty[0] & /*hasIconOnly*/ 4 && {
    						style: /*hasIconOnly*/ ctx[2] && "width: 3rem;"
    					}
    				])
    			: {};

    			buttonskeleton.$set(buttonskeleton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttonskeleton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttonskeleton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(buttonskeleton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(123:0) {#if skeleton}",
    		ctx
    	});

    	return block;
    }

    // (169:6) {#if hasIconOnly}
    function create_if_block_6(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*iconDescription*/ ctx[4]);
    			toggle_class(span, "bx--assistive-text", true);
    			add_location(span, file$1, 169, 8, 4053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*iconDescription*/ 16) set_data_dev(t, /*iconDescription*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(169:6) {#if hasIconOnly}",
    		ctx
    	});

    	return block;
    }

    // (173:6) {#if icon}
    function create_if_block_5(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*icon*/ ctx[3];

    	function switch_props(ctx) {
    		return {
    			props: {
    				"aria-hidden": "true",
    				class: "bx--btn__icon",
    				"aria-label": /*iconDescription*/ ctx[4]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*iconDescription*/ 16) switch_instance_changes["aria-label"] = /*iconDescription*/ ctx[4];

    			if (switch_value !== (switch_value = /*icon*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(173:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    // (147:6) {#if hasIconOnly}
    function create_if_block_4(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*iconDescription*/ ctx[4]);
    			toggle_class(span, "bx--assistive-text", true);
    			add_location(span, file$1, 147, 8, 3579);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*iconDescription*/ 16) set_data_dev(t, /*iconDescription*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(147:6) {#if hasIconOnly}",
    		ctx
    	});

    	return block;
    }

    // (151:6) {#if icon}
    function create_if_block_3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*icon*/ ctx[3];

    	function switch_props(ctx) {
    		return {
    			props: {
    				"aria-hidden": "true",
    				class: "bx--btn__icon",
    				"aria-label": /*iconDescription*/ ctx[4]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*iconDescription*/ 16) switch_instance_changes["aria-label"] = /*iconDescription*/ ctx[4];

    			if (switch_value !== (switch_value = /*icon*/ ctx[3])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(151:6) {#if icon}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$2, create_if_block_1$1, create_if_block_2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*skeleton*/ ctx[6]) return 0;
    		if (/*as*/ ctx[5]) return 1;
    		if (/*href*/ ctx[8] && !/*disabled*/ ctx[7]) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"kind","size","hasIconOnly","icon","iconDescription","tooltipAlignment","tooltipPosition","as","skeleton","disabled","href","tabindex","type","ref"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Button", slots, ['default']);
    	let { kind = "primary" } = $$props;
    	let { size = "default" } = $$props;
    	let { hasIconOnly = false } = $$props;
    	let { icon = undefined } = $$props;
    	let { iconDescription = undefined } = $$props;
    	let { tooltipAlignment = undefined } = $$props;
    	let { tooltipPosition = undefined } = $$props;
    	let { as = false } = $$props;
    	let { skeleton = false } = $$props;
    	let { disabled = false } = $$props;
    	let { href = undefined } = $$props;
    	let { tabindex = "0" } = $$props;
    	let { type = "button" } = $$props;
    	let { ref = null } = $$props;
    	const ctx = getContext("ComposedModal");

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_2(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("kind" in $$new_props) $$invalidate(11, kind = $$new_props.kind);
    		if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ("hasIconOnly" in $$new_props) $$invalidate(2, hasIconOnly = $$new_props.hasIconOnly);
    		if ("icon" in $$new_props) $$invalidate(3, icon = $$new_props.icon);
    		if ("iconDescription" in $$new_props) $$invalidate(4, iconDescription = $$new_props.iconDescription);
    		if ("tooltipAlignment" in $$new_props) $$invalidate(12, tooltipAlignment = $$new_props.tooltipAlignment);
    		if ("tooltipPosition" in $$new_props) $$invalidate(13, tooltipPosition = $$new_props.tooltipPosition);
    		if ("as" in $$new_props) $$invalidate(5, as = $$new_props.as);
    		if ("skeleton" in $$new_props) $$invalidate(6, skeleton = $$new_props.skeleton);
    		if ("disabled" in $$new_props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ("href" in $$new_props) $$invalidate(8, href = $$new_props.href);
    		if ("tabindex" in $$new_props) $$invalidate(14, tabindex = $$new_props.tabindex);
    		if ("type" in $$new_props) $$invalidate(15, type = $$new_props.type);
    		if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    		if ("$$scope" in $$new_props) $$invalidate(16, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		kind,
    		size,
    		hasIconOnly,
    		icon,
    		iconDescription,
    		tooltipAlignment,
    		tooltipPosition,
    		as,
    		skeleton,
    		disabled,
    		href,
    		tabindex,
    		type,
    		ref,
    		getContext,
    		ButtonSkeleton: Button_Skeleton,
    		ctx,
    		buttonProps
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("kind" in $$props) $$invalidate(11, kind = $$new_props.kind);
    		if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    		if ("hasIconOnly" in $$props) $$invalidate(2, hasIconOnly = $$new_props.hasIconOnly);
    		if ("icon" in $$props) $$invalidate(3, icon = $$new_props.icon);
    		if ("iconDescription" in $$props) $$invalidate(4, iconDescription = $$new_props.iconDescription);
    		if ("tooltipAlignment" in $$props) $$invalidate(12, tooltipAlignment = $$new_props.tooltipAlignment);
    		if ("tooltipPosition" in $$props) $$invalidate(13, tooltipPosition = $$new_props.tooltipPosition);
    		if ("as" in $$props) $$invalidate(5, as = $$new_props.as);
    		if ("skeleton" in $$props) $$invalidate(6, skeleton = $$new_props.skeleton);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$new_props.disabled);
    		if ("href" in $$props) $$invalidate(8, href = $$new_props.href);
    		if ("tabindex" in $$props) $$invalidate(14, tabindex = $$new_props.tabindex);
    		if ("type" in $$props) $$invalidate(15, type = $$new_props.type);
    		if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    		if ("buttonProps" in $$props) $$invalidate(9, buttonProps = $$new_props.buttonProps);
    	};

    	let buttonProps;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*ref*/ 1) {
    			 if (ctx && ref) {
    				ctx.declareRef(ref);
    			}
    		}

    		 $$invalidate(9, buttonProps = {
    			role: "button",
    			type: href && !disabled ? undefined : type,
    			tabindex,
    			disabled,
    			href,
    			...$$restProps,
    			class: [
    				"bx--btn",
    				size === "field" && "bx--btn--field",
    				size === "small" && "bx--btn--sm",
    				kind && `bx--btn--${kind}`,
    				disabled && "bx--btn--disabled",
    				hasIconOnly && "bx--btn--icon-only",
    				hasIconOnly && "bx--tooltip__trigger",
    				hasIconOnly && "bx--tooltip--a11y",
    				hasIconOnly && tooltipPosition && `bx--tooltip--${tooltipPosition}`,
    				hasIconOnly && tooltipAlignment && `bx--tooltip--align-${tooltipAlignment}`,
    				$$restProps.class
    			].filter(Boolean).join(" ")
    		});
    	};

    	return [
    		ref,
    		size,
    		hasIconOnly,
    		icon,
    		iconDescription,
    		as,
    		skeleton,
    		disabled,
    		href,
    		buttonProps,
    		$$restProps,
    		kind,
    		tooltipAlignment,
    		tooltipPosition,
    		tabindex,
    		type,
    		$$scope,
    		slots,
    		click_handler_1,
    		mouseover_handler_1,
    		mouseenter_handler_1,
    		mouseleave_handler_1,
    		click_handler_2,
    		mouseover_handler_2,
    		mouseenter_handler_2,
    		mouseleave_handler_2,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		a_binding,
    		button_binding
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$3,
    			create_fragment$3,
    			safe_not_equal,
    			{
    				kind: 11,
    				size: 1,
    				hasIconOnly: 2,
    				icon: 3,
    				iconDescription: 4,
    				tooltipAlignment: 12,
    				tooltipPosition: 13,
    				as: 5,
    				skeleton: 6,
    				disabled: 7,
    				href: 8,
    				tabindex: 14,
    				type: 15,
    				ref: 0
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get kind() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kind(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasIconOnly() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasIconOnly(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDescription() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDescription(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipAlignment() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipAlignment(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tooltipPosition() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tooltipPosition(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get as() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set as(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skeleton() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set skeleton(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/WarningFilled16/WarningFilled16.svelte generated by Svelte v3.29.0 */

    const file$2 = "node_modules/carbon-icons-svelte/lib/WarningFilled16/WarningFilled16.svelte";

    // (39:4) {#if title}
    function create_if_block$3(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$2, 39, 6, 1352);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "WarningFilled16" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 16 16" },
    		{ fill: "currentColor" },
    		{ width: "16" },
    		{ height: "16" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2\tc-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z");
    			add_location(path0, file$2, 36, 2, 953);
    			attr_dev(path1, "d", "M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8\tc0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			attr_dev(path1, "opacity", "0");
    			add_location(path1, file$2, 36, 192, 1143);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$2, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "WarningFilled16" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 16 16" },
    				{ fill: "currentColor" },
    				{ width: "16" },
    				{ height: "16" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WarningFilled16", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class WarningFilled16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WarningFilled16",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get class() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<WarningFilled16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<WarningFilled16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/ChevronDown16/ChevronDown16.svelte generated by Svelte v3.29.0 */

    const file$3 = "node_modules/carbon-icons-svelte/lib/ChevronDown16/ChevronDown16.svelte";

    // (39:4) {#if title}
    function create_if_block$4(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$3, 39, 6, 1039);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$1.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "ChevronDown16" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 16 16" },
    		{ fill: "currentColor" },
    		{ width: "16" },
    		{ height: "16" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z");
    			add_location(path, file$3, 36, 2, 951);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$3, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "ChevronDown16" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 16 16" },
    				{ fill: "currentColor" },
    				{ width: "16" },
    				{ height: "16" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ChevronDown16", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class ChevronDown16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChevronDown16",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get class() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ChevronDown16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ChevronDown16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/Close16/Close16.svelte generated by Svelte v3.29.0 */

    const file$4 = "node_modules/carbon-icons-svelte/lib/Close16/Close16.svelte";

    // (39:4) {#if title}
    function create_if_block$5(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$4, 39, 6, 1091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$2.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "Close16" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "16" },
    		{ height: "16" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
    			add_location(path, file$4, 36, 2, 945);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$4, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "Close16" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "16" },
    				{ height: "16" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Close16", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class Close16 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Close16",
    			options,
    			id: create_fragment$6.name
    		});
    	}

    	get class() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Close16>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Close16>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/Close20/Close20.svelte generated by Svelte v3.29.0 */

    const file$5 = "node_modules/carbon-icons-svelte/lib/Close20/Close20.svelte";

    // (39:4) {#if title}
    function create_if_block$6(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$5, 39, 6, 1091);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$3(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$3.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$3(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "Close20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z");
    			add_location(path, file$5, 36, 2, 945);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$5, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "Close20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Close20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class Close20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Close20",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get class() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Close20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Close20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Form/Form.svelte generated by Svelte v3.29.0 */

    const file$6 = "node_modules/carbon-components-svelte/src/Form/Form.svelte";

    function create_fragment$8(ctx) {
    	let form;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);
    	let form_levels = [/*$$restProps*/ ctx[0]];
    	let form_data = {};

    	for (let i = 0; i < form_levels.length; i += 1) {
    		form_data = assign(form_data, form_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			form = element("form");
    			if (default_slot) default_slot.c();
    			set_attributes(form, form_data);
    			toggle_class(form, "bx--form", true);
    			add_location(form, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);

    			if (default_slot) {
    				default_slot.m(form, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(form, "click", /*click_handler*/ ctx[3], false, false, false),
    					listen_dev(form, "mouseover", /*mouseover_handler*/ ctx[4], false, false, false),
    					listen_dev(form, "mouseenter", /*mouseenter_handler*/ ctx[5], false, false, false),
    					listen_dev(form, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[7]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			set_attributes(form, form_data = get_spread_update(form_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
    			toggle_class(form, "bx--form", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Form", slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("$$scope" in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	return [
    		$$restProps,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		submit_handler
    	];
    }

    class Form extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Form",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte generated by Svelte v3.29.0 */

    const file$7 = "node_modules/carbon-components-svelte/src/FormGroup/FormGroup.svelte";

    // (38:2) {#if message}
    function create_if_block$7(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*messageText*/ ctx[2]);
    			toggle_class(div, "bx--form__requirement", true);
    			add_location(div, file$7, 38, 4, 741);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*messageText*/ 4) set_data_dev(t, /*messageText*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(38:2) {#if message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let fieldset;
    	let legend;
    	let t0;
    	let t1;
    	let t2;
    	let fieldset_data_invalid_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	let if_block = /*message*/ ctx[1] && create_if_block$7(ctx);

    	let fieldset_levels = [
    		{
    			"data-invalid": fieldset_data_invalid_value = /*invalid*/ ctx[0] || undefined
    		},
    		/*$$restProps*/ ctx[4]
    	];

    	let fieldset_data = {};

    	for (let i = 0; i < fieldset_levels.length; i += 1) {
    		fieldset_data = assign(fieldset_data, fieldset_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			fieldset = element("fieldset");
    			legend = element("legend");
    			t0 = text(/*legendText*/ ctx[3]);
    			t1 = space();
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (if_block) if_block.c();
    			toggle_class(legend, "bx--label", true);
    			add_location(legend, file$7, 35, 2, 655);
    			set_attributes(fieldset, fieldset_data);
    			toggle_class(fieldset, "bx--fieldset", true);
    			add_location(fieldset, file$7, 26, 0, 494);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, fieldset, anchor);
    			append_dev(fieldset, legend);
    			append_dev(legend, t0);
    			append_dev(fieldset, t1);

    			if (default_slot) {
    				default_slot.m(fieldset, null);
    			}

    			append_dev(fieldset, t2);
    			if (if_block) if_block.m(fieldset, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(fieldset, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(fieldset, "mouseover", /*mouseover_handler*/ ctx[8], false, false, false),
    					listen_dev(fieldset, "mouseenter", /*mouseenter_handler*/ ctx[9], false, false, false),
    					listen_dev(fieldset, "mouseleave", /*mouseleave_handler*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*legendText*/ 8) set_data_dev(t0, /*legendText*/ ctx[3]);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (/*message*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					if_block.m(fieldset, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			set_attributes(fieldset, fieldset_data = get_spread_update(fieldset_levels, [
    				(!current || dirty & /*invalid*/ 1 && fieldset_data_invalid_value !== (fieldset_data_invalid_value = /*invalid*/ ctx[0] || undefined)) && {
    					"data-invalid": fieldset_data_invalid_value
    				},
    				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
    			]));

    			toggle_class(fieldset, "bx--fieldset", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(fieldset);
    			if (default_slot) default_slot.d(detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	const omit_props_names = ["invalid","message","messageText","legendText"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FormGroup", slots, ['default']);
    	let { invalid = false } = $$props;
    	let { message = false } = $$props;
    	let { messageText = "" } = $$props;
    	let { legendText = "" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("invalid" in $$new_props) $$invalidate(0, invalid = $$new_props.invalid);
    		if ("message" in $$new_props) $$invalidate(1, message = $$new_props.message);
    		if ("messageText" in $$new_props) $$invalidate(2, messageText = $$new_props.messageText);
    		if ("legendText" in $$new_props) $$invalidate(3, legendText = $$new_props.legendText);
    		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		invalid,
    		message,
    		messageText,
    		legendText
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("invalid" in $$props) $$invalidate(0, invalid = $$new_props.invalid);
    		if ("message" in $$props) $$invalidate(1, message = $$new_props.message);
    		if ("messageText" in $$props) $$invalidate(2, messageText = $$new_props.messageText);
    		if ("legendText" in $$props) $$invalidate(3, legendText = $$new_props.legendText);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		invalid,
    		message,
    		messageText,
    		legendText,
    		$$restProps,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class FormGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			invalid: 0,
    			message: 1,
    			messageText: 2,
    			legendText: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormGroup",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get invalid() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get message() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get messageText() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set messageText(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get legendText() {
    		throw new Error("<FormGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set legendText(value) {
    		throw new Error("<FormGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Icon/Icon.Skeleton.svelte generated by Svelte v3.29.0 */

    const file$8 = "node_modules/carbon-components-svelte/src/Icon/Icon.Skeleton.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let div_style_value;
    	let mounted;
    	let dispose;

    	let div_levels = [
    		/*$$restProps*/ ctx[1],
    		{
    			style: div_style_value = "" + (/*$$restProps*/ ctx[1].style + "; width: " + /*size*/ ctx[0] + "px; height: " + /*size*/ ctx[0] + "px")
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_attributes(div, div_data);
    			toggle_class(div, "bx--icon--skeleton", true);
    			add_location(div, file$8, 8, 0, 116);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler*/ ctx[2], false, false, false),
    					listen_dev(div, "mouseover", /*mouseover_handler*/ ctx[3], false, false, false),
    					listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[4], false, false, false),
    					listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1],
    				dirty & /*$$restProps, size*/ 3 && div_style_value !== (div_style_value = "" + (/*$$restProps*/ ctx[1].style + "; width: " + /*size*/ ctx[0] + "px; height: " + /*size*/ ctx[0] + "px")) && { style: div_style_value }
    			]));

    			toggle_class(div, "bx--icon--skeleton", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	const omit_props_names = ["size"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Icon_Skeleton", slots, []);
    	let { size = 16 } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("size" in $$new_props) $$invalidate(0, size = $$new_props.size);
    	};

    	$$self.$capture_state = () => ({ size });

    	$$self.$inject_state = $$new_props => {
    		if ("size" in $$props) $$invalidate(0, size = $$new_props.size);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		size,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Icon_Skeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { size: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon_Skeleton",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get size() {
    		throw new Error("<Icon_Skeleton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Icon_Skeleton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Icon/Icon.svelte generated by Svelte v3.29.0 */

    // (26:0) {:else}
    function create_else_block$3(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*$$restProps*/ ctx[2]];
    	var switch_value = /*render*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("click", /*click_handler_1*/ ctx[7]);
    		switch_instance.$on("mouseover", /*mouseover_handler_1*/ ctx[8]);
    		switch_instance.$on("mouseenter", /*mouseenter_handler_1*/ ctx[9]);
    		switch_instance.$on("mouseleave", /*mouseleave_handler_1*/ ctx[10]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$$restProps*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*$$restProps*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*render*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("click", /*click_handler_1*/ ctx[7]);
    					switch_instance.$on("mouseover", /*mouseover_handler_1*/ ctx[8]);
    					switch_instance.$on("mouseenter", /*mouseenter_handler_1*/ ctx[9]);
    					switch_instance.$on("mouseleave", /*mouseleave_handler_1*/ ctx[10]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(26:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if skeleton}
    function create_if_block$8(ctx) {
    	let iconskeleton;
    	let current;
    	const iconskeleton_spread_levels = [/*$$restProps*/ ctx[2]];
    	let iconskeleton_props = {};

    	for (let i = 0; i < iconskeleton_spread_levels.length; i += 1) {
    		iconskeleton_props = assign(iconskeleton_props, iconskeleton_spread_levels[i]);
    	}

    	iconskeleton = new Icon_Skeleton({
    			props: iconskeleton_props,
    			$$inline: true
    		});

    	iconskeleton.$on("click", /*click_handler*/ ctx[3]);
    	iconskeleton.$on("mouseover", /*mouseover_handler*/ ctx[4]);
    	iconskeleton.$on("mouseenter", /*mouseenter_handler*/ ctx[5]);
    	iconskeleton.$on("mouseleave", /*mouseleave_handler*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(iconskeleton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(iconskeleton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const iconskeleton_changes = (dirty & /*$$restProps*/ 4)
    			? get_spread_update(iconskeleton_spread_levels, [get_spread_object(/*$$restProps*/ ctx[2])])
    			: {};

    			iconskeleton.$set(iconskeleton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconskeleton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(iconskeleton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(iconskeleton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(18:0) {#if skeleton}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*skeleton*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	const omit_props_names = ["render","skeleton"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Icon", slots, []);
    	let { render = undefined } = $$props;
    	let { skeleton = false } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("render" in $$new_props) $$invalidate(0, render = $$new_props.render);
    		if ("skeleton" in $$new_props) $$invalidate(1, skeleton = $$new_props.skeleton);
    	};

    	$$self.$capture_state = () => ({ render, skeleton, IconSkeleton: Icon_Skeleton });

    	$$self.$inject_state = $$new_props => {
    		if ("render" in $$props) $$invalidate(0, render = $$new_props.render);
    		if ("skeleton" in $$props) $$invalidate(1, skeleton = $$new_props.skeleton);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		render,
    		skeleton,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_1,
    		mouseover_handler_1,
    		mouseenter_handler_1,
    		mouseleave_handler_1
    	];
    }

    class Icon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { render: 0, skeleton: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Icon",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get render() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set render(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skeleton() {
    		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set skeleton(value) {
    		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte generated by Svelte v3.29.0 */
    const file$9 = "node_modules/carbon-components-svelte/src/Notification/NotificationButton.svelte";

    function create_fragment$c(ctx) {
    	let button;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*renderIcon*/ ctx[1];

    	function switch_props(ctx) {
    		return {
    			props: {
    				title: /*title*/ ctx[2],
    				class: "" + ((/*notificationType*/ ctx[0] === "toast" && "bx--toast-notification__close-icon") + "\n      " + (/*notificationType*/ ctx[0] === "inline" && "bx--inline-notification__close-icon"))
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	let button_levels = [
    		{ type: "button" },
    		{ "aria-label": /*iconDescription*/ ctx[3] },
    		{ title: /*iconDescription*/ ctx[3] },
    		/*$$restProps*/ ctx[4]
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			set_attributes(button, button_data);
    			toggle_class(button, "bx--toast-notification__close-button", /*notificationType*/ ctx[0] === "toast");
    			toggle_class(button, "bx--inline-notification__close-button", /*notificationType*/ ctx[0] === "inline");
    			add_location(button, file$9, 28, 0, 670);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[5], false, false, false),
    					listen_dev(button, "mouseover", /*mouseover_handler*/ ctx[6], false, false, false),
    					listen_dev(button, "mouseenter", /*mouseenter_handler*/ ctx[7], false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*title*/ 4) switch_instance_changes.title = /*title*/ ctx[2];
    			if (dirty & /*notificationType*/ 1) switch_instance_changes.class = "" + ((/*notificationType*/ ctx[0] === "toast" && "bx--toast-notification__close-icon") + "\n      " + (/*notificationType*/ ctx[0] === "inline" && "bx--inline-notification__close-icon"));

    			if (switch_value !== (switch_value = /*renderIcon*/ ctx[1])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, button, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				{ type: "button" },
    				(!current || dirty & /*iconDescription*/ 8) && { "aria-label": /*iconDescription*/ ctx[3] },
    				(!current || dirty & /*iconDescription*/ 8) && { title: /*iconDescription*/ ctx[3] },
    				dirty & /*$$restProps*/ 16 && /*$$restProps*/ ctx[4]
    			]));

    			toggle_class(button, "bx--toast-notification__close-button", /*notificationType*/ ctx[0] === "toast");
    			toggle_class(button, "bx--inline-notification__close-button", /*notificationType*/ ctx[0] === "inline");
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	const omit_props_names = ["notificationType","renderIcon","title","iconDescription"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotificationButton", slots, []);
    	let { notificationType = "toast" } = $$props;
    	let { renderIcon = Close20 } = $$props;
    	let { title = undefined } = $$props;
    	let { iconDescription = "Close icon" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(4, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("notificationType" in $$new_props) $$invalidate(0, notificationType = $$new_props.notificationType);
    		if ("renderIcon" in $$new_props) $$invalidate(1, renderIcon = $$new_props.renderIcon);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("iconDescription" in $$new_props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    	};

    	$$self.$capture_state = () => ({
    		notificationType,
    		renderIcon,
    		title,
    		iconDescription,
    		Close20
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("notificationType" in $$props) $$invalidate(0, notificationType = $$new_props.notificationType);
    		if ("renderIcon" in $$props) $$invalidate(1, renderIcon = $$new_props.renderIcon);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("iconDescription" in $$props) $$invalidate(3, iconDescription = $$new_props.iconDescription);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		notificationType,
    		renderIcon,
    		title,
    		iconDescription,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class NotificationButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
    			notificationType: 0,
    			renderIcon: 1,
    			title: 2,
    			iconDescription: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotificationButton",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get notificationType() {
    		throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificationType(value) {
    		throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderIcon() {
    		throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderIcon(value) {
    		throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDescription() {
    		throw new Error("<NotificationButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDescription(value) {
    		throw new Error("<NotificationButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/CheckmarkFilled20/CheckmarkFilled20.svelte generated by Svelte v3.29.0 */

    const file$a = "node_modules/carbon-icons-svelte/lib/CheckmarkFilled20/CheckmarkFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$9(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$a, 39, 6, 1231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$4(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$4.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$4(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "CheckmarkFilled20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 20 20" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
    			add_location(path0, file$a, 36, 2, 955);
    			attr_dev(path1, "fill", "none");
    			attr_dev(path1, "d", "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			attr_dev(path1, "opacity", "0");
    			add_location(path1, file$a, 36, 124, 1077);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$a, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "CheckmarkFilled20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 20 20" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CheckmarkFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class CheckmarkFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CheckmarkFilled20",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get class() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CheckmarkFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CheckmarkFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/ErrorFilled20/ErrorFilled20.svelte generated by Svelte v3.29.0 */

    const file$b = "node_modules/carbon-icons-svelte/lib/ErrorFilled20/ErrorFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$a(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$b, 39, 6, 1173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$5(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$5.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$5(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "ErrorFilled20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 20 20" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
    			add_location(path0, file$b, 36, 2, 951);
    			attr_dev(path1, "d", "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			attr_dev(path1, "opacity", "0");
    			add_location(path1, file$b, 36, 100, 1049);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$b, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "ErrorFilled20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 20 20" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ErrorFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class ErrorFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ErrorFilled20",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get class() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ErrorFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ErrorFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/InformationFilled20/InformationFilled20.svelte generated by Svelte v3.29.0 */

    const file$c = "node_modules/carbon-icons-svelte/lib/InformationFilled20/InformationFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$b(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$c, 39, 6, 1315);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$6(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$6.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$6(ctx);

    	let svg_levels = [
    		{
    			"data-carbon-icon": "InformationFilled20"
    		},
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.125h-8v-2.25h2.875v-6.75h-1.875v-2.25h4.125v9h2.875Z");
    			add_location(path0, file$c, 36, 2, 957);
    			attr_dev(path1, "fill", "none");
    			attr_dev(path1, "d", "M16,7a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17.125h-8v-2.25h2.875v-6.75h-1.875v-2.25h4.125v9h2.875Z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			add_location(path1, file$c, 36, 165, 1120);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$c, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{
    					"data-carbon-icon": "InformationFilled20"
    				},
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InformationFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class InformationFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InformationFilled20",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get class() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<InformationFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<InformationFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/InformationSquareFilled20/InformationSquareFilled20.svelte generated by Svelte v3.29.0 */

    const file$d = "node_modules/carbon-icons-svelte/lib/InformationSquareFilled20/InformationSquareFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$c(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$d, 39, 6, 1297);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$7(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$7.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$7(ctx);

    	let svg_levels = [
    		{
    			"data-carbon-icon": "InformationSquareFilled20"
    		},
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,7a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,7Zm4,17H12V22h3V15H13V13h4v9h3Z");
    			add_location(path0, file$d, 36, 2, 963);
    			attr_dev(path1, "fill", "none");
    			attr_dev(path1, "d", "M20,22v2H12V22h3V15H13V13h4v9ZM16,7a1.5,1.5,0,1,0,1.5,1.5A1.5,1.5,0,0,0,16,7Z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			add_location(path1, file$d, 36, 169, 1130);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$d, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{
    					"data-carbon-icon": "InformationSquareFilled20"
    				},
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InformationSquareFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class InformationSquareFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InformationSquareFilled20",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get class() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<InformationSquareFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<InformationSquareFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/WarningFilled20/WarningFilled20.svelte generated by Svelte v3.29.0 */

    const file$e = "node_modules/carbon-icons-svelte/lib/WarningFilled20/WarningFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$d(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$e, 39, 6, 1264);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$8(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$8.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$8(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "WarningFilled20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 20 20" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z");
    			add_location(path0, file$e, 36, 2, 953);
    			attr_dev(path1, "d", "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			attr_dev(path1, "opacity", "0");
    			add_location(path1, file$e, 36, 145, 1096);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$e, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "WarningFilled20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 20 20" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WarningFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class WarningFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WarningFilled20",
    			options,
    			id: create_fragment$h.name
    		});
    	}

    	get class() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<WarningFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<WarningFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/WarningAltFilled20/WarningAltFilled20.svelte generated by Svelte v3.29.0 */

    const file$f = "node_modules/carbon-icons-svelte/lib/WarningAltFilled20/WarningAltFilled20.svelte";

    // (39:4) {#if title}
    function create_if_block$e(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$f, 39, 6, 1348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$9(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$9.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$9(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "WarningAltFilled20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M29.879,27.5212l-13-25.0363a1.04,1.04,0,0,0-1.7583,0l-13,25.0363A1.0015,1.0015,0,0,0,3,29H29a1.001,1.001,0,0,0,.8789-1.4788ZM14.8751,10.0086h2.25V20h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z");
    			add_location(path0, file$f, 36, 2, 956);
    			attr_dev(path1, "fill", "none");
    			attr_dev(path1, "d", "M14.8751,10.0086h2.25V20h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z");
    			attr_dev(path1, "data-icon-path", "inner-path");
    			add_location(path1, file$f, 36, 224, 1178);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$f, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "WarningAltFilled20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("WarningAltFilled20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class WarningAltFilled20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WarningAltFilled20",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get class() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<WarningAltFilled20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<WarningAltFilled20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Notification/NotificationIcon.svelte generated by Svelte v3.29.0 */

    function create_fragment$j(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*icons*/ ctx[3][/*kind*/ ctx[0]];

    	function switch_props(ctx) {
    		return {
    			props: {
    				title: /*iconDescription*/ ctx[2],
    				class: "bx--" + /*notificationType*/ ctx[1] + "-notification__icon"
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*iconDescription*/ 4) switch_instance_changes.title = /*iconDescription*/ ctx[2];
    			if (dirty & /*notificationType*/ 2) switch_instance_changes.class = "bx--" + /*notificationType*/ ctx[1] + "-notification__icon";

    			if (switch_value !== (switch_value = /*icons*/ ctx[3][/*kind*/ ctx[0]])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotificationIcon", slots, []);
    	let { kind = "error" } = $$props;
    	let { notificationType = "toast" } = $$props;
    	let { iconDescription = "Closes notification" } = $$props;

    	const icons = {
    		error: ErrorFilled20,
    		"info-square": InformationSquareFilled20,
    		info: InformationFilled20,
    		success: CheckmarkFilled20,
    		warning: WarningFilled20,
    		"warning-alt": WarningAltFilled20
    	};

    	const writable_props = ["kind", "notificationType", "iconDescription"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NotificationIcon> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("kind" in $$props) $$invalidate(0, kind = $$props.kind);
    		if ("notificationType" in $$props) $$invalidate(1, notificationType = $$props.notificationType);
    		if ("iconDescription" in $$props) $$invalidate(2, iconDescription = $$props.iconDescription);
    	};

    	$$self.$capture_state = () => ({
    		kind,
    		notificationType,
    		iconDescription,
    		CheckmarkFilled20,
    		ErrorFilled20,
    		InformationFilled20,
    		InformationSquareFilled20,
    		WarningFilled20,
    		WarningAltFilled20,
    		icons
    	});

    	$$self.$inject_state = $$props => {
    		if ("kind" in $$props) $$invalidate(0, kind = $$props.kind);
    		if ("notificationType" in $$props) $$invalidate(1, notificationType = $$props.notificationType);
    		if ("iconDescription" in $$props) $$invalidate(2, iconDescription = $$props.iconDescription);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [kind, notificationType, iconDescription, icons];
    }

    class NotificationIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			kind: 0,
    			notificationType: 1,
    			iconDescription: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotificationIcon",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get kind() {
    		throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kind(value) {
    		throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notificationType() {
    		throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificationType(value) {
    		throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDescription() {
    		throw new Error("<NotificationIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDescription(value) {
    		throw new Error("<NotificationIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Notification/NotificationTextDetails.svelte generated by Svelte v3.29.0 */

    const file$g = "node_modules/carbon-components-svelte/src/Notification/NotificationTextDetails.svelte";

    // (27:0) {#if notificationType === 'toast'}
    function create_if_block_1$2(ctx) {
    	let div2;
    	let h3;
    	let t0;
    	let t1;
    	let div0;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let t5;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			h3 = element("h3");
    			t0 = text(/*title*/ ctx[1]);
    			t1 = space();
    			div0 = element("div");
    			t2 = text(/*subtitle*/ ctx[2]);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(/*caption*/ ctx[3]);
    			t5 = space();
    			if (default_slot) default_slot.c();
    			toggle_class(h3, "bx--toast-notification__title", true);
    			add_location(h3, file$g, 28, 4, 590);
    			toggle_class(div0, "bx--toast-notification__subtitle", true);
    			add_location(div0, file$g, 29, 4, 656);
    			toggle_class(div1, "bx--toast-notification__caption", true);
    			add_location(div1, file$g, 30, 4, 730);
    			toggle_class(div2, "bx--toast-notification__details", true);
    			add_location(div2, file$g, 27, 2, 533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, h3);
    			append_dev(h3, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);

    			if (default_slot) {
    				default_slot.m(div2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*title*/ 2) set_data_dev(t0, /*title*/ ctx[1]);
    			if (!current || dirty & /*subtitle*/ 4) set_data_dev(t2, /*subtitle*/ ctx[2]);
    			if (!current || dirty & /*caption*/ 8) set_data_dev(t4, /*caption*/ ctx[3]);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(27:0) {#if notificationType === 'toast'}",
    		ctx
    	});

    	return block;
    }

    // (36:0) {#if notificationType === 'inline'}
    function create_if_block$f(ctx) {
    	let div1;
    	let p;
    	let t0;
    	let t1;
    	let div0;
    	let t2;
    	let t3;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			p = element("p");
    			t0 = text(/*title*/ ctx[1]);
    			t1 = space();
    			div0 = element("div");
    			t2 = text(/*subtitle*/ ctx[2]);
    			t3 = space();
    			if (default_slot) default_slot.c();
    			toggle_class(p, "bx--inline-notification__title", true);
    			add_location(p, file$g, 37, 4, 928);
    			toggle_class(div0, "bx--inline-notification__subtitle", true);
    			add_location(div0, file$g, 38, 4, 993);
    			toggle_class(div1, "bx--inline-notification__text-wrapper", true);
    			add_location(div1, file$g, 36, 2, 865);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p);
    			append_dev(p, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, t2);
    			append_dev(div1, t3);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*title*/ 2) set_data_dev(t0, /*title*/ ctx[1]);
    			if (!current || dirty & /*subtitle*/ 4) set_data_dev(t2, /*subtitle*/ ctx[2]);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(36:0) {#if notificationType === 'inline'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*notificationType*/ ctx[0] === "toast" && create_if_block_1$2(ctx);
    	let if_block1 = /*notificationType*/ ctx[0] === "inline" && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*notificationType*/ ctx[0] === "toast") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*notificationType*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*notificationType*/ ctx[0] === "inline") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*notificationType*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotificationTextDetails", slots, ['default']);
    	let { notificationType = "toast" } = $$props;
    	let { title = "Title" } = $$props;
    	let { subtitle = "" } = $$props;
    	let { caption = "Caption" } = $$props;
    	const writable_props = ["notificationType", "title", "subtitle", "caption"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NotificationTextDetails> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("notificationType" in $$props) $$invalidate(0, notificationType = $$props.notificationType);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
    		if ("caption" in $$props) $$invalidate(3, caption = $$props.caption);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		notificationType,
    		title,
    		subtitle,
    		caption
    	});

    	$$self.$inject_state = $$props => {
    		if ("notificationType" in $$props) $$invalidate(0, notificationType = $$props.notificationType);
    		if ("title" in $$props) $$invalidate(1, title = $$props.title);
    		if ("subtitle" in $$props) $$invalidate(2, subtitle = $$props.subtitle);
    		if ("caption" in $$props) $$invalidate(3, caption = $$props.caption);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [notificationType, title, subtitle, caption, $$scope, slots];
    }

    class NotificationTextDetails extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			notificationType: 0,
    			title: 1,
    			subtitle: 2,
    			caption: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotificationTextDetails",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get notificationType() {
    		throw new Error("<NotificationTextDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificationType(value) {
    		throw new Error("<NotificationTextDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<NotificationTextDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<NotificationTextDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<NotificationTextDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<NotificationTextDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get caption() {
    		throw new Error("<NotificationTextDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set caption(value) {
    		throw new Error("<NotificationTextDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte generated by Svelte v3.29.0 */
    const file$h = "node_modules/carbon-components-svelte/src/Notification/InlineNotification.svelte";
    const get_actions_slot_changes = dirty => ({});
    const get_actions_slot_context = ctx => ({});

    // (82:0) {#if open}
    function create_if_block$g(ctx) {
    	let div1;
    	let div0;
    	let notificationicon;
    	let t0;
    	let notificationtextdetails;
    	let t1;
    	let t2;
    	let div1_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	notificationicon = new NotificationIcon({
    			props: {
    				notificationType: /*notificationType*/ ctx[0],
    				kind: /*kind*/ ctx[1],
    				iconDescription: /*iconDescription*/ ctx[7]
    			},
    			$$inline: true
    		});

    	notificationtextdetails = new NotificationTextDetails({
    			props: {
    				title: /*title*/ ctx[4],
    				subtitle: /*subtitle*/ ctx[5],
    				notificationType: /*notificationType*/ ctx[0],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const actions_slot_template = /*#slots*/ ctx[12].actions;
    	const actions_slot = create_slot(actions_slot_template, ctx, /*$$scope*/ ctx[17], get_actions_slot_context);
    	let if_block = !/*hideCloseButton*/ ctx[6] && create_if_block_1$3(ctx);

    	let div1_levels = [
    		{ role: /*role*/ ctx[3] },
    		{ kind: /*kind*/ ctx[1] },
    		{
    			class: div1_class_value = /*kind*/ ctx[1] && `bx--inline-notification--${/*kind*/ ctx[1]}`
    		},
    		/*$$restProps*/ ctx[10]
    	];

    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(notificationicon.$$.fragment);
    			t0 = space();
    			create_component(notificationtextdetails.$$.fragment);
    			t1 = space();
    			if (actions_slot) actions_slot.c();
    			t2 = space();
    			if (if_block) if_block.c();
    			toggle_class(div0, "bx--inline-notification__details", true);
    			add_location(div0, file$h, 95, 4, 2230);
    			set_attributes(div1, div1_data);
    			toggle_class(div1, "bx--inline-notification", true);
    			toggle_class(div1, "bx--inline-notification--low-contrast", /*lowContrast*/ ctx[2]);
    			toggle_class(div1, "bx--inline-notification--hide-close-button", /*hideCloseButton*/ ctx[6]);
    			add_location(div1, file$h, 82, 2, 1857);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(notificationicon, div0, null);
    			append_dev(div0, t0);
    			mount_component(notificationtextdetails, div0, null);
    			append_dev(div1, t1);

    			if (actions_slot) {
    				actions_slot.m(div1, null);
    			}

    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*click_handler*/ ctx[13], false, false, false),
    					listen_dev(div1, "mouseover", /*mouseover_handler*/ ctx[14], false, false, false),
    					listen_dev(div1, "mouseenter", /*mouseenter_handler*/ ctx[15], false, false, false),
    					listen_dev(div1, "mouseleave", /*mouseleave_handler*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const notificationicon_changes = {};
    			if (dirty & /*notificationType*/ 1) notificationicon_changes.notificationType = /*notificationType*/ ctx[0];
    			if (dirty & /*kind*/ 2) notificationicon_changes.kind = /*kind*/ ctx[1];
    			if (dirty & /*iconDescription*/ 128) notificationicon_changes.iconDescription = /*iconDescription*/ ctx[7];
    			notificationicon.$set(notificationicon_changes);
    			const notificationtextdetails_changes = {};
    			if (dirty & /*title*/ 16) notificationtextdetails_changes.title = /*title*/ ctx[4];
    			if (dirty & /*subtitle*/ 32) notificationtextdetails_changes.subtitle = /*subtitle*/ ctx[5];
    			if (dirty & /*notificationType*/ 1) notificationtextdetails_changes.notificationType = /*notificationType*/ ctx[0];

    			if (dirty & /*$$scope*/ 131072) {
    				notificationtextdetails_changes.$$scope = { dirty, ctx };
    			}

    			notificationtextdetails.$set(notificationtextdetails_changes);

    			if (actions_slot) {
    				if (actions_slot.p && dirty & /*$$scope*/ 131072) {
    					update_slot(actions_slot, actions_slot_template, ctx, /*$$scope*/ ctx[17], dirty, get_actions_slot_changes, get_actions_slot_context);
    				}
    			}

    			if (!/*hideCloseButton*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hideCloseButton*/ 64) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty & /*role*/ 8) && { role: /*role*/ ctx[3] },
    				(!current || dirty & /*kind*/ 2) && { kind: /*kind*/ ctx[1] },
    				(!current || dirty & /*kind*/ 2 && div1_class_value !== (div1_class_value = /*kind*/ ctx[1] && `bx--inline-notification--${/*kind*/ ctx[1]}`)) && { class: div1_class_value },
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10]
    			]));

    			toggle_class(div1, "bx--inline-notification", true);
    			toggle_class(div1, "bx--inline-notification--low-contrast", /*lowContrast*/ ctx[2]);
    			toggle_class(div1, "bx--inline-notification--hide-close-button", /*hideCloseButton*/ ctx[6]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notificationicon.$$.fragment, local);
    			transition_in(notificationtextdetails.$$.fragment, local);
    			transition_in(actions_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notificationicon.$$.fragment, local);
    			transition_out(notificationtextdetails.$$.fragment, local);
    			transition_out(actions_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(notificationicon);
    			destroy_component(notificationtextdetails);
    			if (actions_slot) actions_slot.d(detaching);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(82:0) {#if open}",
    		ctx
    	});

    	return block;
    }

    // (102:6) <NotificationTextDetails         title="{title}"         subtitle="{subtitle}"         notificationType="{notificationType}"       >
    function create_default_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 131072) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(102:6) <NotificationTextDetails         title=\\\"{title}\\\"         subtitle=\\\"{subtitle}\\\"         notificationType=\\\"{notificationType}\\\"       >",
    		ctx
    	});

    	return block;
    }

    // (111:4) {#if !hideCloseButton}
    function create_if_block_1$3(ctx) {
    	let notificationbutton;
    	let current;

    	notificationbutton = new NotificationButton({
    			props: {
    				iconDescription: /*iconDescription*/ ctx[7],
    				notificationType: /*notificationType*/ ctx[0]
    			},
    			$$inline: true
    		});

    	notificationbutton.$on("click", /*close*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(notificationbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notificationbutton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notificationbutton_changes = {};
    			if (dirty & /*iconDescription*/ 128) notificationbutton_changes.iconDescription = /*iconDescription*/ ctx[7];
    			if (dirty & /*notificationType*/ 1) notificationbutton_changes.notificationType = /*notificationType*/ ctx[0];
    			notificationbutton.$set(notificationbutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notificationbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notificationbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notificationbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(111:4) {#if !hideCloseButton}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*open*/ ctx[8] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*open*/ ctx[8]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*open*/ 256) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"notificationType","kind","lowContrast","timeout","role","title","subtitle","hideCloseButton","iconDescription"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InlineNotification", slots, ['default','actions']);
    	let { notificationType = "inline" } = $$props;
    	let { kind = "error" } = $$props;
    	let { lowContrast = false } = $$props;
    	let { timeout = 0 } = $$props;
    	let { role = "alert" } = $$props;
    	let { title = "Title" } = $$props;
    	let { subtitle = "" } = $$props;
    	let { hideCloseButton = false } = $$props;
    	let { iconDescription = "Closes notification" } = $$props;
    	const dispatch = createEventDispatcher();
    	let open = true;
    	let timeoutId = undefined;

    	function close() {
    		$$invalidate(8, open = false);
    		dispatch("close");
    	}

    	onMount(() => {
    		if (timeout) {
    			timeoutId = setTimeout(() => close(), timeout);
    		}

    		return () => {
    			clearTimeout(timeoutId);
    		};
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("notificationType" in $$new_props) $$invalidate(0, notificationType = $$new_props.notificationType);
    		if ("kind" in $$new_props) $$invalidate(1, kind = $$new_props.kind);
    		if ("lowContrast" in $$new_props) $$invalidate(2, lowContrast = $$new_props.lowContrast);
    		if ("timeout" in $$new_props) $$invalidate(11, timeout = $$new_props.timeout);
    		if ("role" in $$new_props) $$invalidate(3, role = $$new_props.role);
    		if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
    		if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ("hideCloseButton" in $$new_props) $$invalidate(6, hideCloseButton = $$new_props.hideCloseButton);
    		if ("iconDescription" in $$new_props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		notificationType,
    		kind,
    		lowContrast,
    		timeout,
    		role,
    		title,
    		subtitle,
    		hideCloseButton,
    		iconDescription,
    		createEventDispatcher,
    		onMount,
    		NotificationIcon,
    		NotificationTextDetails,
    		NotificationButton,
    		dispatch,
    		open,
    		timeoutId,
    		close
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("notificationType" in $$props) $$invalidate(0, notificationType = $$new_props.notificationType);
    		if ("kind" in $$props) $$invalidate(1, kind = $$new_props.kind);
    		if ("lowContrast" in $$props) $$invalidate(2, lowContrast = $$new_props.lowContrast);
    		if ("timeout" in $$props) $$invalidate(11, timeout = $$new_props.timeout);
    		if ("role" in $$props) $$invalidate(3, role = $$new_props.role);
    		if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
    		if ("subtitle" in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
    		if ("hideCloseButton" in $$props) $$invalidate(6, hideCloseButton = $$new_props.hideCloseButton);
    		if ("iconDescription" in $$props) $$invalidate(7, iconDescription = $$new_props.iconDescription);
    		if ("open" in $$props) $$invalidate(8, open = $$new_props.open);
    		if ("timeoutId" in $$props) timeoutId = $$new_props.timeoutId;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		notificationType,
    		kind,
    		lowContrast,
    		role,
    		title,
    		subtitle,
    		hideCloseButton,
    		iconDescription,
    		open,
    		close,
    		$$restProps,
    		timeout,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		$$scope
    	];
    }

    class InlineNotification extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			notificationType: 0,
    			kind: 1,
    			lowContrast: 2,
    			timeout: 11,
    			role: 3,
    			title: 4,
    			subtitle: 5,
    			hideCloseButton: 6,
    			iconDescription: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InlineNotification",
    			options,
    			id: create_fragment$l.name
    		});
    	}

    	get notificationType() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificationType(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get kind() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set kind(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowContrast() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowContrast(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get timeout() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set timeout(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get role() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set role(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideCloseButton() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideCloseButton(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDescription() {
    		throw new Error("<InlineNotification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDescription(value) {
    		throw new Error("<InlineNotification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Select/Select.svelte generated by Svelte v3.29.0 */
    const file$i = "node_modules/carbon-components-svelte/src/Select/Select.svelte";

    // (113:4) {#if !noLabel}
    function create_if_block_8(ctx) {
    	let label;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(/*labelText*/ ctx[11]);
    			attr_dev(label, "for", /*id*/ ctx[5]);
    			toggle_class(label, "bx--label", true);
    			toggle_class(label, "bx--visually-hidden", /*hideLabel*/ ctx[12]);
    			toggle_class(label, "bx--label--disabled", /*disabled*/ ctx[4]);
    			add_location(label, file$i, 113, 6, 2574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labelText*/ 2048) set_data_dev(t, /*labelText*/ ctx[11]);

    			if (dirty & /*id*/ 32) {
    				attr_dev(label, "for", /*id*/ ctx[5]);
    			}

    			if (dirty & /*hideLabel*/ 4096) {
    				toggle_class(label, "bx--visually-hidden", /*hideLabel*/ ctx[12]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				toggle_class(label, "bx--label--disabled", /*disabled*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(113:4) {#if !noLabel}",
    		ctx
    	});

    	return block;
    }

    // (123:4) {#if inline}
    function create_if_block_4$1(ctx) {
    	let div1;
    	let div0;
    	let select;
    	let select_aria_describedby_value;
    	let select_aria_invalid_value;
    	let select_disabled_value;
    	let select_class_value;
    	let t0;
    	let chevrondown16;
    	let t1;
    	let div0_data_invalid_value;
    	let t2;
    	let t3;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	chevrondown16 = new ChevronDown16({
    			props: { class: "bx--select__arrow" },
    			$$inline: true
    		});

    	let if_block0 = /*invalid*/ ctx[7] && create_if_block_7(ctx);
    	let if_block1 = /*invalid*/ ctx[7] && create_if_block_6$1(ctx);
    	let if_block2 = /*helperText*/ ctx[9] && create_if_block_5$1(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			create_component(chevrondown16.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/ ctx[7] ? /*errorId*/ ctx[13] : undefined);
    			attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/ ctx[7] || undefined);
    			select.disabled = select_disabled_value = /*disabled*/ ctx[4] || undefined;
    			attr_dev(select, "id", /*id*/ ctx[5]);
    			attr_dev(select, "name", /*name*/ ctx[6]);
    			attr_dev(select, "class", select_class_value = /*size*/ ctx[1] && `bx--select-input--${/*size*/ ctx[1]}`);
    			toggle_class(select, "bx--select-input", true);
    			add_location(select, file$i, 128, 10, 2991);
    			attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/ ctx[7] || undefined);
    			toggle_class(div0, "bx--select-input__wrapper", true);
    			add_location(div0, file$i, 124, 8, 2867);
    			toggle_class(div1, "bx--select-input--inline__wrapper", true);
    			add_location(div1, file$i, 123, 6, 2804);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, select);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			/*select_binding*/ ctx[21](select);
    			append_dev(div0, t0);
    			mount_component(chevrondown16, div0, null);
    			append_dev(div0, t1);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*change_handler*/ ctx[22], false, false, false),
    					listen_dev(select, "blur", /*blur_handler*/ ctx[20], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 131072) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*invalid, errorId*/ 8320 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/ ctx[7] ? /*errorId*/ ctx[13] : undefined)) {
    				attr_dev(select, "aria-describedby", select_aria_describedby_value);
    			}

    			if (!current || dirty & /*invalid*/ 128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/ ctx[7] || undefined)) {
    				attr_dev(select, "aria-invalid", select_aria_invalid_value);
    			}

    			if (!current || dirty & /*disabled*/ 16 && select_disabled_value !== (select_disabled_value = /*disabled*/ ctx[4] || undefined)) {
    				prop_dev(select, "disabled", select_disabled_value);
    			}

    			if (!current || dirty & /*id*/ 32) {
    				attr_dev(select, "id", /*id*/ ctx[5]);
    			}

    			if (!current || dirty & /*name*/ 64) {
    				attr_dev(select, "name", /*name*/ ctx[6]);
    			}

    			if (!current || dirty & /*size*/ 2 && select_class_value !== (select_class_value = /*size*/ ctx[1] && `bx--select-input--${/*size*/ ctx[1]}`)) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty & /*size*/ 2) {
    				toggle_class(select, "bx--select-input", true);
    			}

    			if (/*invalid*/ ctx[7]) {
    				if (if_block0) {
    					if (dirty & /*invalid*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*invalid*/ 128 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/ ctx[7] || undefined)) {
    				attr_dev(div0, "data-invalid", div0_data_invalid_value);
    			}

    			if (/*invalid*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$1(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*helperText*/ ctx[9]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_5$1(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(chevrondown16.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(chevrondown16.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding*/ ctx[21](null);
    			destroy_component(chevrondown16);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(123:4) {#if inline}",
    		ctx
    	});

    	return block;
    }

    // (146:10) {#if invalid}
    function create_if_block_7(ctx) {
    	let warningfilled16;
    	let current;

    	warningfilled16 = new WarningFilled16({
    			props: { class: "bx--select__invalid-icon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(warningfilled16.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(warningfilled16, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(warningfilled16.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(warningfilled16.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(warningfilled16, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(146:10) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    // (150:8) {#if invalid}
    function create_if_block_6$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*invalidText*/ ctx[8]);
    			attr_dev(div, "id", /*errorId*/ ctx[13]);
    			toggle_class(div, "bx--form-requirement", true);
    			add_location(div, file$i, 150, 10, 3723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*invalidText*/ 256) set_data_dev(t, /*invalidText*/ ctx[8]);

    			if (dirty & /*errorId*/ 8192) {
    				attr_dev(div, "id", /*errorId*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(150:8) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    // (156:6) {#if helperText}
    function create_if_block_5$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*helperText*/ ctx[9]);
    			toggle_class(div, "bx--form__helper-text", true);
    			toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[4]);
    			add_location(div, file$i, 156, 8, 3881);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*helperText*/ 512) set_data_dev(t, /*helperText*/ ctx[9]);

    			if (dirty & /*disabled*/ 16) {
    				toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(156:6) {#if helperText}",
    		ctx
    	});

    	return block;
    }

    // (165:4) {#if !inline}
    function create_if_block$h(ctx) {
    	let div;
    	let select;
    	let select_aria_describedby_value;
    	let select_disabled_value;
    	let select_aria_invalid_value;
    	let select_class_value;
    	let t0;
    	let chevrondown16;
    	let t1;
    	let div_data_invalid_value;
    	let t2;
    	let t3;
    	let if_block2_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	chevrondown16 = new ChevronDown16({
    			props: { class: "bx--select__arrow" },
    			$$inline: true
    		});

    	let if_block0 = /*invalid*/ ctx[7] && create_if_block_3$1(ctx);
    	let if_block1 = !/*invalid*/ ctx[7] && /*helperText*/ ctx[9] && create_if_block_2$1(ctx);
    	let if_block2 = /*invalid*/ ctx[7] && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			select = element("select");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			create_component(chevrondown16.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr_dev(select, "id", /*id*/ ctx[5]);
    			attr_dev(select, "name", /*name*/ ctx[6]);
    			attr_dev(select, "aria-describedby", select_aria_describedby_value = /*invalid*/ ctx[7] ? /*errorId*/ ctx[13] : undefined);
    			select.disabled = select_disabled_value = /*disabled*/ ctx[4] || undefined;
    			attr_dev(select, "aria-invalid", select_aria_invalid_value = /*invalid*/ ctx[7] || undefined);
    			attr_dev(select, "class", select_class_value = /*size*/ ctx[1] && `bx--select-input--${/*size*/ ctx[1]}`);
    			toggle_class(select, "bx--select-input", true);
    			add_location(select, file$i, 169, 8, 4204);
    			attr_dev(div, "data-invalid", div_data_invalid_value = /*invalid*/ ctx[7] || undefined);
    			toggle_class(div, "bx--select-input__wrapper", true);
    			add_location(div, file$i, 165, 6, 4088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, select);

    			if (default_slot) {
    				default_slot.m(select, null);
    			}

    			/*select_binding_1*/ ctx[23](select);
    			append_dev(div, t0);
    			mount_component(chevrondown16, div, null);
    			append_dev(div, t1);
    			if (if_block0) if_block0.m(div, null);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*change_handler_1*/ ctx[24], false, false, false),
    					listen_dev(select, "blur", /*blur_handler_1*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 131072) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*id*/ 32) {
    				attr_dev(select, "id", /*id*/ ctx[5]);
    			}

    			if (!current || dirty & /*name*/ 64) {
    				attr_dev(select, "name", /*name*/ ctx[6]);
    			}

    			if (!current || dirty & /*invalid, errorId*/ 8320 && select_aria_describedby_value !== (select_aria_describedby_value = /*invalid*/ ctx[7] ? /*errorId*/ ctx[13] : undefined)) {
    				attr_dev(select, "aria-describedby", select_aria_describedby_value);
    			}

    			if (!current || dirty & /*disabled*/ 16 && select_disabled_value !== (select_disabled_value = /*disabled*/ ctx[4] || undefined)) {
    				prop_dev(select, "disabled", select_disabled_value);
    			}

    			if (!current || dirty & /*invalid*/ 128 && select_aria_invalid_value !== (select_aria_invalid_value = /*invalid*/ ctx[7] || undefined)) {
    				attr_dev(select, "aria-invalid", select_aria_invalid_value);
    			}

    			if (!current || dirty & /*size*/ 2 && select_class_value !== (select_class_value = /*size*/ ctx[1] && `bx--select-input--${/*size*/ ctx[1]}`)) {
    				attr_dev(select, "class", select_class_value);
    			}

    			if (dirty & /*size*/ 2) {
    				toggle_class(select, "bx--select-input", true);
    			}

    			if (/*invalid*/ ctx[7]) {
    				if (if_block0) {
    					if (dirty & /*invalid*/ 128) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*invalid*/ 128 && div_data_invalid_value !== (div_data_invalid_value = /*invalid*/ ctx[7] || undefined)) {
    				attr_dev(div, "data-invalid", div_data_invalid_value);
    			}

    			if (!/*invalid*/ ctx[7] && /*helperText*/ ctx[9]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*invalid*/ ctx[7]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$4(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(chevrondown16.$$.fragment, local);
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(chevrondown16.$$.fragment, local);
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*select_binding_1*/ ctx[23](null);
    			destroy_component(chevrondown16);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(165:4) {#if !inline}",
    		ctx
    	});

    	return block;
    }

    // (187:8) {#if invalid}
    function create_if_block_3$1(ctx) {
    	let warningfilled16;
    	let current;

    	warningfilled16 = new WarningFilled16({
    			props: { class: "bx--select__invalid-icon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(warningfilled16.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(warningfilled16, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(warningfilled16.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(warningfilled16.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(warningfilled16, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(187:8) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    // (191:6) {#if !invalid && helperText}
    function create_if_block_2$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*helperText*/ ctx[9]);
    			toggle_class(div, "bx--form__helper-text", true);
    			toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[4]);
    			add_location(div, file$i, 191, 8, 4907);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*helperText*/ 512) set_data_dev(t, /*helperText*/ ctx[9]);

    			if (dirty & /*disabled*/ 16) {
    				toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(191:6) {#if !invalid && helperText}",
    		ctx
    	});

    	return block;
    }

    // (199:6) {#if invalid}
    function create_if_block_1$4(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*invalidText*/ ctx[8]);
    			attr_dev(div, "id", /*errorId*/ ctx[13]);
    			toggle_class(div, "bx--form-requirement", true);
    			add_location(div, file$i, 199, 8, 5108);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*invalidText*/ 256) set_data_dev(t, /*invalidText*/ ctx[8]);

    			if (dirty & /*errorId*/ 8192) {
    				attr_dev(div, "id", /*errorId*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(199:6) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let current;
    	let if_block0 = !/*noLabel*/ ctx[10] && create_if_block_8(ctx);
    	let if_block1 = /*inline*/ ctx[2] && create_if_block_4$1(ctx);
    	let if_block2 = !/*inline*/ ctx[2] && create_if_block$h(ctx);
    	let div1_levels = [/*$$restProps*/ ctx[15]];
    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			toggle_class(div0, "bx--select", true);
    			toggle_class(div0, "bx--select--inline", /*inline*/ ctx[2]);
    			toggle_class(div0, "bx--select--light", /*light*/ ctx[3]);
    			toggle_class(div0, "bx--select--invalid", /*invalid*/ ctx[7]);
    			toggle_class(div0, "bx--select--disabled", /*disabled*/ ctx[4]);
    			add_location(div0, file$i, 105, 2, 2346);
    			set_attributes(div1, div1_data);
    			toggle_class(div1, "bx--form-item", true);
    			add_location(div1, file$i, 104, 0, 2292);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block2) if_block2.m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*noLabel*/ ctx[10]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*inline*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*inline*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*inline*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*inline*/ 4) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$h(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*inline*/ 4) {
    				toggle_class(div0, "bx--select--inline", /*inline*/ ctx[2]);
    			}

    			if (dirty & /*light*/ 8) {
    				toggle_class(div0, "bx--select--light", /*light*/ ctx[3]);
    			}

    			if (dirty & /*invalid*/ 128) {
    				toggle_class(div0, "bx--select--invalid", /*invalid*/ ctx[7]);
    			}

    			if (dirty & /*disabled*/ 16) {
    				toggle_class(div0, "bx--select--disabled", /*disabled*/ ctx[4]);
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [dirty & /*$$restProps*/ 32768 && /*$$restProps*/ ctx[15]]));
    			toggle_class(div1, "bx--form-item", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"selected","size","inline","light","disabled","id","name","invalid","invalidText","helperText","noLabel","labelText","hideLabel","ref"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $selectedValue;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select", slots, ['default']);
    	let { selected = undefined } = $$props;
    	let { size = undefined } = $$props;
    	let { inline = false } = $$props;
    	let { light = false } = $$props;
    	let { disabled = false } = $$props;
    	let { id = "ccs-" + Math.random().toString(36) } = $$props;
    	let { name = undefined } = $$props;
    	let { invalid = false } = $$props;
    	let { invalidText = "" } = $$props;
    	let { helperText = "" } = $$props;
    	let { noLabel = false } = $$props;
    	let { labelText = "" } = $$props;
    	let { hideLabel = false } = $$props;
    	let { ref = null } = $$props;
    	const dispatch = createEventDispatcher();
    	const selectedValue = writable(selected);
    	validate_store(selectedValue, "selectedValue");
    	component_subscribe($$self, selectedValue, value => $$invalidate(25, $selectedValue = value));
    	setContext("Select", { selectedValue });

    	afterUpdate(() => {
    		$$invalidate(16, selected = $selectedValue);
    		dispatch("change", $selectedValue);
    	});

    	function blur_handler_1(event) {
    		bubble($$self, event);
    	}

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function select_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	const change_handler = ({ target }) => {
    		selectedValue.set(target.value);
    	};

    	function select_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	const change_handler_1 = ({ target }) => {
    		selectedValue.set(target.value);
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("selected" in $$new_props) $$invalidate(16, selected = $$new_props.selected);
    		if ("size" in $$new_props) $$invalidate(1, size = $$new_props.size);
    		if ("inline" in $$new_props) $$invalidate(2, inline = $$new_props.inline);
    		if ("light" in $$new_props) $$invalidate(3, light = $$new_props.light);
    		if ("disabled" in $$new_props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    		if ("name" in $$new_props) $$invalidate(6, name = $$new_props.name);
    		if ("invalid" in $$new_props) $$invalidate(7, invalid = $$new_props.invalid);
    		if ("invalidText" in $$new_props) $$invalidate(8, invalidText = $$new_props.invalidText);
    		if ("helperText" in $$new_props) $$invalidate(9, helperText = $$new_props.helperText);
    		if ("noLabel" in $$new_props) $$invalidate(10, noLabel = $$new_props.noLabel);
    		if ("labelText" in $$new_props) $$invalidate(11, labelText = $$new_props.labelText);
    		if ("hideLabel" in $$new_props) $$invalidate(12, hideLabel = $$new_props.hideLabel);
    		if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    		if ("$$scope" in $$new_props) $$invalidate(17, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		selected,
    		size,
    		inline,
    		light,
    		disabled,
    		id,
    		name,
    		invalid,
    		invalidText,
    		helperText,
    		noLabel,
    		labelText,
    		hideLabel,
    		ref,
    		createEventDispatcher,
    		setContext,
    		afterUpdate,
    		writable,
    		ChevronDown16,
    		WarningFilled16,
    		dispatch,
    		selectedValue,
    		$selectedValue,
    		errorId
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("selected" in $$props) $$invalidate(16, selected = $$new_props.selected);
    		if ("size" in $$props) $$invalidate(1, size = $$new_props.size);
    		if ("inline" in $$props) $$invalidate(2, inline = $$new_props.inline);
    		if ("light" in $$props) $$invalidate(3, light = $$new_props.light);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$new_props.disabled);
    		if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    		if ("name" in $$props) $$invalidate(6, name = $$new_props.name);
    		if ("invalid" in $$props) $$invalidate(7, invalid = $$new_props.invalid);
    		if ("invalidText" in $$props) $$invalidate(8, invalidText = $$new_props.invalidText);
    		if ("helperText" in $$props) $$invalidate(9, helperText = $$new_props.helperText);
    		if ("noLabel" in $$props) $$invalidate(10, noLabel = $$new_props.noLabel);
    		if ("labelText" in $$props) $$invalidate(11, labelText = $$new_props.labelText);
    		if ("hideLabel" in $$props) $$invalidate(12, hideLabel = $$new_props.hideLabel);
    		if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    		if ("errorId" in $$props) $$invalidate(13, errorId = $$new_props.errorId);
    	};

    	let errorId;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*id*/ 32) {
    			 $$invalidate(13, errorId = `error-${id}`);
    		}

    		if ($$self.$$.dirty & /*selected*/ 65536) {
    			 selectedValue.set(selected);
    		}
    	};

    	return [
    		ref,
    		size,
    		inline,
    		light,
    		disabled,
    		id,
    		name,
    		invalid,
    		invalidText,
    		helperText,
    		noLabel,
    		labelText,
    		hideLabel,
    		errorId,
    		selectedValue,
    		$$restProps,
    		selected,
    		$$scope,
    		slots,
    		blur_handler_1,
    		blur_handler,
    		select_binding,
    		change_handler,
    		select_binding_1,
    		change_handler_1
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			selected: 16,
    			size: 1,
    			inline: 2,
    			light: 3,
    			disabled: 4,
    			id: 5,
    			name: 6,
    			invalid: 7,
    			invalidText: 8,
    			helperText: 9,
    			noLabel: 10,
    			labelText: 11,
    			hideLabel: 12,
    			ref: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get selected() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get size() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inline() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inline(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalidText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalidText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get helperText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set helperText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Select/SelectItem.svelte generated by Svelte v3.29.0 */
    const file$j = "node_modules/carbon-components-svelte/src/Select/SelectItem.svelte";

    function create_fragment$n(ctx) {
    	let option;
    	let t_value = (/*text*/ ctx[1] || /*value*/ ctx[0]) + "";
    	let t;
    	let option_class_value;
    	let option_style_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = /*value*/ ctx[0];
    			option.value = option.__value;
    			option.disabled = /*disabled*/ ctx[3];
    			option.hidden = /*hidden*/ ctx[2];
    			option.selected = /*selected*/ ctx[4];
    			attr_dev(option, "class", option_class_value = /*$$restProps*/ ctx[5].class);
    			attr_dev(option, "style", option_style_value = /*$$restProps*/ ctx[5].style);
    			toggle_class(option, "bx--select-option", true);
    			add_location(option, file$j, 40, 0, 740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text, value*/ 3 && t_value !== (t_value = (/*text*/ ctx[1] || /*value*/ ctx[0]) + "")) set_data_dev(t, t_value);

    			if (dirty & /*value*/ 1) {
    				prop_dev(option, "__value", /*value*/ ctx[0]);
    				option.value = option.__value;
    			}

    			if (dirty & /*disabled*/ 8) {
    				prop_dev(option, "disabled", /*disabled*/ ctx[3]);
    			}

    			if (dirty & /*hidden*/ 4) {
    				prop_dev(option, "hidden", /*hidden*/ ctx[2]);
    			}

    			if (dirty & /*selected*/ 16) {
    				prop_dev(option, "selected", /*selected*/ ctx[4]);
    			}

    			if (dirty & /*$$restProps*/ 32 && option_class_value !== (option_class_value = /*$$restProps*/ ctx[5].class)) {
    				attr_dev(option, "class", option_class_value);
    			}

    			if (dirty & /*$$restProps*/ 32 && option_style_value !== (option_style_value = /*$$restProps*/ ctx[5].style)) {
    				attr_dev(option, "style", option_style_value);
    			}

    			if (dirty & /*$$restProps*/ 32) {
    				toggle_class(option, "bx--select-option", true);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	const omit_props_names = ["value","text","hidden","disabled"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectItem", slots, []);
    	let { value = "" } = $$props;
    	let { text = "" } = $$props;
    	let { hidden = false } = $$props;
    	let { disabled = false } = $$props;
    	const ctx = getContext("Select") || getContext("TimePickerSelect");
    	let selected = false;

    	const unsubscribe = ctx.selectedValue.subscribe($ => {
    		$$invalidate(4, selected = $ === value);
    	});

    	onDestroy(() => {
    		unsubscribe();
    	});

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ("text" in $$new_props) $$invalidate(1, text = $$new_props.text);
    		if ("hidden" in $$new_props) $$invalidate(2, hidden = $$new_props.hidden);
    		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		value,
    		text,
    		hidden,
    		disabled,
    		getContext,
    		onDestroy,
    		ctx,
    		selected,
    		unsubscribe
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    		if ("text" in $$props) $$invalidate(1, text = $$new_props.text);
    		if ("hidden" in $$props) $$invalidate(2, hidden = $$new_props.hidden);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ("selected" in $$props) $$invalidate(4, selected = $$new_props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, text, hidden, disabled, selected, $$restProps];
    }

    class SelectItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			value: 0,
    			text: 1,
    			hidden: 2,
    			disabled: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectItem",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get value() {
    		throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hidden() {
    		throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hidden(value) {
    		throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<SelectItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<SelectItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/ChevronDownGlyph/ChevronDownGlyph.svelte generated by Svelte v3.29.0 */

    const file$k = "node_modules/carbon-icons-svelte/lib/ChevronDownGlyph/ChevronDownGlyph.svelte";

    // (39:4) {#if title}
    function create_if_block$i(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$k, 39, 6, 1038);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$a(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$a.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$a(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "ChevronDownGlyph" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 10 6" },
    		{ fill: "currentColor" },
    		{ width: "10" },
    		{ height: "6" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M5 6L0 1 0.7 0.3 5 4.6 9.3 0.3 10 1z");
    			add_location(path, file$k, 36, 2, 952);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$k, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "ChevronDownGlyph" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 10 6" },
    				{ fill: "currentColor" },
    				{ width: "10" },
    				{ height: "6" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ChevronDownGlyph", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class ChevronDownGlyph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChevronDownGlyph",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get class() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ChevronDownGlyph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ChevronDownGlyph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte generated by Svelte v3.29.0 */
    const file$l = "node_modules/carbon-components-svelte/src/Tabs/Tabs.svelte";
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});

    // (138:6) {#if currentTab}
    function create_if_block$j(ctx) {
    	let t_value = /*currentTab*/ ctx[4].label + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentTab*/ 16 && t_value !== (t_value = /*currentTab*/ ctx[4].label + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(138:6) {#if currentTab}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div1;
    	let div0;
    	let a;
    	let t0;
    	let chevrondownglyph;
    	let div0_aria_label_value;
    	let t1;
    	let ul;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*currentTab*/ ctx[4] && create_if_block$j(ctx);

    	chevrondownglyph = new ChevronDownGlyph({
    			props: {
    				"aria-hidden": "true",
    				title: /*iconDescription*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
    	let div1_levels = [{ role: "navigation" }, /*$$restProps*/ ctx[9]];
    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign(div1_data, div1_levels[i]);
    	}

    	const content_slot_template = /*#slots*/ ctx[13].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[12], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			a = element("a");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(chevrondownglyph.$$.fragment);
    			t1 = space();
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			t2 = space();
    			if (content_slot) content_slot.c();
    			attr_dev(a, "tabindex", "-1");
    			attr_dev(a, "href", /*triggerHref*/ ctx[2]);
    			toggle_class(a, "bx--tabs-trigger-text", true);
    			add_location(a, file$l, 128, 4, 2978);
    			attr_dev(div0, "role", "listbox");
    			attr_dev(div0, "tabindex", "0");
    			attr_dev(div0, "aria-label", div0_aria_label_value = /*$$props*/ ctx[10]["aria-label"] || "listbox");
    			toggle_class(div0, "bx--tabs-trigger", true);
    			add_location(div0, file$l, 115, 2, 2678);
    			attr_dev(ul, "role", "tablist");
    			toggle_class(ul, "bx--tabs__nav", true);
    			toggle_class(ul, "bx--tabs__nav--hidden", /*dropdownHidden*/ ctx[3]);
    			add_location(ul, file$l, 141, 2, 3305);
    			set_attributes(div1, div1_data);
    			toggle_class(div1, "bx--tabs", true);
    			toggle_class(div1, "bx--tabs--container", /*type*/ ctx[0] === "container");
    			add_location(div1, file$l, 109, 0, 2551);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, a);
    			if (if_block) if_block.m(a, null);
    			append_dev(div0, t0);
    			mount_component(chevrondownglyph, div0, null);
    			append_dev(div1, t1);
    			append_dev(div1, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			insert_dev(target, t2, anchor);

    			if (content_slot) {
    				content_slot.m(target, anchor);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[15], false, false, false),
    					listen_dev(a, "click", /*click_handler_1*/ ctx[16], false, false, false),
    					listen_dev(div0, "click", /*click_handler_2*/ ctx[17], false, false, false),
    					listen_dev(div0, "keypress", /*keypress_handler*/ ctx[14], false, false, false),
    					listen_dev(div0, "keypress", /*keypress_handler_1*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*currentTab*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					if_block.m(a, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (!current || dirty & /*triggerHref*/ 4) {
    				attr_dev(a, "href", /*triggerHref*/ ctx[2]);
    			}

    			const chevrondownglyph_changes = {};
    			if (dirty & /*iconDescription*/ 2) chevrondownglyph_changes.title = /*iconDescription*/ ctx[1];
    			chevrondownglyph.$set(chevrondownglyph_changes);

    			if (!current || dirty & /*$$props*/ 1024 && div0_aria_label_value !== (div0_aria_label_value = /*$$props*/ ctx[10]["aria-label"] || "listbox")) {
    				attr_dev(div0, "aria-label", div0_aria_label_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, null, null);
    				}
    			}

    			if (dirty & /*dropdownHidden*/ 8) {
    				toggle_class(ul, "bx--tabs__nav--hidden", /*dropdownHidden*/ ctx[3]);
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				{ role: "navigation" },
    				dirty & /*$$restProps*/ 512 && /*$$restProps*/ ctx[9]
    			]));

    			toggle_class(div1, "bx--tabs", true);
    			toggle_class(div1, "bx--tabs--container", /*type*/ ctx[0] === "container");

    			if (content_slot) {
    				if (content_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(content_slot, content_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_content_slot_changes, get_content_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chevrondownglyph.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chevrondownglyph.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			destroy_component(chevrondownglyph);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (content_slot) content_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	const omit_props_names = ["selected","type","iconDescription","triggerHref"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $tabsById;
    	let $tabs;
    	let $content;
    	let $selectedTab;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabs", slots, ['default','content']);
    	let { selected = 0 } = $$props;
    	let { type = "default" } = $$props;
    	let { iconDescription = "Show menu options" } = $$props;
    	let { triggerHref = "#" } = $$props;
    	const dispatch = createEventDispatcher();
    	const tabs = writable([]);
    	validate_store(tabs, "tabs");
    	component_subscribe($$self, tabs, value => $$invalidate(21, $tabs = value));
    	const tabsById = derived(tabs, _ => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
    	validate_store(tabsById, "tabsById");
    	component_subscribe($$self, tabsById, value => $$invalidate(20, $tabsById = value));
    	const selectedTab = writable(undefined);
    	validate_store(selectedTab, "selectedTab");
    	component_subscribe($$self, selectedTab, value => $$invalidate(24, $selectedTab = value));
    	const content = writable([]);
    	validate_store(content, "content");
    	component_subscribe($$self, content, value => $$invalidate(23, $content = value));
    	const contentById = derived(content, _ => _.reduce((a, c) => ({ ...a, [c.id]: c }), {}));
    	const selectedContent = writable(undefined);

    	setContext("Tabs", {
    		tabs,
    		contentById,
    		selectedTab,
    		selectedContent,
    		add: data => {
    			tabs.update(_ => [..._, { ...data, index: _.length }]);
    		},
    		addContent: data => {
    			content.update(_ => [..._, { ...data, index: _.length }]);
    		},
    		update: id => {
    			$$invalidate(19, currentIndex = $tabsById[id].index);
    		},
    		change: direction => {
    			let index = currentIndex + direction;

    			if (index < 0) {
    				index = $tabs.length - 1;
    			} else if (index >= $tabs.length) {
    				index = 0;
    			}

    			let disabled = $tabs[index].disabled;

    			while (disabled) {
    				index = index + direction;

    				if (index < 0) {
    					index = $tabs.length - 1;
    				} else if (index >= $tabs.length) {
    					index = 0;
    				}

    				disabled = $tabs[index].disabled;
    			}

    			$$invalidate(19, currentIndex = index);
    		}
    	});

    	afterUpdate(() => {
    		$$invalidate(11, selected = currentIndex);
    	});

    	let dropdownHidden = true;
    	let currentIndex = selected;

    	function keypress_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	const click_handler_1 = () => {
    		$$invalidate(3, dropdownHidden = !dropdownHidden);
    	};

    	const click_handler_2 = () => {
    		$$invalidate(3, dropdownHidden = !dropdownHidden);
    	};

    	const keypress_handler_1 = () => {
    		$$invalidate(3, dropdownHidden = !dropdownHidden);
    	};

    	$$self.$$set = $$new_props => {
    		$$invalidate(10, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("selected" in $$new_props) $$invalidate(11, selected = $$new_props.selected);
    		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
    		if ("iconDescription" in $$new_props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    		if ("triggerHref" in $$new_props) $$invalidate(2, triggerHref = $$new_props.triggerHref);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		selected,
    		type,
    		iconDescription,
    		triggerHref,
    		createEventDispatcher,
    		afterUpdate,
    		setContext,
    		writable,
    		derived,
    		ChevronDownGlyph,
    		dispatch,
    		tabs,
    		tabsById,
    		selectedTab,
    		content,
    		contentById,
    		selectedContent,
    		dropdownHidden,
    		currentIndex,
    		$tabsById,
    		$tabs,
    		currentTab,
    		currentContent,
    		$content,
    		$selectedTab
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(10, $$props = assign(assign({}, $$props), $$new_props));
    		if ("selected" in $$props) $$invalidate(11, selected = $$new_props.selected);
    		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
    		if ("iconDescription" in $$props) $$invalidate(1, iconDescription = $$new_props.iconDescription);
    		if ("triggerHref" in $$props) $$invalidate(2, triggerHref = $$new_props.triggerHref);
    		if ("dropdownHidden" in $$props) $$invalidate(3, dropdownHidden = $$new_props.dropdownHidden);
    		if ("currentIndex" in $$props) $$invalidate(19, currentIndex = $$new_props.currentIndex);
    		if ("currentTab" in $$props) $$invalidate(4, currentTab = $$new_props.currentTab);
    		if ("currentContent" in $$props) $$invalidate(22, currentContent = $$new_props.currentContent);
    	};

    	let currentTab;
    	let currentContent;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected*/ 2048) {
    			 $$invalidate(19, currentIndex = selected);
    		}

    		if ($$self.$$.dirty & /*$tabs, currentIndex*/ 2621440) {
    			 $$invalidate(4, currentTab = $tabs[currentIndex] || undefined);
    		}

    		if ($$self.$$.dirty & /*$content, currentIndex*/ 8912896) {
    			 $$invalidate(22, currentContent = $content[currentIndex] || undefined);
    		}

    		if ($$self.$$.dirty & /*currentIndex, currentTab, currentContent*/ 4718608) {
    			 {
    				dispatch("change", currentIndex);

    				if (currentTab) {
    					selectedTab.set(currentTab.id);
    				}

    				if (currentContent) {
    					selectedContent.set(currentContent.id);
    				}
    			}
    		}

    		if ($$self.$$.dirty & /*$selectedTab*/ 16777216) {
    			 if ($selectedTab) {
    				$$invalidate(3, dropdownHidden = true);
    			}
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		type,
    		iconDescription,
    		triggerHref,
    		dropdownHidden,
    		currentTab,
    		tabs,
    		tabsById,
    		selectedTab,
    		content,
    		$$restProps,
    		$$props,
    		selected,
    		$$scope,
    		slots,
    		keypress_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		keypress_handler_1
    	];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			selected: 11,
    			type: 0,
    			iconDescription: 1,
    			triggerHref: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get selected() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconDescription() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconDescription(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get triggerHref() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set triggerHref(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tabs/Tab.svelte generated by Svelte v3.29.0 */
    const file$m = "node_modules/carbon-components-svelte/src/Tabs/Tab.svelte";

    // (88:10) {label}
    function fallback_block$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$b.name,
    		type: "fallback",
    		source: "(88:10) {label}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let li;
    	let a;
    	let a_tabindex_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[12].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
    	const default_slot_or_fallback = default_slot || fallback_block$b(ctx);
    	let li_levels = [{ tabindex: "-1" }, { role: "presentation" }, /*$$restProps*/ ctx[10]];
    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(a, "role", "tab");
    			attr_dev(a, "tabindex", a_tabindex_value = /*disabled*/ ctx[3] ? "-1" : /*tabindex*/ ctx[4]);
    			attr_dev(a, "aria-selected", /*selected*/ ctx[6]);
    			attr_dev(a, "aria-disabled", /*disabled*/ ctx[3]);
    			attr_dev(a, "id", /*id*/ ctx[5]);
    			attr_dev(a, "href", /*href*/ ctx[2]);
    			toggle_class(a, "bx--tabs__nav-link", true);
    			add_location(a, file$m, 77, 2, 1607);
    			set_attributes(li, li_data);
    			toggle_class(li, "bx--tabs__nav-item", true);
    			toggle_class(li, "bx--tabs__nav-item--disabled", /*disabled*/ ctx[3]);
    			toggle_class(li, "bx--tabs__nav-item--selected", /*selected*/ ctx[6]);
    			add_location(li, file$m, 50, 0, 1017);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			/*a_binding*/ ctx[16](a);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", prevent_default(/*click_handler*/ ctx[17]), false, true, false),
    					listen_dev(li, "mouseover", /*mouseover_handler*/ ctx[13], false, false, false),
    					listen_dev(li, "mouseenter", /*mouseenter_handler*/ ctx[14], false, false, false),
    					listen_dev(li, "mouseleave", /*mouseleave_handler*/ ctx[15], false, false, false),
    					listen_dev(li, "keydown", /*keydown_handler*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2048) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[11], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*label*/ 2) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*disabled, tabindex*/ 24 && a_tabindex_value !== (a_tabindex_value = /*disabled*/ ctx[3] ? "-1" : /*tabindex*/ ctx[4])) {
    				attr_dev(a, "tabindex", a_tabindex_value);
    			}

    			if (!current || dirty & /*selected*/ 64) {
    				attr_dev(a, "aria-selected", /*selected*/ ctx[6]);
    			}

    			if (!current || dirty & /*disabled*/ 8) {
    				attr_dev(a, "aria-disabled", /*disabled*/ ctx[3]);
    			}

    			if (!current || dirty & /*id*/ 32) {
    				attr_dev(a, "id", /*id*/ ctx[5]);
    			}

    			if (!current || dirty & /*href*/ 4) {
    				attr_dev(a, "href", /*href*/ ctx[2]);
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				{ tabindex: "-1" },
    				{ role: "presentation" },
    				dirty & /*$$restProps*/ 1024 && /*$$restProps*/ ctx[10]
    			]));

    			toggle_class(li, "bx--tabs__nav-item", true);
    			toggle_class(li, "bx--tabs__nav-item--disabled", /*disabled*/ ctx[3]);
    			toggle_class(li, "bx--tabs__nav-item--selected", /*selected*/ ctx[6]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			/*a_binding*/ ctx[16](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	const omit_props_names = ["label","href","disabled","tabindex","id","ref"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $selectedTab;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tab", slots, ['default']);
    	let { label = "" } = $$props;
    	let { href = "#" } = $$props;
    	let { disabled = false } = $$props;
    	let { tabindex = "0" } = $$props;
    	let { id = "ccs-" + Math.random().toString(36) } = $$props;
    	let { ref = null } = $$props;
    	const { selectedTab, add, update, change } = getContext("Tabs");
    	validate_store(selectedTab, "selectedTab");
    	component_subscribe($$self, selectedTab, value => $$invalidate(19, $selectedTab = value));
    	add({ id, label, disabled });

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	const click_handler = () => {
    		if (!disabled) {
    			update(id);
    		}
    	};

    	const keydown_handler = ({ key }) => {
    		if (!disabled) {
    			if (key === "ArrowRight") {
    				change(1);
    			} else if (key === "ArrowLeft") {
    				change(-1);
    			} else if (key === " " || key === "Enter") {
    				update(id);
    			}
    		}
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("label" in $$new_props) $$invalidate(1, label = $$new_props.label);
    		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ("disabled" in $$new_props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ("tabindex" in $$new_props) $$invalidate(4, tabindex = $$new_props.tabindex);
    		if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    		if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    		if ("$$scope" in $$new_props) $$invalidate(11, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		label,
    		href,
    		disabled,
    		tabindex,
    		id,
    		ref,
    		getContext,
    		selectedTab,
    		add,
    		update,
    		change,
    		selected,
    		$selectedTab
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("label" in $$props) $$invalidate(1, label = $$new_props.label);
    		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$new_props.disabled);
    		if ("tabindex" in $$props) $$invalidate(4, tabindex = $$new_props.tabindex);
    		if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    		if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    		if ("selected" in $$props) $$invalidate(6, selected = $$new_props.selected);
    	};

    	let selected;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$selectedTab, id*/ 524320) {
    			 $$invalidate(6, selected = $selectedTab === id);
    		}

    		if ($$self.$$.dirty & /*selected, ref*/ 65) {
    			 if (selected && ref) {
    				ref.focus();
    			}
    		}
    	};

    	return [
    		ref,
    		label,
    		href,
    		disabled,
    		tabindex,
    		id,
    		selected,
    		selectedTab,
    		update,
    		change,
    		$$restProps,
    		$$scope,
    		slots,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		a_binding,
    		click_handler,
    		keydown_handler
    	];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			label: 1,
    			href: 2,
    			disabled: 3,
    			tabindex: 4,
    			id: 5,
    			ref: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get label() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte generated by Svelte v3.29.0 */
    const file$n = "node_modules/carbon-components-svelte/src/Tabs/TabContent.svelte";

    function create_fragment$r(ctx) {
    	let div;
    	let div_aria_hidden_value;
    	let div_hidden_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let div_levels = [
    		{ role: "tabpanel" },
    		{ "aria-labelledby": /*tabId*/ ctx[2] },
    		{
    			"aria-hidden": div_aria_hidden_value = !/*selected*/ ctx[1]
    		},
    		{
    			hidden: div_hidden_value = /*selected*/ ctx[1] ? undefined : ""
    		},
    		{ id: /*id*/ ctx[0] },
    		/*$$restProps*/ ctx[6]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			toggle_class(div, "bx--tab-content", true);
    			add_location(div, file$n, 18, 0, 407);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				{ role: "tabpanel" },
    				(!current || dirty & /*tabId*/ 4) && { "aria-labelledby": /*tabId*/ ctx[2] },
    				(!current || dirty & /*selected*/ 2 && div_aria_hidden_value !== (div_aria_hidden_value = !/*selected*/ ctx[1])) && { "aria-hidden": div_aria_hidden_value },
    				(!current || dirty & /*selected*/ 2 && div_hidden_value !== (div_hidden_value = /*selected*/ ctx[1] ? undefined : "")) && { hidden: div_hidden_value },
    				(!current || dirty & /*id*/ 1) && { id: /*id*/ ctx[0] },
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
    			]));

    			toggle_class(div, "bx--tab-content", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	const omit_props_names = ["id"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $selectedContent;
    	let $contentById;
    	let $tabs;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TabContent", slots, ['default']);
    	let { id = "ccs-" + Math.random().toString(36) } = $$props;
    	const { selectedContent, addContent, tabs, contentById } = getContext("Tabs");
    	validate_store(selectedContent, "selectedContent");
    	component_subscribe($$self, selectedContent, value => $$invalidate(9, $selectedContent = value));
    	validate_store(tabs, "tabs");
    	component_subscribe($$self, tabs, value => $$invalidate(12, $tabs = value));
    	validate_store(contentById, "contentById");
    	component_subscribe($$self, contentById, value => $$invalidate(11, $contentById = value));
    	addContent({ id });

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		id,
    		getContext,
    		selectedContent,
    		addContent,
    		tabs,
    		contentById,
    		selected,
    		$selectedContent,
    		index,
    		$contentById,
    		tabId,
    		$tabs
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
    		if ("selected" in $$props) $$invalidate(1, selected = $$new_props.selected);
    		if ("index" in $$props) $$invalidate(10, index = $$new_props.index);
    		if ("tabId" in $$props) $$invalidate(2, tabId = $$new_props.tabId);
    	};

    	let selected;
    	let index;
    	let tabId;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$selectedContent, id*/ 513) {
    			 $$invalidate(1, selected = $selectedContent === id);
    		}

    		if ($$self.$$.dirty & /*$contentById, id*/ 2049) {
    			 $$invalidate(10, index = $contentById[id].index);
    		}

    		if ($$self.$$.dirty & /*$tabs, index*/ 5120) {
    			 $$invalidate(2, tabId = $tabs[index].id);
    		}
    	};

    	return [
    		id,
    		selected,
    		tabId,
    		selectedContent,
    		tabs,
    		contentById,
    		$$restProps,
    		$$scope,
    		slots
    	];
    }

    class TabContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TabContent",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get id() {
    		throw new Error("<TabContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TabContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tag/Tag.Skeleton.svelte generated by Svelte v3.29.0 */

    const file$o = "node_modules/carbon-components-svelte/src/Tag/Tag.Skeleton.svelte";

    function create_fragment$s(ctx) {
    	let span;
    	let mounted;
    	let dispose;
    	let span_levels = [/*$$restProps*/ ctx[0]];
    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			set_attributes(span, span_data);
    			toggle_class(span, "bx--tag", true);
    			toggle_class(span, "bx--skeleton", true);
    			add_location(span, file$o, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "click", /*click_handler*/ ctx[1], false, false, false),
    					listen_dev(span, "mouseover", /*mouseover_handler*/ ctx[2], false, false, false),
    					listen_dev(span, "mouseenter", /*mouseenter_handler*/ ctx[3], false, false, false),
    					listen_dev(span, "mouseleave", /*mouseleave_handler*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			set_attributes(span, span_data = get_spread_update(span_levels, [dirty & /*$$restProps*/ 1 && /*$$restProps*/ ctx[0]]));
    			toggle_class(span, "bx--tag", true);
    			toggle_class(span, "bx--skeleton", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	const omit_props_names = [];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tag_Skeleton", slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(0, $$restProps = compute_rest_props($$props, omit_props_names));
    	};

    	return [
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Tag_Skeleton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag_Skeleton",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tag/Tag.svelte generated by Svelte v3.29.0 */
    const file$p = "node_modules/carbon-components-svelte/src/Tag/Tag.svelte";
    const get_default_slot_changes$2 = dirty => ({});
    const get_default_slot_context$2 = ctx => ({ props: { class: "bx--tag__label" } });

    // (77:2) {:else}
    function create_else_block$4(ctx) {
    	let span;
    	let span_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	let span_levels = [
    		/*$$restProps*/ ctx[6],
    		{
    			class: span_class_value = "" + ((/*type*/ ctx[0] && `bx--tag--${/*type*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[6].class)
    		}
    	];

    	let span_data = {};

    	for (let i = 0; i < span_levels.length; i += 1) {
    		span_data = assign(span_data, span_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (default_slot) default_slot.c();
    			set_attributes(span, span_data);
    			toggle_class(span, "bx--tag", true);
    			toggle_class(span, "bx--tag--disabled", /*disabled*/ ctx[2]);
    			add_location(span, file$p, 77, 4, 1841);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (default_slot) {
    				default_slot.m(span, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "click", /*click_handler_2*/ ctx[13], false, false, false),
    					listen_dev(span, "mouseover", /*mouseover_handler_2*/ ctx[14], false, false, false),
    					listen_dev(span, "mouseenter", /*mouseenter_handler_2*/ ctx[15], false, false, false),
    					listen_dev(span, "mouseleave", /*mouseleave_handler_2*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			set_attributes(span, span_data = get_spread_update(span_levels, [
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*type, $$restProps*/ 65 && span_class_value !== (span_class_value = "" + ((/*type*/ ctx[0] && `bx--tag--${/*type*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[6].class))) && { class: span_class_value }
    			]));

    			toggle_class(span, "bx--tag", true);
    			toggle_class(span, "bx--tag--disabled", /*disabled*/ ctx[2]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(77:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:2) {#if filter}
    function create_if_block_1$5(ctx) {
    	let div;
    	let t;
    	let button;
    	let close16;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$2);
    	const default_slot_or_fallback = default_slot || fallback_block$c(ctx);
    	close16 = new Close16({ $$inline: true });

    	let div_levels = [
    		{ "aria-label": /*title*/ ctx[4] },
    		{ id: /*id*/ ctx[5] },
    		/*$$restProps*/ ctx[6],
    		{
    			class: div_class_value = "" + ((/*type*/ ctx[0] && `bx--tag--${/*type*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[6].class)
    		}
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			button = element("button");
    			create_component(close16.$$.fragment);
    			attr_dev(button, "aria-labelledby", /*id*/ ctx[5]);
    			button.disabled = /*disabled*/ ctx[2];
    			attr_dev(button, "title", /*title*/ ctx[4]);
    			toggle_class(button, "bx--tag__close-icon", true);
    			add_location(button, file$p, 63, 6, 1538);
    			set_attributes(div, div_data);
    			toggle_class(div, "bx--tag", true);
    			toggle_class(div, "bx--tag--disabled", /*disabled*/ ctx[2]);
    			toggle_class(div, "bx--tag--filter", /*filter*/ ctx[1]);
    			add_location(div, file$p, 51, 4, 1158);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(div, null);
    			}

    			append_dev(div, t);
    			append_dev(div, button);
    			mount_component(close16, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", stop_propagation(/*click_handler_1*/ ctx[9]), false, false, true),
    					listen_dev(button, "mouseover", /*mouseover_handler_1*/ ctx[10], false, false, false),
    					listen_dev(button, "mouseenter", /*mouseenter_handler_1*/ ctx[11], false, false, false),
    					listen_dev(button, "mouseleave", /*mouseleave_handler_1*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$2, get_default_slot_context$2);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*type*/ 1) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			if (!current || dirty & /*id*/ 32) {
    				attr_dev(button, "aria-labelledby", /*id*/ ctx[5]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (!current || dirty & /*title*/ 16) {
    				attr_dev(button, "title", /*title*/ ctx[4]);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*title*/ 16) && { "aria-label": /*title*/ ctx[4] },
    				(!current || dirty & /*id*/ 32) && { id: /*id*/ ctx[5] },
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6],
    				(!current || dirty & /*type, $$restProps*/ 65 && div_class_value !== (div_class_value = "" + ((/*type*/ ctx[0] && `bx--tag--${/*type*/ ctx[0]}`) + " " + /*$$restProps*/ ctx[6].class))) && { class: div_class_value }
    			]));

    			toggle_class(div, "bx--tag", true);
    			toggle_class(div, "bx--tag--disabled", /*disabled*/ ctx[2]);
    			toggle_class(div, "bx--tag--filter", /*filter*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			transition_in(close16.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			transition_out(close16.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			destroy_component(close16);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(51:2) {#if filter}",
    		ctx
    	});

    	return block;
    }

    // (42:0) {#if skeleton}
    function create_if_block$k(ctx) {
    	let tagskeleton;
    	let current;
    	const tagskeleton_spread_levels = [/*$$restProps*/ ctx[6]];
    	let tagskeleton_props = {};

    	for (let i = 0; i < tagskeleton_spread_levels.length; i += 1) {
    		tagskeleton_props = assign(tagskeleton_props, tagskeleton_spread_levels[i]);
    	}

    	tagskeleton = new Tag_Skeleton({ props: tagskeleton_props, $$inline: true });
    	tagskeleton.$on("click", /*click_handler*/ ctx[17]);
    	tagskeleton.$on("mouseover", /*mouseover_handler*/ ctx[18]);
    	tagskeleton.$on("mouseenter", /*mouseenter_handler*/ ctx[19]);
    	tagskeleton.$on("mouseleave", /*mouseleave_handler*/ ctx[20]);

    	const block = {
    		c: function create() {
    			create_component(tagskeleton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tagskeleton, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tagskeleton_changes = (dirty & /*$$restProps*/ 64)
    			? get_spread_update(tagskeleton_spread_levels, [get_spread_object(/*$$restProps*/ ctx[6])])
    			: {};

    			tagskeleton.$set(tagskeleton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagskeleton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tagskeleton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tagskeleton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(42:0) {#if skeleton}",
    		ctx
    	});

    	return block;
    }

    // (61:50)          
    function fallback_block$c(ctx) {
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(/*type*/ ctx[0]);
    			toggle_class(span, "bx--tag__label", true);
    			add_location(span, file$p, 61, 8, 1468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*type*/ 1) set_data_dev(t, /*type*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$c.name,
    		type: "fallback",
    		source: "(61:50)          ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$k, create_if_block_1$5, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*skeleton*/ ctx[3]) return 0;
    		if (/*filter*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	const omit_props_names = ["type","filter","disabled","skeleton","title","id"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tag", slots, ['default']);
    	let { type = undefined } = $$props;
    	let { filter = false } = $$props;
    	let { disabled = false } = $$props;
    	let { skeleton = false } = $$props;
    	let { title = "Clear filter" } = $$props;
    	let { id = "ccs-" + Math.random().toString(36) } = $$props;

    	function click_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_1(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_1(event) {
    		bubble($$self, event);
    	}

    	function click_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler_2(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler_2(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("type" in $$new_props) $$invalidate(0, type = $$new_props.type);
    		if ("filter" in $$new_props) $$invalidate(1, filter = $$new_props.filter);
    		if ("disabled" in $$new_props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("skeleton" in $$new_props) $$invalidate(3, skeleton = $$new_props.skeleton);
    		if ("title" in $$new_props) $$invalidate(4, title = $$new_props.title);
    		if ("id" in $$new_props) $$invalidate(5, id = $$new_props.id);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		type,
    		filter,
    		disabled,
    		skeleton,
    		title,
    		id,
    		Close16,
    		TagSkeleton: Tag_Skeleton
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("type" in $$props) $$invalidate(0, type = $$new_props.type);
    		if ("filter" in $$props) $$invalidate(1, filter = $$new_props.filter);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$new_props.disabled);
    		if ("skeleton" in $$props) $$invalidate(3, skeleton = $$new_props.skeleton);
    		if ("title" in $$props) $$invalidate(4, title = $$new_props.title);
    		if ("id" in $$props) $$invalidate(5, id = $$new_props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		type,
    		filter,
    		disabled,
    		skeleton,
    		title,
    		id,
    		$$restProps,
    		$$scope,
    		slots,
    		click_handler_1,
    		mouseover_handler_1,
    		mouseenter_handler_1,
    		mouseleave_handler_1,
    		click_handler_2,
    		mouseover_handler_2,
    		mouseenter_handler_2,
    		mouseleave_handler_2,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Tag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			type: 0,
    			filter: 1,
    			disabled: 2,
    			skeleton: 3,
    			title: 4,
    			id: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tag",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get type() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get skeleton() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set skeleton(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Tag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Tag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte generated by Svelte v3.29.0 */
    const file$q = "node_modules/carbon-components-svelte/src/TextArea/TextArea.svelte";

    // (98:2) {#if labelText && !hideLabel}
    function create_if_block_3$2(ctx) {
    	let label;
    	let t;

    	const block = {
    		c: function create() {
    			label = element("label");
    			t = text(/*labelText*/ ctx[8]);
    			attr_dev(label, "for", /*id*/ ctx[12]);
    			toggle_class(label, "bx--label", true);
    			toggle_class(label, "bx--visually-hidden", /*hideLabel*/ ctx[9]);
    			toggle_class(label, "bx--label--disabled", /*disabled*/ ctx[6]);
    			add_location(label, file$q, 98, 4, 1904);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*labelText*/ 256) set_data_dev(t, /*labelText*/ ctx[8]);

    			if (dirty & /*id*/ 4096) {
    				attr_dev(label, "for", /*id*/ ctx[12]);
    			}

    			if (dirty & /*hideLabel*/ 512) {
    				toggle_class(label, "bx--visually-hidden", /*hideLabel*/ ctx[9]);
    			}

    			if (dirty & /*disabled*/ 64) {
    				toggle_class(label, "bx--label--disabled", /*disabled*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(98:2) {#if labelText && !hideLabel}",
    		ctx
    	});

    	return block;
    }

    // (112:4) {#if invalid}
    function create_if_block_2$2(ctx) {
    	let warningfilled16;
    	let current;

    	warningfilled16 = new WarningFilled16({
    			props: { class: "bx--text-area__invalid-icon" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(warningfilled16.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(warningfilled16, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(warningfilled16.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(warningfilled16.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(warningfilled16, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(112:4) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    // (139:2) {#if !invalid && helperText}
    function create_if_block_1$6(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*helperText*/ ctx[7]);
    			toggle_class(div, "bx--form__helper-text", true);
    			toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[6]);
    			add_location(div, file$q, 139, 4, 2923);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*helperText*/ 128) set_data_dev(t, /*helperText*/ ctx[7]);

    			if (dirty & /*disabled*/ 64) {
    				toggle_class(div, "bx--form__helper-text--disabled", /*disabled*/ ctx[6]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(139:2) {#if !invalid && helperText}",
    		ctx
    	});

    	return block;
    }

    // (147:2) {#if invalid}
    function create_if_block$l(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*invalidText*/ ctx[11]);
    			attr_dev(div, "id", /*errorId*/ ctx[14]);
    			toggle_class(div, "bx--form-requirement", true);
    			add_location(div, file$q, 147, 4, 3092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*invalidText*/ 2048) set_data_dev(t, /*invalidText*/ ctx[11]);

    			if (dirty & /*errorId*/ 16384) {
    				attr_dev(div, "id", /*errorId*/ ctx[14]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(147:2) {#if invalid}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div1;
    	let t0;
    	let div0;
    	let t1;
    	let textarea;
    	let textarea_aria_invalid_value;
    	let textarea_aria_describedby_value;
    	let div0_data_invalid_value;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*labelText*/ ctx[8] && !/*hideLabel*/ ctx[9] && create_if_block_3$2(ctx);
    	let if_block1 = /*invalid*/ ctx[10] && create_if_block_2$2(ctx);

    	let textarea_levels = [
    		{
    			"aria-invalid": textarea_aria_invalid_value = /*invalid*/ ctx[10] || undefined
    		},
    		{
    			"aria-describedby": textarea_aria_describedby_value = /*invalid*/ ctx[10] ? /*errorId*/ ctx[14] : undefined
    		},
    		{ disabled: /*disabled*/ ctx[6] },
    		{ id: /*id*/ ctx[12] },
    		{ name: /*name*/ ctx[13] },
    		{ cols: /*cols*/ ctx[3] },
    		{ rows: /*rows*/ ctx[4] },
    		{ value: /*value*/ ctx[0] },
    		{ placeholder: /*placeholder*/ ctx[2] },
    		/*$$restProps*/ ctx[15]
    	];

    	let textarea_data = {};

    	for (let i = 0; i < textarea_levels.length; i += 1) {
    		textarea_data = assign(textarea_data, textarea_levels[i]);
    	}

    	let if_block2 = !/*invalid*/ ctx[10] && /*helperText*/ ctx[7] && create_if_block_1$6(ctx);
    	let if_block3 = /*invalid*/ ctx[10] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div0 = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			set_attributes(textarea, textarea_data);
    			toggle_class(textarea, "bx--text-area", true);
    			toggle_class(textarea, "bx--text-area--light", /*light*/ ctx[5]);
    			toggle_class(textarea, "bx--text-area--invalid", /*invalid*/ ctx[10]);
    			add_location(textarea, file$q, 114, 4, 2284);
    			attr_dev(div0, "data-invalid", div0_data_invalid_value = /*invalid*/ ctx[10] || undefined);
    			toggle_class(div0, "bx--text-area__wrapper", true);
    			add_location(div0, file$q, 107, 2, 2097);
    			toggle_class(div1, "bx--form-item", true);
    			add_location(div1, file$q, 90, 0, 1772);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			append_dev(div0, textarea);
    			/*textarea_binding*/ ctx[24](textarea);
    			append_dev(div1, t2);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t3);
    			if (if_block3) if_block3.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "change", /*change_handler*/ ctx[20], false, false, false),
    					listen_dev(textarea, "input", /*input_handler*/ ctx[21], false, false, false),
    					listen_dev(textarea, "input", /*input_handler_1*/ ctx[25], false, false, false),
    					listen_dev(textarea, "focus", /*focus_handler*/ ctx[22], false, false, false),
    					listen_dev(textarea, "blur", /*blur_handler*/ ctx[23], false, false, false),
    					listen_dev(div1, "click", /*click_handler*/ ctx[16], false, false, false),
    					listen_dev(div1, "mouseover", /*mouseover_handler*/ ctx[17], false, false, false),
    					listen_dev(div1, "mouseenter", /*mouseenter_handler*/ ctx[18], false, false, false),
    					listen_dev(div1, "mouseleave", /*mouseleave_handler*/ ctx[19], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*labelText*/ ctx[8] && !/*hideLabel*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					if_block0.m(div1, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*invalid*/ ctx[10]) {
    				if (if_block1) {
    					if (dirty & /*invalid*/ 1024) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
    				(!current || dirty & /*invalid*/ 1024 && textarea_aria_invalid_value !== (textarea_aria_invalid_value = /*invalid*/ ctx[10] || undefined)) && {
    					"aria-invalid": textarea_aria_invalid_value
    				},
    				(!current || dirty & /*invalid, errorId*/ 17408 && textarea_aria_describedby_value !== (textarea_aria_describedby_value = /*invalid*/ ctx[10] ? /*errorId*/ ctx[14] : undefined)) && {
    					"aria-describedby": textarea_aria_describedby_value
    				},
    				(!current || dirty & /*disabled*/ 64) && { disabled: /*disabled*/ ctx[6] },
    				(!current || dirty & /*id*/ 4096) && { id: /*id*/ ctx[12] },
    				(!current || dirty & /*name*/ 8192) && { name: /*name*/ ctx[13] },
    				(!current || dirty & /*cols*/ 8) && { cols: /*cols*/ ctx[3] },
    				(!current || dirty & /*rows*/ 16) && { rows: /*rows*/ ctx[4] },
    				(!current || dirty & /*value*/ 1) && { value: /*value*/ ctx[0] },
    				(!current || dirty & /*placeholder*/ 4) && { placeholder: /*placeholder*/ ctx[2] },
    				dirty & /*$$restProps*/ 32768 && /*$$restProps*/ ctx[15]
    			]));

    			toggle_class(textarea, "bx--text-area", true);
    			toggle_class(textarea, "bx--text-area--light", /*light*/ ctx[5]);
    			toggle_class(textarea, "bx--text-area--invalid", /*invalid*/ ctx[10]);

    			if (!current || dirty & /*invalid*/ 1024 && div0_data_invalid_value !== (div0_data_invalid_value = /*invalid*/ ctx[10] || undefined)) {
    				attr_dev(div0, "data-invalid", div0_data_invalid_value);
    			}

    			if (!/*invalid*/ ctx[10] && /*helperText*/ ctx[7]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$6(ctx);
    					if_block2.c();
    					if_block2.m(div1, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*invalid*/ ctx[10]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$l(ctx);
    					if_block3.c();
    					if_block3.m(div1, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*textarea_binding*/ ctx[24](null);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"value","placeholder","cols","rows","light","disabled","helperText","labelText","hideLabel","invalid","invalidText","id","name","ref"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("TextArea", slots, []);
    	let { value = "" } = $$props;
    	let { placeholder = "" } = $$props;
    	let { cols = 50 } = $$props;
    	let { rows = 4 } = $$props;
    	let { light = false } = $$props;
    	let { disabled = false } = $$props;
    	let { helperText = "" } = $$props;
    	let { labelText = "" } = $$props;
    	let { hideLabel = false } = $$props;
    	let { invalid = false } = $$props;
    	let { invalidText = "" } = $$props;
    	let { id = "ccs-" + Math.random().toString(36) } = $$props;
    	let { name = undefined } = $$props;
    	let { ref = null } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function change_handler(event) {
    		bubble($$self, event);
    	}

    	function input_handler(event) {
    		bubble($$self, event);
    	}

    	function focus_handler(event) {
    		bubble($$self, event);
    	}

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(1, ref);
    		});
    	}

    	const input_handler_1 = ({ target }) => {
    		$$invalidate(0, value = target.value);
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("value" in $$new_props) $$invalidate(0, value = $$new_props.value);
    		if ("placeholder" in $$new_props) $$invalidate(2, placeholder = $$new_props.placeholder);
    		if ("cols" in $$new_props) $$invalidate(3, cols = $$new_props.cols);
    		if ("rows" in $$new_props) $$invalidate(4, rows = $$new_props.rows);
    		if ("light" in $$new_props) $$invalidate(5, light = $$new_props.light);
    		if ("disabled" in $$new_props) $$invalidate(6, disabled = $$new_props.disabled);
    		if ("helperText" in $$new_props) $$invalidate(7, helperText = $$new_props.helperText);
    		if ("labelText" in $$new_props) $$invalidate(8, labelText = $$new_props.labelText);
    		if ("hideLabel" in $$new_props) $$invalidate(9, hideLabel = $$new_props.hideLabel);
    		if ("invalid" in $$new_props) $$invalidate(10, invalid = $$new_props.invalid);
    		if ("invalidText" in $$new_props) $$invalidate(11, invalidText = $$new_props.invalidText);
    		if ("id" in $$new_props) $$invalidate(12, id = $$new_props.id);
    		if ("name" in $$new_props) $$invalidate(13, name = $$new_props.name);
    		if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    	};

    	$$self.$capture_state = () => ({
    		value,
    		placeholder,
    		cols,
    		rows,
    		light,
    		disabled,
    		helperText,
    		labelText,
    		hideLabel,
    		invalid,
    		invalidText,
    		id,
    		name,
    		ref,
    		WarningFilled16,
    		errorId
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("value" in $$props) $$invalidate(0, value = $$new_props.value);
    		if ("placeholder" in $$props) $$invalidate(2, placeholder = $$new_props.placeholder);
    		if ("cols" in $$props) $$invalidate(3, cols = $$new_props.cols);
    		if ("rows" in $$props) $$invalidate(4, rows = $$new_props.rows);
    		if ("light" in $$props) $$invalidate(5, light = $$new_props.light);
    		if ("disabled" in $$props) $$invalidate(6, disabled = $$new_props.disabled);
    		if ("helperText" in $$props) $$invalidate(7, helperText = $$new_props.helperText);
    		if ("labelText" in $$props) $$invalidate(8, labelText = $$new_props.labelText);
    		if ("hideLabel" in $$props) $$invalidate(9, hideLabel = $$new_props.hideLabel);
    		if ("invalid" in $$props) $$invalidate(10, invalid = $$new_props.invalid);
    		if ("invalidText" in $$props) $$invalidate(11, invalidText = $$new_props.invalidText);
    		if ("id" in $$props) $$invalidate(12, id = $$new_props.id);
    		if ("name" in $$props) $$invalidate(13, name = $$new_props.name);
    		if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    		if ("errorId" in $$props) $$invalidate(14, errorId = $$new_props.errorId);
    	};

    	let errorId;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*id*/ 4096) {
    			 $$invalidate(14, errorId = `error-${id}`);
    		}
    	};

    	return [
    		value,
    		ref,
    		placeholder,
    		cols,
    		rows,
    		light,
    		disabled,
    		helperText,
    		labelText,
    		hideLabel,
    		invalid,
    		invalidText,
    		id,
    		name,
    		errorId,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		change_handler,
    		input_handler,
    		focus_handler,
    		blur_handler,
    		textarea_binding,
    		input_handler_1
    	];
    }

    class TextArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {
    			value: 0,
    			placeholder: 2,
    			cols: 3,
    			rows: 4,
    			light: 5,
    			disabled: 6,
    			helperText: 7,
    			labelText: 8,
    			hideLabel: 9,
    			invalid: 10,
    			invalidText: 11,
    			id: 12,
    			name: 13,
    			ref: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextArea",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get value() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cols() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cols(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rows() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rows(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get helperText() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set helperText(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get labelText() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set labelText(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideLabel() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideLabel(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalid() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalid(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get invalidText() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invalidText(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<TextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<TextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tile/Tile.svelte generated by Svelte v3.29.0 */

    const file$r = "node_modules/carbon-components-svelte/src/Tile/Tile.svelte";

    function create_fragment$v(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let div_levels = [/*$$restProps*/ ctx[1]];
    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_attributes(div, div_data);
    			toggle_class(div, "bx--tile", true);
    			toggle_class(div, "bx--tile--light", /*light*/ ctx[0]);
    			add_location(div, file$r, 8, 0, 142);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(div, "mouseover", /*mouseover_handler*/ ctx[5], false, false, false),
    					listen_dev(div, "mouseenter", /*mouseenter_handler*/ ctx[6], false, false, false),
    					listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]]));
    			toggle_class(div, "bx--tile", true);
    			toggle_class(div, "bx--tile--light", /*light*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	const omit_props_names = ["light"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tile", slots, ['default']);
    	let { light = false } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("light" in $$new_props) $$invalidate(0, light = $$new_props.light);
    		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ light });

    	$$self.$inject_state = $$new_props => {
    		if ("light" in $$props) $$invalidate(0, light = $$new_props.light);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		light,
    		$$restProps,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler
    	];
    }

    class Tile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { light: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tile",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get light() {
    		throw new Error("<Tile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<Tile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte generated by Svelte v3.29.0 */

    const file$s = "node_modules/carbon-components-svelte/src/Tile/ClickableTile.svelte";

    function create_fragment$w(ctx) {
    	let a;
    	let a_rel_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	let a_levels = [
    		{
    			rel: a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    			? "noopener noreferrer"
    			: undefined
    		},
    		/*$$restProps*/ ctx[3],
    		{ href: /*href*/ ctx[2] }
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			toggle_class(a, "bx--tile", true);
    			toggle_class(a, "bx--tile--clickable", true);
    			toggle_class(a, "bx--tile--is-clicked", /*clicked*/ ctx[0]);
    			toggle_class(a, "bx--tile--light", /*light*/ ctx[1]);
    			add_location(a, file$s, 21, 0, 396);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[6], false, false, false),
    					listen_dev(a, "click", /*click_handler_1*/ ctx[11], false, false, false),
    					listen_dev(a, "keydown", /*keydown_handler*/ ctx[7], false, false, false),
    					listen_dev(a, "keydown", /*keydown_handler_1*/ ctx[12], false, false, false),
    					listen_dev(a, "mouseover", /*mouseover_handler*/ ctx[8], false, false, false),
    					listen_dev(a, "mouseenter", /*mouseenter_handler*/ ctx[9], false, false, false),
    					listen_dev(a, "mouseleave", /*mouseleave_handler*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*$$restProps*/ 8 && a_rel_value !== (a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    				? "noopener noreferrer"
    				: undefined)) && { rel: a_rel_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3],
    				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] }
    			]));

    			toggle_class(a, "bx--tile", true);
    			toggle_class(a, "bx--tile--clickable", true);
    			toggle_class(a, "bx--tile--is-clicked", /*clicked*/ ctx[0]);
    			toggle_class(a, "bx--tile--light", /*light*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	const omit_props_names = ["clicked","light","href"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ClickableTile", slots, ['default']);
    	let { clicked = false } = $$props;
    	let { light = false } = $$props;
    	let { href = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	const click_handler_1 = () => {
    		$$invalidate(0, clicked = !clicked);
    	};

    	const keydown_handler_1 = ({ key }) => {
    		if (key === " " || key === "Enter") {
    			$$invalidate(0, clicked = !clicked);
    		}
    	};

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("clicked" in $$new_props) $$invalidate(0, clicked = $$new_props.clicked);
    		if ("light" in $$new_props) $$invalidate(1, light = $$new_props.light);
    		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ("$$scope" in $$new_props) $$invalidate(4, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ clicked, light, href });

    	$$self.$inject_state = $$new_props => {
    		if ("clicked" in $$props) $$invalidate(0, clicked = $$new_props.clicked);
    		if ("light" in $$props) $$invalidate(1, light = $$new_props.light);
    		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		clicked,
    		light,
    		href,
    		$$restProps,
    		$$scope,
    		slots,
    		click_handler,
    		keydown_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		click_handler_1,
    		keydown_handler_1
    	];
    }

    class ClickableTile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { clicked: 0, light: 1, href: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClickableTile",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get clicked() {
    		throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clicked(value) {
    		throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get light() {
    		throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set light(value) {
    		throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<ClickableTile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<ClickableTile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    /* node_modules/carbon-icons-svelte/lib/Menu20/Menu20.svelte generated by Svelte v3.29.0 */

    const file$t = "node_modules/carbon-icons-svelte/lib/Menu20/Menu20.svelte";

    // (39:4) {#if title}
    function create_if_block$m(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$t, 39, 6, 1086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$d(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$d.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$d(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "Menu20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 20 20" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z");
    			add_location(path, file$t, 36, 2, 944);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$t, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "Menu20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 20 20" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Menu20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class Menu20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu20",
    			options,
    			id: create_fragment$x.name
    		});
    	}

    	get class() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Menu20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Menu20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/SideNav/HamburgerMenu.svelte generated by Svelte v3.29.0 */
    const file$u = "node_modules/carbon-components-svelte/src/UIShell/SideNav/HamburgerMenu.svelte";

    function create_fragment$y(ctx) {
    	let button;
    	let icon;
    	let button_transition;
    	let current;
    	let mounted;
    	let dispose;

    	icon = new Icon({
    			props: {
    				title: /*isOpen*/ ctx[0] ? "Close" : "Open Menu",
    				render: /*isOpen*/ ctx[0] ? Close20 : Menu20
    			},
    			$$inline: true
    		});

    	let button_levels = [
    		{ type: "button" },
    		{ title: "Open menu" },
    		{ "aria-label": /*ariaLabel*/ ctx[2] },
    		/*$$restProps*/ ctx[3]
    	];

    	let button_data = {};

    	for (let i = 0; i < button_levels.length; i += 1) {
    		button_data = assign(button_data, button_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(icon.$$.fragment);
    			set_attributes(button, button_data);
    			toggle_class(button, "bx--header__action", true);
    			toggle_class(button, "bx--header__menu-trigger", true);
    			toggle_class(button, "bx--header__menu-toggle", true);
    			add_location(button, file$u, 25, 0, 596);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(icon, button, null);
    			/*button_binding*/ ctx[5](button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const icon_changes = {};
    			if (dirty & /*isOpen*/ 1) icon_changes.title = /*isOpen*/ ctx[0] ? "Close" : "Open Menu";
    			if (dirty & /*isOpen*/ 1) icon_changes.render = /*isOpen*/ ctx[0] ? Close20 : Menu20;
    			icon.$set(icon_changes);

    			set_attributes(button, button_data = get_spread_update(button_levels, [
    				{ type: "button" },
    				{ title: "Open menu" },
    				(!current || dirty & /*ariaLabel*/ 4) && { "aria-label": /*ariaLabel*/ ctx[2] },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));

    			toggle_class(button, "bx--header__action", true);
    			toggle_class(button, "bx--header__menu-trigger", true);
    			toggle_class(button, "bx--header__menu-toggle", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);

    			add_render_callback(() => {
    				if (!button_transition) button_transition = create_bidirectional_transition(button, fly, { x: -200, delay: 50, duration: 250 }, true);
    				button_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			if (!button_transition) button_transition = create_bidirectional_transition(button, fly, { x: -200, delay: 50, duration: 250 }, false);
    			button_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(icon);
    			/*button_binding*/ ctx[5](null);
    			if (detaching && button_transition) button_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	const omit_props_names = ["ariaLabel","isOpen","ref"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HamburgerMenu", slots, []);
    	let { ariaLabel = undefined } = $$props;
    	let { isOpen = false } = $$props;
    	let { ref = null } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(1, ref);
    		});
    	}

    	const click_handler_1 = () => $$invalidate(0, isOpen = !isOpen);

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("ariaLabel" in $$new_props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ("isOpen" in $$new_props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    	};

    	$$self.$capture_state = () => ({
    		ariaLabel,
    		isOpen,
    		ref,
    		fly,
    		Close20,
    		Menu20,
    		Icon
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("ariaLabel" in $$props) $$invalidate(2, ariaLabel = $$new_props.ariaLabel);
    		if ("isOpen" in $$props) $$invalidate(0, isOpen = $$new_props.isOpen);
    		if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isOpen,
    		ref,
    		ariaLabel,
    		$$restProps,
    		click_handler,
    		button_binding,
    		click_handler_1
    	];
    }

    class HamburgerMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { ariaLabel: 2, isOpen: 0, ref: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HamburgerMenu",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get ariaLabel() {
    		throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isOpen() {
    		throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isOpen(value) {
    		throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<HamburgerMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<HamburgerMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/Header.svelte generated by Svelte v3.29.0 */
    const file$v = "node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/Header.svelte";
    const get_platform_slot_changes = dirty => ({});
    const get_platform_slot_context = ctx => ({});
    const get_skip_to_content_slot_changes = dirty => ({});
    const get_skip_to_content_slot_context = ctx => ({});

    // (59:2) {#if winWidth < 1056}
    function create_if_block_1$7(ctx) {
    	let hamburgermenu;
    	let updating_isOpen;
    	let current;

    	function hamburgermenu_isOpen_binding(value) {
    		/*hamburgermenu_isOpen_binding*/ ctx[14].call(null, value);
    	}

    	let hamburgermenu_props = {};

    	if (/*isSideNavOpen*/ ctx[0] !== void 0) {
    		hamburgermenu_props.isOpen = /*isSideNavOpen*/ ctx[0];
    	}

    	hamburgermenu = new HamburgerMenu({
    			props: hamburgermenu_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(hamburgermenu, "isOpen", hamburgermenu_isOpen_binding));

    	const block = {
    		c: function create() {
    			create_component(hamburgermenu.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hamburgermenu, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hamburgermenu_changes = {};

    			if (!updating_isOpen && dirty & /*isSideNavOpen*/ 1) {
    				updating_isOpen = true;
    				hamburgermenu_changes.isOpen = /*isSideNavOpen*/ ctx[0];
    				add_flush_callback(() => updating_isOpen = false);
    			}

    			hamburgermenu.$set(hamburgermenu_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hamburgermenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hamburgermenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hamburgermenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(59:2) {#if winWidth < 1056}",
    		ctx
    	});

    	return block;
    }

    // (69:4) {#if company}
    function create_if_block$n(ctx) {
    	let span;
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(/*company*/ ctx[3]);
    			t1 = text(" ");
    			toggle_class(span, "bx--header__name--prefix", true);
    			add_location(span, file$v, 69, 6, 1651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*company*/ 8) set_data_dev(t0, /*company*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(69:4) {#if company}",
    		ctx
    	});

    	return block;
    }

    // (72:26) {platformName}
    function fallback_block$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*platformName*/ ctx[4]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*platformName*/ 16) set_data_dev(t, /*platformName*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$e.name,
    		type: "fallback",
    		source: "(72:26) {platformName}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let header;
    	let t0;
    	let t1;
    	let a;
    	let t2;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[13]);
    	const skip_to_content_slot_template = /*#slots*/ ctx[11]["skip-to-content"];
    	const skip_to_content_slot = create_slot(skip_to_content_slot_template, ctx, /*$$scope*/ ctx[10], get_skip_to_content_slot_context);
    	let if_block0 = /*winWidth*/ ctx[5] < 1056 && create_if_block_1$7(ctx);
    	let if_block1 = /*company*/ ctx[3] && create_if_block$n(ctx);
    	const platform_slot_template = /*#slots*/ ctx[11].platform;
    	const platform_slot = create_slot(platform_slot_template, ctx, /*$$scope*/ ctx[10], get_platform_slot_context);
    	const platform_slot_or_fallback = platform_slot || fallback_block$e(ctx);
    	let a_levels = [{ href: /*href*/ ctx[2] }, /*$$restProps*/ ctx[7]];
    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			header = element("header");
    			if (skip_to_content_slot) skip_to_content_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			a = element("a");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (platform_slot_or_fallback) platform_slot_or_fallback.c();
    			t3 = space();
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			toggle_class(a, "bx--header__name", true);
    			add_location(a, file$v, 61, 2, 1510);
    			attr_dev(header, "role", "banner");
    			attr_dev(header, "aria-label", /*ariaLabel*/ ctx[6]);
    			toggle_class(header, "bx--header", true);
    			add_location(header, file$v, 56, 0, 1316);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);

    			if (skip_to_content_slot) {
    				skip_to_content_slot.m(header, null);
    			}

    			append_dev(header, t0);
    			if (if_block0) if_block0.m(header, null);
    			append_dev(header, t1);
    			append_dev(header, a);
    			if (if_block1) if_block1.m(a, null);
    			append_dev(a, t2);

    			if (platform_slot_or_fallback) {
    				platform_slot_or_fallback.m(a, null);
    			}

    			/*a_binding*/ ctx[15](a);
    			append_dev(header, t3);

    			if (default_slot) {
    				default_slot.m(header, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "resize", /*onwindowresize*/ ctx[13]),
    					listen_dev(a, "click", /*click_handler*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (skip_to_content_slot) {
    				if (skip_to_content_slot.p && dirty & /*$$scope*/ 1024) {
    					update_slot(skip_to_content_slot, skip_to_content_slot_template, ctx, /*$$scope*/ ctx[10], dirty, get_skip_to_content_slot_changes, get_skip_to_content_slot_context);
    				}
    			}

    			if (/*winWidth*/ ctx[5] < 1056) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*winWidth*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(header, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*company*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$n(ctx);
    					if_block1.c();
    					if_block1.m(a, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (platform_slot) {
    				if (platform_slot.p && dirty & /*$$scope*/ 1024) {
    					update_slot(platform_slot, platform_slot_template, ctx, /*$$scope*/ ctx[10], dirty, get_platform_slot_changes, get_platform_slot_context);
    				}
    			} else {
    				if (platform_slot_or_fallback && platform_slot_or_fallback.p && dirty & /*platformName*/ 16) {
    					platform_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 4) && { href: /*href*/ ctx[2] },
    				dirty & /*$$restProps*/ 128 && /*$$restProps*/ ctx[7]
    			]));

    			toggle_class(a, "bx--header__name", true);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1024) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*ariaLabel*/ 64) {
    				attr_dev(header, "aria-label", /*ariaLabel*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skip_to_content_slot, local);
    			transition_in(if_block0);
    			transition_in(platform_slot_or_fallback, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skip_to_content_slot, local);
    			transition_out(if_block0);
    			transition_out(platform_slot_or_fallback, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (skip_to_content_slot) skip_to_content_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (platform_slot_or_fallback) platform_slot_or_fallback.d(detaching);
    			/*a_binding*/ ctx[15](null);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	const omit_props_names = [
    		"expandedByDefault","isSideNavOpen","uiShellAriaLabel","href","company","platformName","ref"
    	];

    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Header", slots, ['skip-to-content','platform','default']);
    	let { expandedByDefault = true } = $$props;
    	let { isSideNavOpen = false } = $$props;
    	let { uiShellAriaLabel = undefined } = $$props;
    	let { href = undefined } = $$props;
    	let { company = undefined } = $$props;
    	let { platformName = undefined } = $$props;
    	let { ref = null } = $$props;
    	let winWidth = undefined;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function onwindowresize() {
    		$$invalidate(5, winWidth = window.innerWidth);
    	}

    	function hamburgermenu_isOpen_binding(value) {
    		isSideNavOpen = value;
    		(($$invalidate(0, isSideNavOpen), $$invalidate(8, expandedByDefault)), $$invalidate(5, winWidth));
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(1, ref);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(16, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		$$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("expandedByDefault" in $$new_props) $$invalidate(8, expandedByDefault = $$new_props.expandedByDefault);
    		if ("isSideNavOpen" in $$new_props) $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    		if ("uiShellAriaLabel" in $$new_props) $$invalidate(9, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    		if ("href" in $$new_props) $$invalidate(2, href = $$new_props.href);
    		if ("company" in $$new_props) $$invalidate(3, company = $$new_props.company);
    		if ("platformName" in $$new_props) $$invalidate(4, platformName = $$new_props.platformName);
    		if ("ref" in $$new_props) $$invalidate(1, ref = $$new_props.ref);
    		if ("$$scope" in $$new_props) $$invalidate(10, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		expandedByDefault,
    		isSideNavOpen,
    		uiShellAriaLabel,
    		href,
    		company,
    		platformName,
    		ref,
    		HamburgerMenu,
    		winWidth,
    		ariaLabel
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(16, $$props = assign(assign({}, $$props), $$new_props));
    		if ("expandedByDefault" in $$props) $$invalidate(8, expandedByDefault = $$new_props.expandedByDefault);
    		if ("isSideNavOpen" in $$props) $$invalidate(0, isSideNavOpen = $$new_props.isSideNavOpen);
    		if ("uiShellAriaLabel" in $$props) $$invalidate(9, uiShellAriaLabel = $$new_props.uiShellAriaLabel);
    		if ("href" in $$props) $$invalidate(2, href = $$new_props.href);
    		if ("company" in $$props) $$invalidate(3, company = $$new_props.company);
    		if ("platformName" in $$props) $$invalidate(4, platformName = $$new_props.platformName);
    		if ("ref" in $$props) $$invalidate(1, ref = $$new_props.ref);
    		if ("winWidth" in $$props) $$invalidate(5, winWidth = $$new_props.winWidth);
    		if ("ariaLabel" in $$props) $$invalidate(6, ariaLabel = $$new_props.ariaLabel);
    	};

    	let ariaLabel;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*expandedByDefault, winWidth*/ 288) {
    			 $$invalidate(0, isSideNavOpen = expandedByDefault && winWidth >= 1056);
    		}

    		 $$invalidate(6, ariaLabel = company
    		? `${company} `
    		: "" + (uiShellAriaLabel || $$props["aria-label"] || platformName));
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		isSideNavOpen,
    		ref,
    		href,
    		company,
    		platformName,
    		winWidth,
    		ariaLabel,
    		$$restProps,
    		expandedByDefault,
    		uiShellAriaLabel,
    		$$scope,
    		slots,
    		click_handler,
    		onwindowresize,
    		hamburgermenu_isOpen_binding,
    		a_binding
    	];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			expandedByDefault: 8,
    			isSideNavOpen: 0,
    			uiShellAriaLabel: 9,
    			href: 2,
    			company: 3,
    			platformName: 4,
    			ref: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$z.name
    		});
    	}

    	get expandedByDefault() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set expandedByDefault(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSideNavOpen() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSideNavOpen(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get uiShellAriaLabel() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set uiShellAriaLabel(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get company() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set company(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get platformName() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set platformName(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/HeaderNav.svelte generated by Svelte v3.29.0 */

    const file$w = "node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/HeaderNav.svelte";

    function create_fragment$A(ctx) {
    	let nav;
    	let ul;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let nav_levels = [{ "aria-label": /*ariaLabel*/ ctx[0] }, /*$$restProps*/ ctx[1]];
    	let nav_data = {};

    	for (let i = 0; i < nav_levels.length; i += 1) {
    		nav_data = assign(nav_data, nav_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "role", "menubar");
    			attr_dev(ul, "aria-label", /*ariaLabel*/ ctx[0]);
    			toggle_class(ul, "bx--header__menu-bar", true);
    			add_location(ul, file$w, 9, 2, 221);
    			set_attributes(nav, nav_data);
    			toggle_class(nav, "bx--header__nav", true);
    			add_location(nav, file$w, 8, 0, 140);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*ariaLabel*/ 1) {
    				attr_dev(ul, "aria-label", /*ariaLabel*/ ctx[0]);
    			}

    			set_attributes(nav, nav_data = get_spread_update(nav_levels, [
    				(!current || dirty & /*ariaLabel*/ 1) && { "aria-label": /*ariaLabel*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));

    			toggle_class(nav, "bx--header__nav", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	const omit_props_names = ["ariaLabel"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HeaderNav", slots, ['default']);
    	let { ariaLabel = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("ariaLabel" in $$new_props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ ariaLabel });

    	$$self.$inject_state = $$new_props => {
    		if ("ariaLabel" in $$props) $$invalidate(0, ariaLabel = $$new_props.ariaLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ariaLabel, $$restProps, $$scope, slots];
    }

    class HeaderNav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { ariaLabel: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderNav",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get ariaLabel() {
    		throw new Error("<HeaderNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ariaLabel(value) {
    		throw new Error("<HeaderNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/HeaderNavItem.svelte generated by Svelte v3.29.0 */

    const file$x = "node_modules/carbon-components-svelte/src/UIShell/GlobalHeader/HeaderNavItem.svelte";

    function create_fragment$B(ctx) {
    	let li;
    	let a;
    	let span;
    	let t;
    	let a_rel_value;
    	let mounted;
    	let dispose;

    	let a_levels = [
    		{ role: "menuitem" },
    		{ tabindex: "0" },
    		{ href: /*href*/ ctx[1] },
    		{
    			rel: a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    			? "noopener noreferrer"
    			: undefined
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			span = element("span");
    			t = text(/*text*/ ctx[2]);
    			toggle_class(span, "bx--text-truncate--end", true);
    			add_location(span, file$x, 38, 4, 711);
    			set_attributes(a, a_data);
    			toggle_class(a, "bx--header__menu-item", true);
    			add_location(a, file$x, 21, 2, 362);
    			add_location(li, file$x, 20, 0, 355);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, span);
    			append_dev(span, t);
    			/*a_binding*/ ctx[12](a);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*click_handler*/ ctx[4], false, false, false),
    					listen_dev(a, "mouseover", /*mouseover_handler*/ ctx[5], false, false, false),
    					listen_dev(a, "mouseenter", /*mouseenter_handler*/ ctx[6], false, false, false),
    					listen_dev(a, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false),
    					listen_dev(a, "keyup", /*keyup_handler*/ ctx[8], false, false, false),
    					listen_dev(a, "keydown", /*keydown_handler*/ ctx[9], false, false, false),
    					listen_dev(a, "focus", /*focus_handler*/ ctx[10], false, false, false),
    					listen_dev(a, "blur", /*blur_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*text*/ 4) set_data_dev(t, /*text*/ ctx[2]);

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				{ role: "menuitem" },
    				{ tabindex: "0" },
    				dirty & /*href*/ 2 && { href: /*href*/ ctx[1] },
    				dirty & /*$$restProps*/ 8 && a_rel_value !== (a_rel_value = /*$$restProps*/ ctx[3].target === "_blank"
    				? "noopener noreferrer"
    				: undefined) && { rel: a_rel_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));

    			toggle_class(a, "bx--header__menu-item", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			/*a_binding*/ ctx[12](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	const omit_props_names = ["href","text","ref"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HeaderNavItem", slots, []);
    	let { href = undefined } = $$props;
    	let { text = undefined } = $$props;
    	let { ref = null } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	function focus_handler(event) {
    		bubble($$self, event);
    	}

    	function blur_handler(event) {
    		bubble($$self, event);
    	}

    	function a_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			ref = $$value;
    			$$invalidate(0, ref);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("href" in $$new_props) $$invalidate(1, href = $$new_props.href);
    		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
    		if ("ref" in $$new_props) $$invalidate(0, ref = $$new_props.ref);
    	};

    	$$self.$capture_state = () => ({ href, text, ref });

    	$$self.$inject_state = $$new_props => {
    		if ("href" in $$props) $$invalidate(1, href = $$new_props.href);
    		if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
    		if ("ref" in $$props) $$invalidate(0, ref = $$new_props.ref);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		ref,
    		href,
    		text,
    		$$restProps,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler,
    		focus_handler,
    		blur_handler,
    		a_binding
    	];
    }

    class HeaderNavItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { href: 1, text: 2, ref: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderNavItem",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get href() {
    		throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ref() {
    		throw new Error("<HeaderNavItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ref(value) {
    		throw new Error("<HeaderNavItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/Content.svelte generated by Svelte v3.29.0 */

    const file$y = "node_modules/carbon-components-svelte/src/UIShell/Content.svelte";

    function create_fragment$C(ctx) {
    	let main;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);
    	let main_levels = [{ id: /*id*/ ctx[0] }, /*$$restProps*/ ctx[1]];
    	let main_data = {};

    	for (let i = 0; i < main_levels.length; i += 1) {
    		main_data = assign(main_data, main_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			if (default_slot) default_slot.c();
    			set_attributes(main, main_data);
    			toggle_class(main, "bx--content", true);
    			add_location(main, file$y, 8, 0, 147);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);

    			if (default_slot) {
    				default_slot.m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			set_attributes(main, main_data = get_spread_update(main_levels, [
    				(!current || dirty & /*id*/ 1) && { id: /*id*/ ctx[0] },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));

    			toggle_class(main, "bx--content", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	const omit_props_names = ["id"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Content", slots, ['default']);
    	let { id = "main-content" } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
    		if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ id });

    	$$self.$inject_state = $$new_props => {
    		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [id, $$restProps, $$scope, slots];
    }

    class Content extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { id: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Content",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get id() {
    		throw new Error("<Content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte generated by Svelte v3.29.0 */

    const file$z = "node_modules/carbon-components-svelte/src/UIShell/SkipToContent.svelte";

    // (22:8) Skip to main content
    function fallback_block$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Skip to main content");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$f.name,
    		type: "fallback",
    		source: "(22:8) Skip to main content",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	const default_slot_or_fallback = default_slot || fallback_block$f(ctx);

    	let a_levels = [
    		{ href: /*href*/ ctx[0] },
    		{ tabindex: /*tabindex*/ ctx[1] },
    		/*$$restProps*/ ctx[2]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			set_attributes(a, a_data);
    			toggle_class(a, "bx--skip-to-content", true);
    			add_location(a, file$z, 14, 0, 249);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				(!current || dirty & /*tabindex*/ 2) && { tabindex: /*tabindex*/ ctx[1] },
    				dirty & /*$$restProps*/ 4 && /*$$restProps*/ ctx[2]
    			]));

    			toggle_class(a, "bx--skip-to-content", true);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	const omit_props_names = ["href","tabindex"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SkipToContent", slots, ['default']);
    	let { href = "#main-content" } = $$props;
    	let { tabindex = "0" } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(2, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("href" in $$new_props) $$invalidate(0, href = $$new_props.href);
    		if ("tabindex" in $$new_props) $$invalidate(1, tabindex = $$new_props.tabindex);
    		if ("$$scope" in $$new_props) $$invalidate(3, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ href, tabindex });

    	$$self.$inject_state = $$new_props => {
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("tabindex" in $$props) $$invalidate(1, tabindex = $$new_props.tabindex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [href, tabindex, $$restProps, $$scope, slots, click_handler];
    }

    class SkipToContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { href: 0, tabindex: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SkipToContent",
    			options,
    			id: create_fragment$D.name
    		});
    	}

    	get href() {
    		throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<SkipToContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<SkipToContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var chance_1 = createCommonjsModule(function (module, exports) {
    //  Chance.js 1.1.7
    //  http://chancejs.com
    //  (c) 2013 Victor Quinn
    //  Chance may be freely distributed or modified under the MIT license.

    (function () {

        // Constants
        var MAX_INT = 9007199254740992;
        var MIN_INT = -MAX_INT;
        var NUMBERS = '0123456789';
        var CHARS_LOWER = 'abcdefghijklmnopqrstuvwxyz';
        var CHARS_UPPER = CHARS_LOWER.toUpperCase();
        var HEX_POOL  = NUMBERS + "abcdef";

        // Errors
        function UnsupportedError(message) {
            this.name = 'UnsupportedError';
            this.message = message || 'This feature is not supported on this platform';
        }

        UnsupportedError.prototype = new Error();
        UnsupportedError.prototype.constructor = UnsupportedError;

        // Cached array helpers
        var slice = Array.prototype.slice;

        // Constructor
        function Chance (seed) {
            if (!(this instanceof Chance)) {
                if (!seed) { seed = null; } // handle other non-truthy seeds, as described in issue #322
                return seed === null ? new Chance() : new Chance(seed);
            }

            // if user has provided a function, use that as the generator
            if (typeof seed === 'function') {
                this.random = seed;
                return this;
            }

            if (arguments.length) {
                // set a starting value of zero so we can add to it
                this.seed = 0;
            }

            // otherwise, leave this.seed blank so that MT will receive a blank

            for (var i = 0; i < arguments.length; i++) {
                var seedling = 0;
                if (Object.prototype.toString.call(arguments[i]) === '[object String]') {
                    for (var j = 0; j < arguments[i].length; j++) {
                        // create a numeric hash for each argument, add to seedling
                        var hash = 0;
                        for (var k = 0; k < arguments[i].length; k++) {
                            hash = arguments[i].charCodeAt(k) + (hash << 6) + (hash << 16) - hash;
                        }
                        seedling += hash;
                    }
                } else {
                    seedling = arguments[i];
                }
                this.seed += (arguments.length - i) * seedling;
            }

            // If no generator function was provided, use our MT
            this.mt = this.mersenne_twister(this.seed);
            this.bimd5 = this.blueimp_md5();
            this.random = function () {
                return this.mt.random(this.seed);
            };

            return this;
        }

        Chance.prototype.VERSION = "1.1.7";

        // Random helper functions
        function initOptions(options, defaults) {
            options = options || {};

            if (defaults) {
                for (var i in defaults) {
                    if (typeof options[i] === 'undefined') {
                        options[i] = defaults[i];
                    }
                }
            }

            return options;
        }

        function range(size) {
            return Array.apply(null, Array(size)).map(function (_, i) {return i;});
        }

        function testRange(test, errorMessage) {
            if (test) {
                throw new RangeError(errorMessage);
            }
        }

        /**
         * Encode the input string with Base64.
         */
        var base64 = function() {
            throw new Error('No Base64 encoder available.');
        };

        // Select proper Base64 encoder.
        (function determineBase64Encoder() {
            if (typeof btoa === 'function') {
                base64 = btoa;
            } else if (typeof Buffer === 'function') {
                base64 = function(input) {
                    return new Buffer(input).toString('base64');
                };
            }
        })();

        // -- Basics --

        /**
         *  Return a random bool, either true or false
         *
         *  @param {Object} [options={ likelihood: 50 }] alter the likelihood of
         *    receiving a true or false value back.
         *  @throws {RangeError} if the likelihood is out of bounds
         *  @returns {Bool} either true or false
         */
        Chance.prototype.bool = function (options) {
            // likelihood of success (true)
            options = initOptions(options, {likelihood : 50});

            // Note, we could get some minor perf optimizations by checking range
            // prior to initializing defaults, but that makes code a bit messier
            // and the check more complicated as we have to check existence of
            // the object then existence of the key before checking constraints.
            // Since the options initialization should be minor computationally,
            // decision made for code cleanliness intentionally. This is mentioned
            // here as it's the first occurrence, will not be mentioned again.
            testRange(
                options.likelihood < 0 || options.likelihood > 100,
                "Chance: Likelihood accepts values from 0 to 100."
            );

            return this.random() * 100 < options.likelihood;
        };

        Chance.prototype.falsy = function (options) {
            // return a random falsy value
            options = initOptions(options, {pool: [false, null, 0, NaN, '']});
            var pool = options.pool,
                index = this.integer({min: 0, max: pool.length}),
                value = pool[index];

            return value;
        };

        Chance.prototype.animal = function (options){
          //returns a random animal
          options = initOptions(options);

          if(typeof options.type !== 'undefined'){
            //if user does not put in a valid animal type, user will get an error
            testRange(
               !this.get("animals")[options.type.toLowerCase()],
               "Please pick from desert, ocean, grassland, forest, zoo, pets, farm."
             );
             //if user does put in valid animal type, will return a random animal of that type
              return this.pick(this.get("animals")[options.type.toLowerCase()]);
          }
           //if user does not put in any animal type, will return a random animal regardless
          var animalTypeArray = ["desert","forest","ocean","zoo","farm","pet","grassland"];
          return this.pick(this.get("animals")[this.pick(animalTypeArray)]);
        };

        /**
         *  Return a random character.
         *
         *  @param {Object} [options={}] can specify a character pool or alpha,
         *    numeric, symbols and casing (lower or upper)
         *  @returns {String} a single random character
         */
        Chance.prototype.character = function (options) {
            options = initOptions(options);

            var symbols = "!@#$%^&*()[]",
                letters, pool;

            if (options.casing === 'lower') {
                letters = CHARS_LOWER;
            } else if (options.casing === 'upper') {
                letters = CHARS_UPPER;
            } else {
                letters = CHARS_LOWER + CHARS_UPPER;
            }

            if (options.pool) {
                pool = options.pool;
            } else {
                pool = '';
                if (options.alpha) {
                    pool += letters;
                }
                if (options.numeric) {
                    pool += NUMBERS;
                }
                if (options.symbols) {
                    pool += symbols;
                }
                if (!pool) {
                    pool = letters + NUMBERS + symbols;
                }
            }

            return pool.charAt(this.natural({max: (pool.length - 1)}));
        };

        // Note, wanted to use "float" or "double" but those are both JS reserved words.

        // Note, fixed means N OR LESS digits after the decimal. This because
        // It could be 14.9000 but in JavaScript, when this is cast as a number,
        // the trailing zeroes are dropped. Left to the consumer if trailing zeroes are
        // needed
        /**
         *  Return a random floating point number
         *
         *  @param {Object} [options={}] can specify a fixed precision, min, max
         *  @returns {Number} a single floating point number
         *  @throws {RangeError} Can only specify fixed or precision, not both. Also
         *    min cannot be greater than max
         */
        Chance.prototype.floating = function (options) {
            options = initOptions(options, {fixed : 4});
            testRange(
                options.fixed && options.precision,
                "Chance: Cannot specify both fixed and precision."
            );

            var num;
            var fixed = Math.pow(10, options.fixed);

            var max = MAX_INT / fixed;
            var min = -max;

            testRange(
                options.min && options.fixed && options.min < min,
                "Chance: Min specified is out of range with fixed. Min should be, at least, " + min
            );
            testRange(
                options.max && options.fixed && options.max > max,
                "Chance: Max specified is out of range with fixed. Max should be, at most, " + max
            );

            options = initOptions(options, { min : min, max : max });

            // Todo - Make this work!
            // options.precision = (typeof options.precision !== "undefined") ? options.precision : false;

            num = this.integer({min: options.min * fixed, max: options.max * fixed});
            var num_fixed = (num / fixed).toFixed(options.fixed);

            return parseFloat(num_fixed);
        };

        /**
         *  Return a random integer
         *
         *  NOTE the max and min are INCLUDED in the range. So:
         *  chance.integer({min: 1, max: 3});
         *  would return either 1, 2, or 3.
         *
         *  @param {Object} [options={}] can specify a min and/or max
         *  @returns {Number} a single random integer number
         *  @throws {RangeError} min cannot be greater than max
         */
        Chance.prototype.integer = function (options) {
            // 9007199254740992 (2^53) is the max integer number in JavaScript
            // See: http://vq.io/132sa2j
            options = initOptions(options, {min: MIN_INT, max: MAX_INT});
            testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

            return Math.floor(this.random() * (options.max - options.min + 1) + options.min);
        };

        /**
         *  Return a random natural
         *
         *  NOTE the max and min are INCLUDED in the range. So:
         *  chance.natural({min: 1, max: 3});
         *  would return either 1, 2, or 3.
         *
         *  @param {Object} [options={}] can specify a min and/or max or a numerals count.
         *  @returns {Number} a single random integer number
         *  @throws {RangeError} min cannot be greater than max
         */
        Chance.prototype.natural = function (options) {
            options = initOptions(options, {min: 0, max: MAX_INT});
            if (typeof options.numerals === 'number'){
              testRange(options.numerals < 1, "Chance: Numerals cannot be less than one.");
              options.min = Math.pow(10, options.numerals - 1);
              options.max = Math.pow(10, options.numerals) - 1;
            }
            testRange(options.min < 0, "Chance: Min cannot be less than zero.");

            if (options.exclude) {
                testRange(!Array.isArray(options.exclude), "Chance: exclude must be an array.");

                for (var exclusionIndex in options.exclude) {
                    testRange(!Number.isInteger(options.exclude[exclusionIndex]), "Chance: exclude must be numbers.");
                }

                var random = options.min + this.natural({max: options.max - options.min - options.exclude.length});
                var sortedExclusions = options.exclude.sort();
                for (var exclusionIndex in sortedExclusions) {
                    if (random < sortedExclusions[exclusionIndex]) {
                        break
                    }
                    random++;
                }
                return random
            }
            return this.integer(options);
        };

        /**
         *  Return a random prime number
         *
         *  NOTE the max and min are INCLUDED in the range.
         *
         *  @param {Object} [options={}] can specify a min and/or max
         *  @returns {Number} a single random prime number
         *  @throws {RangeError} min cannot be greater than max nor negative
         */
        Chance.prototype.prime = function (options) {
            options = initOptions(options, {min: 0, max: 10000});
            testRange(options.min < 0, "Chance: Min cannot be less than zero.");
            testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

            var lastPrime = data.primes[data.primes.length - 1];
            if (options.max > lastPrime) {
                for (var i = lastPrime + 2; i <= options.max; ++i) {
                    if (this.is_prime(i)) {
                        data.primes.push(i);
                    }
                }
            }
            var targetPrimes = data.primes.filter(function (prime) {
                return prime >= options.min && prime <= options.max;
            });
            return this.pick(targetPrimes);
        };

        /**
         * Determine whether a given number is prime or not.
         */
        Chance.prototype.is_prime = function (n) {
            if (n % 1 || n < 2) {
                return false;
            }
            if (n % 2 === 0) {
                return n === 2;
            }
            if (n % 3 === 0) {
                return n === 3;
            }
            var m = Math.sqrt(n);
            for (var i = 5; i <= m; i += 6) {
                if (n % i === 0 || n % (i + 2) === 0) {
                    return false;
                }
            }
            return true;
        };

        /**
         *  Return a random hex number as string
         *
         *  NOTE the max and min are INCLUDED in the range. So:
         *  chance.hex({min: '9', max: 'B'});
         *  would return either '9', 'A' or 'B'.
         *
         *  @param {Object} [options={}] can specify a min and/or max and/or casing
         *  @returns {String} a single random string hex number
         *  @throws {RangeError} min cannot be greater than max
         */
        Chance.prototype.hex = function (options) {
            options = initOptions(options, {min: 0, max: MAX_INT, casing: 'lower'});
            testRange(options.min < 0, "Chance: Min cannot be less than zero.");
    		var integer = this.natural({min: options.min, max: options.max});
    		if (options.casing === 'upper') {
    			return integer.toString(16).toUpperCase();
    		}
    		return integer.toString(16);
        };

        Chance.prototype.letter = function(options) {
            options = initOptions(options, {casing: 'lower'});
            var pool = "abcdefghijklmnopqrstuvwxyz";
            var letter = this.character({pool: pool});
            if (options.casing === 'upper') {
                letter = letter.toUpperCase();
            }
            return letter;
        };

        /**
         *  Return a random string
         *
         *  @param {Object} [options={}] can specify a length or min and max
         *  @returns {String} a string of random length
         *  @throws {RangeError} length cannot be less than zero
         */
        Chance.prototype.string = function (options) {
            options = initOptions(options, { min: 5, max: 20 });

            if (!options.length) {
                options.length = this.natural({ min: options.min, max: options.max });
            }

            testRange(options.length < 0, "Chance: Length cannot be less than zero.");
            var length = options.length,
                text = this.n(this.character, length, options);

            return text.join("");
        };

        function CopyToken(c) {
            this.c = c;
        }

        CopyToken.prototype = {
            substitute: function () {
                return this.c
            }
        };

        function EscapeToken(c) {
            this.c = c;
        }

        EscapeToken.prototype = {
            substitute: function () {
                if (!/[{}\\]/.test(this.c)) {
                    throw new Error('Invalid escape sequence: "\\' + this.c + '".')
                }
                return this.c
            }
        };

        function ReplaceToken(c) {
            this.c = c;
        }

        ReplaceToken.prototype = {
            replacers: {
                '#': function (chance) { return chance.character({ pool: NUMBERS }) },
                'A': function (chance) { return chance.character({ pool: CHARS_UPPER }) },
                'a': function (chance) { return chance.character({ pool: CHARS_LOWER }) },
            },

            substitute: function (chance) {
                var replacer = this.replacers[this.c];
                if (!replacer) {
                    throw new Error('Invalid replacement character: "' + this.c + '".')
                }
                return replacer(chance)
            }
        };

        function parseTemplate(template) {
            var tokens = [];
            var mode = 'identity';
            for (var i = 0; i<template.length; i++) {
                var c = template[i];
                switch (mode) {
                    case 'escape':
                        tokens.push(new EscapeToken(c));
                        mode = 'identity';
                        break
                    case 'identity':
                        if (c === '{') {
                            mode = 'replace';
                        } else if (c === '\\') {
                            mode = 'escape';
                        } else {
                            tokens.push(new CopyToken(c));
                        }
                        break
                    case 'replace':
                        if (c === '}') {
                            mode = 'identity';
                        } else {
                            tokens.push(new ReplaceToken(c));
                        }
                        break
                }
            }
            return tokens
        }

        /**
         *  Return a random string matching the given template.
         *
         *  The template consists of any number of "character replacement" and
         *  "character literal" sequences. A "character replacement" sequence
         *  starts with a left brace, has any number of special replacement
         *  characters, and ends with a right brace. A character literal can be any
         *  character except a brace or a backslash. A literal brace or backslash
         *  character can be included in the output by escaping with a backslash.
         *
         *  The following replacement characters can be used in a replacement
         *  sequence:
         *
         *      "#": a random digit
         *      "a": a random lower case letter
         *      "A": a random upper case letter
         *
         *  Example: chance.template('{AA###}-{##}')
         *
         *  @param {String} template string.
         *  @returns {String} a random string matching the template.
         */
        Chance.prototype.template = function (template) {
            if (!template) {
                throw new Error('Template string is required')
            }
            var self = this;
            return parseTemplate(template)
                .map(function (token) { return token.substitute(self) })
                .join('');
        };


        /**
         *  Return a random buffer
         *
         *  @param {Object} [options={}] can specify a length
         *  @returns {Buffer} a buffer of random length
         *  @throws {RangeError} length cannot be less than zero
         */
        Chance.prototype.buffer = function (options) {
            if (typeof Buffer === 'undefined') {
                throw new UnsupportedError('Sorry, the buffer() function is not supported on your platform');
            }
            options = initOptions(options, { length: this.natural({min: 5, max: 20}) });
            testRange(options.length < 0, "Chance: Length cannot be less than zero.");
            var length = options.length;
            var content = this.n(this.character, length, options);

            return Buffer.from(content);
        };

        // -- End Basics --

        // -- Helpers --

        Chance.prototype.capitalize = function (word) {
            return word.charAt(0).toUpperCase() + word.substr(1);
        };

        Chance.prototype.mixin = function (obj) {
            for (var func_name in obj) {
                Chance.prototype[func_name] = obj[func_name];
            }
            return this;
        };

        /**
         *  Given a function that generates something random and a number of items to generate,
         *    return an array of items where none repeat.
         *
         *  @param {Function} fn the function that generates something random
         *  @param {Number} num number of terms to generate
         *  @param {Object} options any options to pass on to the generator function
         *  @returns {Array} an array of length `num` with every item generated by `fn` and unique
         *
         *  There can be more parameters after these. All additional parameters are provided to the given function
         */
        Chance.prototype.unique = function(fn, num, options) {
            testRange(
                typeof fn !== "function",
                "Chance: The first argument must be a function."
            );

            var comparator = function(arr, val) { return arr.indexOf(val) !== -1; };

            if (options) {
                comparator = options.comparator || comparator;
            }

            var arr = [], count = 0, result, MAX_DUPLICATES = num * 50, params = slice.call(arguments, 2);

            while (arr.length < num) {
                var clonedParams = JSON.parse(JSON.stringify(params));
                result = fn.apply(this, clonedParams);
                if (!comparator(arr, result)) {
                    arr.push(result);
                    // reset count when unique found
                    count = 0;
                }

                if (++count > MAX_DUPLICATES) {
                    throw new RangeError("Chance: num is likely too large for sample set");
                }
            }
            return arr;
        };

        /**
         *  Gives an array of n random terms
         *
         *  @param {Function} fn the function that generates something random
         *  @param {Number} n number of terms to generate
         *  @returns {Array} an array of length `n` with items generated by `fn`
         *
         *  There can be more parameters after these. All additional parameters are provided to the given function
         */
        Chance.prototype.n = function(fn, n) {
            testRange(
                typeof fn !== "function",
                "Chance: The first argument must be a function."
            );

            if (typeof n === 'undefined') {
                n = 1;
            }
            var i = n, arr = [], params = slice.call(arguments, 2);

            // Providing a negative count should result in a noop.
            i = Math.max( 0, i );

            for (null; i--; null) {
                arr.push(fn.apply(this, params));
            }

            return arr;
        };

        // H/T to SO for this one: http://vq.io/OtUrZ5
        Chance.prototype.pad = function (number, width, pad) {
            // Default pad to 0 if none provided
            pad = pad || '0';
            // Convert number to a string
            number = number + '';
            return number.length >= width ? number : new Array(width - number.length + 1).join(pad) + number;
        };

        // DEPRECATED on 2015-10-01
        Chance.prototype.pick = function (arr, count) {
            if (arr.length === 0) {
                throw new RangeError("Chance: Cannot pick() from an empty array");
            }
            if (!count || count === 1) {
                return arr[this.natural({max: arr.length - 1})];
            } else {
                return this.shuffle(arr).slice(0, count);
            }
        };

        // Given an array, returns a single random element
        Chance.prototype.pickone = function (arr) {
            if (arr.length === 0) {
              throw new RangeError("Chance: Cannot pickone() from an empty array");
            }
            return arr[this.natural({max: arr.length - 1})];
        };

        // Given an array, returns a random set with 'count' elements
        Chance.prototype.pickset = function (arr, count) {
            if (count === 0) {
                return [];
            }
            if (arr.length === 0) {
                throw new RangeError("Chance: Cannot pickset() from an empty array");
            }
            if (count < 0) {
                throw new RangeError("Chance: Count must be a positive number");
            }
            if (!count || count === 1) {
                return [ this.pickone(arr) ];
            } else {
                var array = arr.slice(0);
                var end = array.length;

                return this.n(function () {
                    var index = this.natural({max: --end});
                    var value = array[index];
                    array[index] = array[end];
                    return value;
                }, Math.min(end, count));
            }
        };

        Chance.prototype.shuffle = function (arr) {
            var new_array = [],
                j = 0,
                length = Number(arr.length),
                source_indexes = range(length),
                last_source_index = length - 1,
                selected_source_index;

            for (var i = 0; i < length; i++) {
                // Pick a random index from the array
                selected_source_index = this.natural({max: last_source_index});
                j = source_indexes[selected_source_index];

                // Add it to the new array
                new_array[i] = arr[j];

                // Mark the source index as used
                source_indexes[selected_source_index] = source_indexes[last_source_index];
                last_source_index -= 1;
            }

            return new_array;
        };

        // Returns a single item from an array with relative weighting of odds
        Chance.prototype.weighted = function (arr, weights, trim) {
            if (arr.length !== weights.length) {
                throw new RangeError("Chance: Length of array and weights must match");
            }

            // scan weights array and sum valid entries
            var sum = 0;
            var val;
            for (var weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
                val = weights[weightIndex];
                if (isNaN(val)) {
                    throw new RangeError("Chance: All weights must be numbers");
                }

                if (val > 0) {
                    sum += val;
                }
            }

            if (sum === 0) {
                throw new RangeError("Chance: No valid entries in array weights");
            }

            // select a value within range
            var selected = this.random() * sum;

            // find array entry corresponding to selected value
            var total = 0;
            var lastGoodIdx = -1;
            var chosenIdx;
            for (weightIndex = 0; weightIndex < weights.length; ++weightIndex) {
                val = weights[weightIndex];
                total += val;
                if (val > 0) {
                    if (selected <= total) {
                        chosenIdx = weightIndex;
                        break;
                    }
                    lastGoodIdx = weightIndex;
                }

                // handle any possible rounding error comparison to ensure something is picked
                if (weightIndex === (weights.length - 1)) {
                    chosenIdx = lastGoodIdx;
                }
            }

            var chosen = arr[chosenIdx];
            trim = (typeof trim === 'undefined') ? false : trim;
            if (trim) {
                arr.splice(chosenIdx, 1);
                weights.splice(chosenIdx, 1);
            }

            return chosen;
        };

        // -- End Helpers --

        // -- Text --

        Chance.prototype.paragraph = function (options) {
            options = initOptions(options);

            var sentences = options.sentences || this.natural({min: 3, max: 7}),
                sentence_array = this.n(this.sentence, sentences),
                separator = options.linebreak === true ? '\n' : ' ';

            return sentence_array.join(separator);
        };

        // Could get smarter about this than generating random words and
        // chaining them together. Such as: http://vq.io/1a5ceOh
        Chance.prototype.sentence = function (options) {
            options = initOptions(options);

            var words = options.words || this.natural({min: 12, max: 18}),
                punctuation = options.punctuation,
                text, word_array = this.n(this.word, words);

            text = word_array.join(' ');

            // Capitalize first letter of sentence
            text = this.capitalize(text);

            // Make sure punctuation has a usable value
            if (punctuation !== false && !/^[.?;!:]$/.test(punctuation)) {
                punctuation = '.';
            }

            // Add punctuation mark
            if (punctuation) {
                text += punctuation;
            }

            return text;
        };

        Chance.prototype.syllable = function (options) {
            options = initOptions(options);

            var length = options.length || this.natural({min: 2, max: 3}),
                consonants = 'bcdfghjklmnprstvwz', // consonants except hard to speak ones
                vowels = 'aeiou', // vowels
                all = consonants + vowels, // all
                text = '',
                chr;

            // I'm sure there's a more elegant way to do this, but this works
            // decently well.
            for (var i = 0; i < length; i++) {
                if (i === 0) {
                    // First character can be anything
                    chr = this.character({pool: all});
                } else if (consonants.indexOf(chr) === -1) {
                    // Last character was a vowel, now we want a consonant
                    chr = this.character({pool: consonants});
                } else {
                    // Last character was a consonant, now we want a vowel
                    chr = this.character({pool: vowels});
                }

                text += chr;
            }

            if (options.capitalize) {
                text = this.capitalize(text);
            }

            return text;
        };

        Chance.prototype.word = function (options) {
            options = initOptions(options);

            testRange(
                options.syllables && options.length,
                "Chance: Cannot specify both syllables AND length."
            );

            var syllables = options.syllables || this.natural({min: 1, max: 3}),
                text = '';

            if (options.length) {
                // Either bound word by length
                do {
                    text += this.syllable();
                } while (text.length < options.length);
                text = text.substring(0, options.length);
            } else {
                // Or by number of syllables
                for (var i = 0; i < syllables; i++) {
                    text += this.syllable();
                }
            }

            if (options.capitalize) {
                text = this.capitalize(text);
            }

            return text;
        };

        // -- End Text --

        // -- Person --

        Chance.prototype.age = function (options) {
            options = initOptions(options);
            var ageRange;

            switch (options.type) {
                case 'child':
                    ageRange = {min: 0, max: 12};
                    break;
                case 'teen':
                    ageRange = {min: 13, max: 19};
                    break;
                case 'adult':
                    ageRange = {min: 18, max: 65};
                    break;
                case 'senior':
                    ageRange = {min: 65, max: 100};
                    break;
                case 'all':
                    ageRange = {min: 0, max: 100};
                    break;
                default:
                    ageRange = {min: 18, max: 65};
                    break;
            }

            return this.natural(ageRange);
        };

        Chance.prototype.birthday = function (options) {
            var age = this.age(options);
            var currentYear = new Date().getFullYear();

            if (options && options.type) {
                var min = new Date();
                var max = new Date();
                min.setFullYear(currentYear - age - 1);
                max.setFullYear(currentYear - age);

                options = initOptions(options, {
                    min: min,
                    max: max
                });
            } else {
                options = initOptions(options, {
                    year: currentYear - age
                });
            }

            return this.date(options);
        };

        // CPF; ID to identify taxpayers in Brazil
        Chance.prototype.cpf = function (options) {
            options = initOptions(options, {
                formatted: true
            });

            var n = this.n(this.natural, 9, { max: 9 });
            var d1 = n[8]*2+n[7]*3+n[6]*4+n[5]*5+n[4]*6+n[3]*7+n[2]*8+n[1]*9+n[0]*10;
            d1 = 11 - (d1 % 11);
            if (d1>=10) {
                d1 = 0;
            }
            var d2 = d1*2+n[8]*3+n[7]*4+n[6]*5+n[5]*6+n[4]*7+n[3]*8+n[2]*9+n[1]*10+n[0]*11;
            d2 = 11 - (d2 % 11);
            if (d2>=10) {
                d2 = 0;
            }
            var cpf = ''+n[0]+n[1]+n[2]+'.'+n[3]+n[4]+n[5]+'.'+n[6]+n[7]+n[8]+'-'+d1+d2;
            return options.formatted ? cpf : cpf.replace(/\D/g,'');
        };

        // CNPJ: ID to identify companies in Brazil
        Chance.prototype.cnpj = function (options) {
            options = initOptions(options, {
                formatted: true
            });

            var n = this.n(this.natural, 12, { max: 12 });
            var d1 = n[11]*2+n[10]*3+n[9]*4+n[8]*5+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
            d1 = 11 - (d1 % 11);
            if (d1<2) {
                d1 = 0;
            }
            var d2 = d1*2+n[11]*3+n[10]*4+n[9]*5+n[8]*6+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
            d2 = 11 - (d2 % 11);
            if (d2<2) {
                d2 = 0;
            }
            var cnpj = ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/'+n[8]+n[9]+n[10]+n[11]+'-'+d1+d2;
            return options.formatted ? cnpj : cnpj.replace(/\D/g,'');
        };

        Chance.prototype.first = function (options) {
            options = initOptions(options, {gender: this.gender(), nationality: 'en'});
            return this.pick(this.get("firstNames")[options.gender.toLowerCase()][options.nationality.toLowerCase()]);
        };

        Chance.prototype.profession = function (options) {
            options = initOptions(options);
            if(options.rank){
                return this.pick(['Apprentice ', 'Junior ', 'Senior ', 'Lead ']) + this.pick(this.get("profession"));
            } else {
                return this.pick(this.get("profession"));
            }
        };

        Chance.prototype.company = function (){
            return this.pick(this.get("company"));
        };

        Chance.prototype.gender = function (options) {
            options = initOptions(options, {extraGenders: []});
            return this.pick(['Male', 'Female'].concat(options.extraGenders));
        };

        Chance.prototype.last = function (options) {
          options = initOptions(options, {nationality: '*'});
          if (options.nationality === "*") {
            var allLastNames = [];
            var lastNames = this.get("lastNames");
            Object.keys(lastNames).forEach(function(key){
              allLastNames = allLastNames.concat(lastNames[key]);
            });
            return this.pick(allLastNames)
          }
          else {
            return this.pick(this.get("lastNames")[options.nationality.toLowerCase()]);
          }

        };

        Chance.prototype.israelId=function(){
            var x=this.string({pool: '0123456789',length:8});
            var y=0;
            for (var i=0;i<x.length;i++){
                var thisDigit=  x[i] *  (i/2===parseInt(i/2) ? 1 : 2);
                thisDigit=this.pad(thisDigit,2).toString();
                thisDigit=parseInt(thisDigit[0]) + parseInt(thisDigit[1]);
                y=y+thisDigit;
            }
            x=x+(10-parseInt(y.toString().slice(-1))).toString().slice(-1);
            return x;
        };

        Chance.prototype.mrz = function (options) {
            var checkDigit = function (input) {
                var alpha = "<ABCDEFGHIJKLMNOPQRSTUVWXYXZ".split(''),
                    multipliers = [ 7, 3, 1 ],
                    runningTotal = 0;

                if (typeof input !== 'string') {
                    input = input.toString();
                }

                input.split('').forEach(function(character, idx) {
                    var pos = alpha.indexOf(character);

                    if(pos !== -1) {
                        character = pos === 0 ? 0 : pos + 9;
                    } else {
                        character = parseInt(character, 10);
                    }
                    character *= multipliers[idx % multipliers.length];
                    runningTotal += character;
                });
                return runningTotal % 10;
            };
            var generate = function (opts) {
                var pad = function (length) {
                    return new Array(length + 1).join('<');
                };
                var number = [ 'P<',
                               opts.issuer,
                               opts.last.toUpperCase(),
                               '<<',
                               opts.first.toUpperCase(),
                               pad(39 - (opts.last.length + opts.first.length + 2)),
                               opts.passportNumber,
                               checkDigit(opts.passportNumber),
                               opts.nationality,
                               opts.dob,
                               checkDigit(opts.dob),
                               opts.gender,
                               opts.expiry,
                               checkDigit(opts.expiry),
                               pad(14),
                               checkDigit(pad(14)) ].join('');

                return number +
                    (checkDigit(number.substr(44, 10) +
                                number.substr(57, 7) +
                                number.substr(65, 7)));
            };

            var that = this;

            options = initOptions(options, {
                first: this.first(),
                last: this.last(),
                passportNumber: this.integer({min: 100000000, max: 999999999}),
                dob: (function () {
                    var date = that.birthday({type: 'adult'});
                    return [date.getFullYear().toString().substr(2),
                            that.pad(date.getMonth() + 1, 2),
                            that.pad(date.getDate(), 2)].join('');
                }()),
                expiry: (function () {
                    var date = new Date();
                    return [(date.getFullYear() + 5).toString().substr(2),
                            that.pad(date.getMonth() + 1, 2),
                            that.pad(date.getDate(), 2)].join('');
                }()),
                gender: this.gender() === 'Female' ? 'F': 'M',
                issuer: 'GBR',
                nationality: 'GBR'
            });
            return generate (options);
        };

        Chance.prototype.name = function (options) {
            options = initOptions(options);

            var first = this.first(options),
                last = this.last(options),
                name;

            if (options.middle) {
                name = first + ' ' + this.first(options) + ' ' + last;
            } else if (options.middle_initial) {
                name = first + ' ' + this.character({alpha: true, casing: 'upper'}) + '. ' + last;
            } else {
                name = first + ' ' + last;
            }

            if (options.prefix) {
                name = this.prefix(options) + ' ' + name;
            }

            if (options.suffix) {
                name = name + ' ' + this.suffix(options);
            }

            return name;
        };

        // Return the list of available name prefixes based on supplied gender.
        // @todo introduce internationalization
        Chance.prototype.name_prefixes = function (gender) {
            gender = gender || "all";
            gender = gender.toLowerCase();

            var prefixes = [
                { name: 'Doctor', abbreviation: 'Dr.' }
            ];

            if (gender === "male" || gender === "all") {
                prefixes.push({ name: 'Mister', abbreviation: 'Mr.' });
            }

            if (gender === "female" || gender === "all") {
                prefixes.push({ name: 'Miss', abbreviation: 'Miss' });
                prefixes.push({ name: 'Misses', abbreviation: 'Mrs.' });
            }

            return prefixes;
        };

        // Alias for name_prefix
        Chance.prototype.prefix = function (options) {
            return this.name_prefix(options);
        };

        Chance.prototype.name_prefix = function (options) {
            options = initOptions(options, { gender: "all" });
            return options.full ?
                this.pick(this.name_prefixes(options.gender)).name :
                this.pick(this.name_prefixes(options.gender)).abbreviation;
        };
        //Hungarian ID number
        Chance.prototype.HIDN= function(){
         //Hungarian ID nuber structure: XXXXXXYY (X=number,Y=Capital Latin letter)
          var idn_pool="0123456789";
          var idn_chrs="ABCDEFGHIJKLMNOPQRSTUVWXYXZ";
          var idn="";
            idn+=this.string({pool:idn_pool,length:6});
            idn+=this.string({pool:idn_chrs,length:2});
            return idn;
        };


        Chance.prototype.ssn = function (options) {
            options = initOptions(options, {ssnFour: false, dashes: true});
            var ssn_pool = "1234567890",
                ssn,
                dash = options.dashes ? '-' : '';

            if(!options.ssnFour) {
                ssn = this.string({pool: ssn_pool, length: 3}) + dash +
                this.string({pool: ssn_pool, length: 2}) + dash +
                this.string({pool: ssn_pool, length: 4});
            } else {
                ssn = this.string({pool: ssn_pool, length: 4});
            }
            return ssn;
        };

        // Aadhar is similar to ssn, used in India to uniquely identify a person
        Chance.prototype.aadhar = function (options) {
            options = initOptions(options, {onlyLastFour: false, separatedByWhiteSpace: true});
            var aadhar_pool = "1234567890",
                aadhar,
                whiteSpace = options.separatedByWhiteSpace ? ' ' : '';

            if(!options.onlyLastFour) {
                aadhar = this.string({pool: aadhar_pool, length: 4}) + whiteSpace +
                this.string({pool: aadhar_pool, length: 4}) + whiteSpace +
                this.string({pool: aadhar_pool, length: 4});
            } else {
                aadhar = this.string({pool: aadhar_pool, length: 4});
            }
            return aadhar;
        };

        // Return the list of available name suffixes
        // @todo introduce internationalization
        Chance.prototype.name_suffixes = function () {
            var suffixes = [
                { name: 'Doctor of Osteopathic Medicine', abbreviation: 'D.O.' },
                { name: 'Doctor of Philosophy', abbreviation: 'Ph.D.' },
                { name: 'Esquire', abbreviation: 'Esq.' },
                { name: 'Junior', abbreviation: 'Jr.' },
                { name: 'Juris Doctor', abbreviation: 'J.D.' },
                { name: 'Master of Arts', abbreviation: 'M.A.' },
                { name: 'Master of Business Administration', abbreviation: 'M.B.A.' },
                { name: 'Master of Science', abbreviation: 'M.S.' },
                { name: 'Medical Doctor', abbreviation: 'M.D.' },
                { name: 'Senior', abbreviation: 'Sr.' },
                { name: 'The Third', abbreviation: 'III' },
                { name: 'The Fourth', abbreviation: 'IV' },
                { name: 'Bachelor of Engineering', abbreviation: 'B.E' },
                { name: 'Bachelor of Technology', abbreviation: 'B.TECH' }
            ];
            return suffixes;
        };

        // Alias for name_suffix
        Chance.prototype.suffix = function (options) {
            return this.name_suffix(options);
        };

        Chance.prototype.name_suffix = function (options) {
            options = initOptions(options);
            return options.full ?
                this.pick(this.name_suffixes()).name :
                this.pick(this.name_suffixes()).abbreviation;
        };

        Chance.prototype.nationalities = function () {
            return this.get("nationalities");
        };

        // Generate random nationality based on json list
        Chance.prototype.nationality = function () {
            var nationality = this.pick(this.nationalities());
            return nationality.name;
        };

        // -- End Person --

        // -- Mobile --
        // Android GCM Registration ID
        Chance.prototype.android_id = function () {
            return "APA91" + this.string({ pool: "0123456789abcefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_", length: 178 });
        };

        // Apple Push Token
        Chance.prototype.apple_token = function () {
            return this.string({ pool: "abcdef1234567890", length: 64 });
        };

        // Windows Phone 8 ANID2
        Chance.prototype.wp8_anid2 = function () {
            return base64( this.hash( { length : 32 } ) );
        };

        // Windows Phone 7 ANID
        Chance.prototype.wp7_anid = function () {
            return 'A=' + this.guid().replace(/-/g, '').toUpperCase() + '&E=' + this.hash({ length:3 }) + '&W=' + this.integer({ min:0, max:9 });
        };

        // BlackBerry Device PIN
        Chance.prototype.bb_pin = function () {
            return this.hash({ length: 8 });
        };

        // -- End Mobile --

        // -- Web --
        Chance.prototype.avatar = function (options) {
            var url = null;
            var URL_BASE = '//www.gravatar.com/avatar/';
            var PROTOCOLS = {
                http: 'http',
                https: 'https'
            };
            var FILE_TYPES = {
                bmp: 'bmp',
                gif: 'gif',
                jpg: 'jpg',
                png: 'png'
            };
            var FALLBACKS = {
                '404': '404', // Return 404 if not found
                mm: 'mm', // Mystery man
                identicon: 'identicon', // Geometric pattern based on hash
                monsterid: 'monsterid', // A generated monster icon
                wavatar: 'wavatar', // A generated face
                retro: 'retro', // 8-bit icon
                blank: 'blank' // A transparent png
            };
            var RATINGS = {
                g: 'g',
                pg: 'pg',
                r: 'r',
                x: 'x'
            };
            var opts = {
                protocol: null,
                email: null,
                fileExtension: null,
                size: null,
                fallback: null,
                rating: null
            };

            if (!options) {
                // Set to a random email
                opts.email = this.email();
                options = {};
            }
            else if (typeof options === 'string') {
                opts.email = options;
                options = {};
            }
            else if (typeof options !== 'object') {
                return null;
            }
            else if (options.constructor === 'Array') {
                return null;
            }

            opts = initOptions(options, opts);

            if (!opts.email) {
                // Set to a random email
                opts.email = this.email();
            }

            // Safe checking for params
            opts.protocol = PROTOCOLS[opts.protocol] ? opts.protocol + ':' : '';
            opts.size = parseInt(opts.size, 0) ? opts.size : '';
            opts.rating = RATINGS[opts.rating] ? opts.rating : '';
            opts.fallback = FALLBACKS[opts.fallback] ? opts.fallback : '';
            opts.fileExtension = FILE_TYPES[opts.fileExtension] ? opts.fileExtension : '';

            url =
                opts.protocol +
                URL_BASE +
                this.bimd5.md5(opts.email) +
                (opts.fileExtension ? '.' + opts.fileExtension : '') +
                (opts.size || opts.rating || opts.fallback ? '?' : '') +
                (opts.size ? '&s=' + opts.size.toString() : '') +
                (opts.rating ? '&r=' + opts.rating : '') +
                (opts.fallback ? '&d=' + opts.fallback : '')
                ;

            return url;
        };

        /**
         * #Description:
         * ===============================================
         * Generate random color value base on color type:
         * -> hex
         * -> rgb
         * -> rgba
         * -> 0x
         * -> named color
         *
         * #Examples:
         * ===============================================
         * * Geerate random hex color
         * chance.color() => '#79c157' / 'rgb(110,52,164)' / '0x67ae0b' / '#e2e2e2' / '#29CFA7'
         *
         * * Generate Hex based color value
         * chance.color({format: 'hex'})    => '#d67118'
         *
         * * Generate simple rgb value
         * chance.color({format: 'rgb'})    => 'rgb(110,52,164)'
         *
         * * Generate Ox based color value
         * chance.color({format: '0x'})     => '0x67ae0b'
         *
         * * Generate graiscale based value
         * chance.color({grayscale: true})  => '#e2e2e2'
         *
         * * Return valide color name
         * chance.color({format: 'name'})   => 'red'
         *
         * * Make color uppercase
         * chance.color({casing: 'upper'})  => '#29CFA7'
         *
         * * Min Max values for RGBA
         * var light_red = chance.color({format: 'hex', min_red: 200, max_red: 255, max_green: 0, max_blue: 0, min_alpha: .2, max_alpha: .3});
         *
         * @param  [object] options
         * @return [string] color value
         */
        Chance.prototype.color = function (options) {
            function gray(value, delimiter) {
                return [value, value, value].join(delimiter || '');
            }

            function rgb(hasAlpha) {
                var rgbValue     = (hasAlpha)    ? 'rgba' : 'rgb';
                var alphaChannel = (hasAlpha)    ? (',' + this.floating({min:min_alpha, max:max_alpha})) : "";
                var colorValue   = (isGrayscale) ? (gray(this.natural({min: min_rgb, max: max_rgb}), ',')) : (this.natural({min: min_green, max: max_green}) + ',' + this.natural({min: min_blue, max: max_blue}) + ',' + this.natural({max: 255}));
                return rgbValue + '(' + colorValue + alphaChannel + ')';
            }

            function hex(start, end, withHash) {
                var symbol = (withHash) ? "#" : "";
                var hexstring = "";

                if (isGrayscale) {
                    hexstring = gray(this.pad(this.hex({min: min_rgb, max: max_rgb}), 2));
                    if (options.format === "shorthex") {
                        hexstring = gray(this.hex({min: 0, max: 15}));
                    }
                }
                else {
                    if (options.format === "shorthex") {
                        hexstring = this.pad(this.hex({min: Math.floor(min_red / 16), max: Math.floor(max_red / 16)}), 1) + this.pad(this.hex({min: Math.floor(min_green / 16), max: Math.floor(max_green / 16)}), 1) + this.pad(this.hex({min: Math.floor(min_blue / 16), max: Math.floor(max_blue / 16)}), 1);
                    }
                    else if (min_red !== undefined || max_red !== undefined || min_green !== undefined || max_green !== undefined || min_blue !== undefined || max_blue !== undefined) {
                        hexstring = this.pad(this.hex({min: min_red, max: max_red}), 2) + this.pad(this.hex({min: min_green, max: max_green}), 2) + this.pad(this.hex({min: min_blue, max: max_blue}), 2);
                    }
                    else {
                        hexstring = this.pad(this.hex({min: min_rgb, max: max_rgb}), 2) + this.pad(this.hex({min: min_rgb, max: max_rgb}), 2) + this.pad(this.hex({min: min_rgb, max: max_rgb}), 2);
                    }
                }

                return symbol + hexstring;
            }

            options = initOptions(options, {
                format: this.pick(['hex', 'shorthex', 'rgb', 'rgba', '0x', 'name']),
                grayscale: false,
                casing: 'lower',
                min: 0,
                max: 255,
                min_red: undefined,
                max_red: undefined,
                min_green: undefined,
                max_green: undefined,
                min_blue: undefined,
                max_blue: undefined,
                min_alpha: 0,
                max_alpha: 1
            });

            var isGrayscale = options.grayscale;
            var min_rgb = options.min;
            var max_rgb = options.max;
            var min_red = options.min_red;
            var max_red = options.max_red;
            var min_green = options.min_green;
            var max_green = options.max_green;
            var min_blue = options.min_blue;
            var max_blue = options.max_blue;
            var min_alpha = options.min_alpha;
            var max_alpha = options.max_alpha;
            if (options.min_red === undefined) { min_red = min_rgb; }
            if (options.max_red === undefined) { max_red = max_rgb; }
            if (options.min_green === undefined) { min_green = min_rgb; }
            if (options.max_green === undefined) { max_green = max_rgb; }
            if (options.min_blue === undefined) { min_blue = min_rgb; }
            if (options.max_blue === undefined) { max_blue = max_rgb; }
            if (options.min_alpha === undefined) { min_alpha = 0; }
            if (options.max_alpha === undefined) { max_alpha = 1; }
            if (isGrayscale && min_rgb === 0 && max_rgb === 255 && min_red !== undefined && max_red !== undefined) {
                min_rgb = ((min_red + min_green + min_blue) / 3);
                max_rgb = ((max_red + max_green + max_blue) / 3);
            }
            var colorValue;

            if (options.format === 'hex') {
                colorValue = hex.call(this, 2, 6, true);
            }
            else if (options.format === 'shorthex') {
                colorValue = hex.call(this, 1, 3, true);
            }
            else if (options.format === 'rgb') {
                colorValue = rgb.call(this, false);
            }
            else if (options.format === 'rgba') {
                colorValue = rgb.call(this, true);
            }
            else if (options.format === '0x') {
                colorValue = '0x' + hex.call(this, 2, 6);
            }
            else if(options.format === 'name') {
                return this.pick(this.get("colorNames"));
            }
            else {
                throw new RangeError('Invalid format provided. Please provide one of "hex", "shorthex", "rgb", "rgba", "0x" or "name".');
            }

            if (options.casing === 'upper' ) {
                colorValue = colorValue.toUpperCase();
            }

            return colorValue;
        };

        Chance.prototype.domain = function (options) {
            options = initOptions(options);
            return this.word() + '.' + (options.tld || this.tld());
        };

        Chance.prototype.email = function (options) {
            options = initOptions(options);
            return this.word({length: options.length}) + '@' + (options.domain || this.domain());
        };

        /**
         * #Description:
         * ===============================================
         * Generate a random Facebook id, aka fbid.
         *
         * NOTE: At the moment (Sep 2017), Facebook ids are
         * "numeric strings" of length 16.
         * However, Facebook Graph API documentation states that
         * "it is extremely likely to change over time".
         * @see https://developers.facebook.com/docs/graph-api/overview/
         *
         * #Examples:
         * ===============================================
         * chance.fbid() => '1000035231661304'
         *
         * @return [string] facebook id
         */
        Chance.prototype.fbid = function () {
            return '10000' + this.string({pool: "1234567890", length: 11});
        };

        Chance.prototype.google_analytics = function () {
            var account = this.pad(this.natural({max: 999999}), 6);
            var property = this.pad(this.natural({max: 99}), 2);

            return 'UA-' + account + '-' + property;
        };

        Chance.prototype.hashtag = function () {
            return '#' + this.word();
        };

        Chance.prototype.ip = function () {
            // Todo: This could return some reserved IPs. See http://vq.io/137dgYy
            // this should probably be updated to account for that rare as it may be
            return this.natural({min: 1, max: 254}) + '.' +
                   this.natural({max: 255}) + '.' +
                   this.natural({max: 255}) + '.' +
                   this.natural({min: 1, max: 254});
        };

        Chance.prototype.ipv6 = function () {
            var ip_addr = this.n(this.hash, 8, {length: 4});

            return ip_addr.join(":");
        };

        Chance.prototype.klout = function () {
            return this.natural({min: 1, max: 99});
        };

        Chance.prototype.semver = function (options) {
            options = initOptions(options, { include_prerelease: true });

            var range = this.pickone(["^", "~", "<", ">", "<=", ">=", "="]);
            if (options.range) {
                range = options.range;
            }

            var prerelease = "";
            if (options.include_prerelease) {
                prerelease = this.weighted(["", "-dev", "-beta", "-alpha"], [50, 10, 5, 1]);
            }
            return range + this.rpg('3d10').join('.') + prerelease;
        };

        Chance.prototype.tlds = function () {
            return ['com', 'org', 'edu', 'gov', 'co.uk', 'net', 'io', 'ac', 'ad', 'ae', 'af', 'ag', 'ai', 'al', 'am', 'ao', 'aq', 'ar', 'as', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'bj', 'bm', 'bn', 'bo', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'cr', 'cu', 'cv', 'cw', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'ee', 'eg', 'eh', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mk', 'ml', 'mm', 'mn', 'mo', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'nc', 'ne', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'ss', 'st', 'su', 'sv', 'sx', 'sy', 'sz', 'tc', 'td', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'za', 'zm', 'zw'];
        };

        Chance.prototype.tld = function () {
            return this.pick(this.tlds());
        };

        Chance.prototype.twitter = function () {
            return '@' + this.word();
        };

        Chance.prototype.url = function (options) {
            options = initOptions(options, { protocol: "http", domain: this.domain(options), domain_prefix: "", path: this.word(), extensions: []});

            var extension = options.extensions.length > 0 ? "." + this.pick(options.extensions) : "";
            var domain = options.domain_prefix ? options.domain_prefix + "." + options.domain : options.domain;

            return options.protocol + "://" + domain + "/" + options.path + extension;
        };

        Chance.prototype.port = function() {
            return this.integer({min: 0, max: 65535});
        };

        Chance.prototype.locale = function (options) {
            options = initOptions(options);
            if (options.region){
              return this.pick(this.get("locale_regions"));
            } else {
              return this.pick(this.get("locale_languages"));
            }
        };

        Chance.prototype.locales = function (options) {
          options = initOptions(options);
          if (options.region){
            return this.get("locale_regions");
          } else {
            return this.get("locale_languages");
          }
        };

        Chance.prototype.loremPicsum = function (options) {
            options = initOptions(options, { width: 500, height: 500, greyscale: false, blurred: false });

            var greyscale = options.greyscale ? 'g/' : '';
            var query = options.blurred ? '/?blur' : '/?random';

            return 'https://picsum.photos/' + greyscale + options.width + '/' + options.height + query;
        };

        // -- End Web --

        // -- Location --

        Chance.prototype.address = function (options) {
            options = initOptions(options);
            return this.natural({min: 5, max: 2000}) + ' ' + this.street(options);
        };

        Chance.prototype.altitude = function (options) {
            options = initOptions(options, {fixed: 5, min: 0, max: 8848});
            return this.floating({
                min: options.min,
                max: options.max,
                fixed: options.fixed
            });
        };

        Chance.prototype.areacode = function (options) {
            options = initOptions(options, {parens : true});
            // Don't want area codes to start with 1, or have a 9 as the second digit
            var areacode = this.natural({min: 2, max: 9}).toString() +
                    this.natural({min: 0, max: 8}).toString() +
                    this.natural({min: 0, max: 9}).toString();

            return options.parens ? '(' + areacode + ')' : areacode;
        };

        Chance.prototype.city = function () {
            return this.capitalize(this.word({syllables: 3}));
        };

        Chance.prototype.coordinates = function (options) {
            return this.latitude(options) + ', ' + this.longitude(options);
        };

        Chance.prototype.countries = function () {
            return this.get("countries");
        };

        Chance.prototype.country = function (options) {
            options = initOptions(options);
            var country = this.pick(this.countries());
            return options.raw ? country : options.full ? country.name : country.abbreviation;
        };

        Chance.prototype.depth = function (options) {
            options = initOptions(options, {fixed: 5, min: -10994, max: 0});
            return this.floating({
                min: options.min,
                max: options.max,
                fixed: options.fixed
            });
        };

        Chance.prototype.geohash = function (options) {
            options = initOptions(options, { length: 7 });
            return this.string({ length: options.length, pool: '0123456789bcdefghjkmnpqrstuvwxyz' });
        };

        Chance.prototype.geojson = function (options) {
            return this.latitude(options) + ', ' + this.longitude(options) + ', ' + this.altitude(options);
        };

        Chance.prototype.latitude = function (options) {
            // Constants - Formats
            const [DDM, DMS, DD] = ['ddm', 'dms', 'dd'];

            options = initOptions(options, 
                options && options.format && [DDM, DMS].includes(options.format.toLowerCase()) ?
                {min: 0, max: 89, fixed: 4} :
                {fixed: 5, min: -90, max: 90, format: DD});

            const format = options.format.toLowerCase();
            
            if (format === DDM || format === DMS) {
                testRange(options.min < 0 || options.min > 89, "Chance: Min specified is out of range. Should be between 0 - 89");
                testRange(options.max < 0 || options.max > 89, "Chance: Max specified is out of range. Should be between 0 - 89");
                testRange(options.fixed > 4, 'Chance: Fixed specified should be below or equal to 4');
            }

            switch (format) {
                case DDM: {
                    return  this.integer({min: options.min, max: options.max}) + '°' + 
                            this.floating({min: 0, max: 59, fixed: options.fixed});
                }
                case DMS: {
                    return  this.integer({min: options.min, max: options.max}) + '°' + 
                            this.integer({min: 0, max: 59}) + '’' + 
                            this.floating({min: 0, max: 59, fixed: options.fixed}) + '”';
                }
                case DD:
                default: {    
                    return this.floating({min: options.min, max: options.max, fixed: options.fixed});
                }
            }
        };

        Chance.prototype.longitude = function (options) {
            // Constants - Formats
            const [DDM, DMS, DD] = ['ddm', 'dms', 'dd'];

            options = initOptions(options, 
                options && options.format && [DDM, DMS].includes(options.format.toLowerCase()) ?
                {min: 0, max: 179, fixed: 4} :
                {fixed: 5, min: -180, max: 180, format: DD});

            const format = options.format.toLowerCase();

            if (format === DDM || format === DMS) {
                testRange(options.min < 0 || options.min > 179, "Chance: Min specified is out of range. Should be between 0 - 179");
                testRange(options.max < 0 || options.max > 179, "Chance: Max specified is out of range. Should be between 0 - 179");
                testRange(options.fixed > 4, 'Chance: Fixed specified should be below or equal to 4');
            }

            switch (format) {
                case DDM: {
                    return  this.integer({min: options.min, max: options.max}) + '°' + 
                            this.floating({min: 0, max: 59.9999, fixed: options.fixed})
                }
                case DMS: {
                    return  this.integer({min: options.min, max: options.max}) + '°' +
                            this.integer({min: 0, max: 59}) + '’' +
                            this.floating({min: 0, max: 59.9999, fixed: options.fixed}) + '”';
                }
                case DD:
                default: {    
                    return this.floating({min: options.min, max: options.max, fixed: options.fixed});
                }
            }
        };

        Chance.prototype.phone = function (options) {
            var self = this,
                numPick,
                ukNum = function (parts) {
                    var section = [];
                    //fills the section part of the phone number with random numbers.
                    parts.sections.forEach(function(n) {
                        section.push(self.string({ pool: '0123456789', length: n}));
                    });
                    return parts.area + section.join(' ');
                };
            options = initOptions(options, {
                formatted: true,
                country: 'us',
                mobile: false
            });
            if (!options.formatted) {
                options.parens = false;
            }
            var phone;
            switch (options.country) {
                case 'fr':
                    if (!options.mobile) {
                        numPick = this.pick([
                            // Valid zone and département codes.
                            '01' + this.pick(['30', '34', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '53', '55', '56', '58', '60', '64', '69', '70', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83']) + self.string({ pool: '0123456789', length: 6}),
                            '02' + this.pick(['14', '18', '22', '23', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '40', '41', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '56', '57', '61', '62', '69', '72', '76', '77', '78', '85', '90', '96', '97', '98', '99']) + self.string({ pool: '0123456789', length: 6}),
                            '03' + this.pick(['10', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '39', '44', '45', '51', '52', '54', '55', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90']) + self.string({ pool: '0123456789', length: 6}),
                            '04' + this.pick(['11', '13', '15', '20', '22', '26', '27', '30', '32', '34', '37', '42', '43', '44', '50', '56', '57', '63', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '88', '89', '90', '91', '92', '93', '94', '95', '97', '98']) + self.string({ pool: '0123456789', length: 6}),
                            '05' + this.pick(['08', '16', '17', '19', '24', '31', '32', '33', '34', '35', '40', '45', '46', '47', '49', '53', '55', '56', '57', '58', '59', '61', '62', '63', '64', '65', '67', '79', '81', '82', '86', '87', '90', '94']) + self.string({ pool: '0123456789', length: 6}),
                            '09' + self.string({ pool: '0123456789', length: 8}),
                        ]);
                        phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                    } else {
                        numPick = this.pick(['06', '07']) + self.string({ pool: '0123456789', length: 8});
                        phone = options.formatted ? numPick.match(/../g).join(' ') : numPick;
                    }
                    break;
                case 'uk':
                    if (!options.mobile) {
                        numPick = this.pick([
                            //valid area codes of major cities/counties followed by random numbers in required format.

                            { area: '01' + this.character({ pool: '234569' }) + '1 ', sections: [3,4] },
                            { area: '020 ' + this.character({ pool: '378' }), sections: [3,4] },
                            { area: '023 ' + this.character({ pool: '89' }), sections: [3,4] },
                            { area: '024 7', sections: [3,4] },
                            { area: '028 ' + this.pick(['25','28','37','71','82','90','92','95']), sections: [2,4] },
                            { area: '012' + this.pick(['04','08','54','76','97','98']) + ' ', sections: [6] },
                            { area: '013' + this.pick(['63','64','84','86']) + ' ', sections: [6] },
                            { area: '014' + this.pick(['04','20','60','61','80','88']) + ' ', sections: [6] },
                            { area: '015' + this.pick(['24','27','62','66']) + ' ', sections: [6] },
                            { area: '016' + this.pick(['06','29','35','47','59','95']) + ' ', sections: [6] },
                            { area: '017' + this.pick(['26','44','50','68']) + ' ', sections: [6] },
                            { area: '018' + this.pick(['27','37','84','97']) + ' ', sections: [6] },
                            { area: '019' + this.pick(['00','05','35','46','49','63','95']) + ' ', sections: [6] }
                        ]);
                        phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '', 'g');
                    } else {
                        numPick = this.pick([
                            { area: '07' + this.pick(['4','5','7','8','9']), sections: [2,6] },
                            { area: '07624 ', sections: [6] }
                        ]);
                        phone = options.formatted ? ukNum(numPick) : ukNum(numPick).replace(' ', '');
                    }
                    break;
                case 'za':
                    if (!options.mobile) {
                        numPick = this.pick([
                           '01' + this.pick(['0', '1', '2', '3', '4', '5', '6', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                           '02' + this.pick(['1', '2', '3', '4', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                           '03' + this.pick(['1', '2', '3', '5', '6', '9']) + self.string({ pool: '0123456789', length: 7}),
                           '04' + this.pick(['1', '2', '3', '4', '5','6','7', '8','9']) + self.string({ pool: '0123456789', length: 7}),
                           '05' + this.pick(['1', '3', '4', '6', '7', '8']) + self.string({ pool: '0123456789', length: 7}),
                        ]);
                        phone = options.formatted || numPick;
                    } else {
                        numPick = this.pick([
                            '060' + this.pick(['3','4','5','6','7','8','9']) + self.string({ pool: '0123456789', length: 6}),
                            '061' + this.pick(['0','1','2','3','4','5','8']) + self.string({ pool: '0123456789', length: 6}),
                            '06'  + self.string({ pool: '0123456789', length: 7}),
                            '071' + this.pick(['0','1','2','3','4','5','6','7','8','9']) + self.string({ pool: '0123456789', length: 6}),
                            '07'  + this.pick(['2','3','4','6','7','8','9']) + self.string({ pool: '0123456789', length: 7}),
                            '08'  + this.pick(['0','1','2','3','4','5']) + self.string({ pool: '0123456789', length: 7}),
                        ]);
                        phone = options.formatted || numPick;
                    }
                    break;
                case 'us':
                    var areacode = this.areacode(options).toString();
                    var exchange = this.natural({ min: 2, max: 9 }).toString() +
                        this.natural({ min: 0, max: 9 }).toString() +
                        this.natural({ min: 0, max: 9 }).toString();
                    var subscriber = this.natural({ min: 1000, max: 9999 }).toString(); // this could be random [0-9]{4}
                    phone = options.formatted ? areacode + ' ' + exchange + '-' + subscriber : areacode + exchange + subscriber;
                    break;
                case 'br':
                    var areaCode = this.pick(["11", "12", "13", "14", "15", "16", "17", "18", "19", "21", "22", "24", "27", "28", "31", "32", "33", "34", "35", "37", "38", "41", "42", "43", "44", "45", "46", "47", "48", "49", "51", "53", "54", "55", "61", "62", "63", "64", "65", "66", "67", "68", "69", "71", "73", "74", "75", "77", "79", "81", "82", "83", "84", "85", "86", "87", "88", "89", "91", "92", "93", "94", "95", "96", "97", "98", "99"]);
                    var prefix;
                    if (options.mobile) {
                        // Brasilian official reference (mobile): http://www.anatel.gov.br/setorregulado/plano-de-numeracao-brasileiro?id=330
                        prefix = '9' + self.string({ pool: '0123456789', length: 4});
                    } else {
                        // Brasilian official reference: http://www.anatel.gov.br/setorregulado/plano-de-numeracao-brasileiro?id=331
                        prefix = this.natural({ min: 2000, max: 5999 }).toString();
                    }
                    var mcdu = self.string({ pool: '0123456789', length: 4});
                    phone = options.formatted ? '(' + areaCode + ') ' + prefix + '-' + mcdu : areaCode + prefix + mcdu;
                    break;
            }
            return phone;
        };

        Chance.prototype.postal = function () {
            // Postal District
            var pd = this.character({pool: "XVTSRPNKLMHJGECBA"});
            // Forward Sortation Area (FSA)
            var fsa = pd + this.natural({max: 9}) + this.character({alpha: true, casing: "upper"});
            // Local Delivery Unut (LDU)
            var ldu = this.natural({max: 9}) + this.character({alpha: true, casing: "upper"}) + this.natural({max: 9});

            return fsa + " " + ldu;
        };

        Chance.prototype.postcode = function () {
            // Area
            var area = this.pick(this.get("postcodeAreas")).code;
            // District
            var district = this.natural({max: 9});
            // Sub-District
            var subDistrict = this.bool() ? this.character({alpha: true, casing: "upper"}) : "";
            // Outward Code
            var outward = area + district + subDistrict;
            // Sector
            var sector = this.natural({max: 9});
            // Unit
            var unit = this.character({alpha: true, casing: "upper"}) + this.character({alpha: true, casing: "upper"});
            // Inward Code
            var inward = sector + unit;

            return outward + " " + inward;
        };

        Chance.prototype.counties = function (options) {
            options = initOptions(options, { country: 'uk' });
            return this.get("counties")[options.country.toLowerCase()];
        };

        Chance.prototype.county = function (options) {
            return this.pick(this.counties(options)).name;
        };

        Chance.prototype.provinces = function (options) {
            options = initOptions(options, { country: 'ca' });
            return this.get("provinces")[options.country.toLowerCase()];
        };

        Chance.prototype.province = function (options) {
            return (options && options.full) ?
                this.pick(this.provinces(options)).name :
                this.pick(this.provinces(options)).abbreviation;
        };

        Chance.prototype.state = function (options) {
            return (options && options.full) ?
                this.pick(this.states(options)).name :
                this.pick(this.states(options)).abbreviation;
        };

        Chance.prototype.states = function (options) {
            options = initOptions(options, { country: 'us', us_states_and_dc: true } );

            var states;

            switch (options.country.toLowerCase()) {
                case 'us':
                    var us_states_and_dc = this.get("us_states_and_dc"),
                        territories = this.get("territories"),
                        armed_forces = this.get("armed_forces");

                    states = [];

                    if (options.us_states_and_dc) {
                        states = states.concat(us_states_and_dc);
                    }
                    if (options.territories) {
                        states = states.concat(territories);
                    }
                    if (options.armed_forces) {
                        states = states.concat(armed_forces);
                    }
                    break;
                case 'it':
                case 'mx':
                    states = this.get("country_regions")[options.country.toLowerCase()];
                    break;
                case 'uk':
                    states = this.get("counties")[options.country.toLowerCase()];
                    break;
            }

            return states;
        };

        Chance.prototype.street = function (options) {
            options = initOptions(options, { country: 'us', syllables: 2 });
            var     street;

            switch (options.country.toLowerCase()) {
                case 'us':
                    street = this.word({ syllables: options.syllables });
                    street = this.capitalize(street);
                    street += ' ';
                    street += options.short_suffix ?
                        this.street_suffix(options).abbreviation :
                        this.street_suffix(options).name;
                    break;
                case 'it':
                    street = this.word({ syllables: options.syllables });
                    street = this.capitalize(street);
                    street = (options.short_suffix ?
                        this.street_suffix(options).abbreviation :
                        this.street_suffix(options).name) + " " + street;
                    break;
            }
            return street;
        };

        Chance.prototype.street_suffix = function (options) {
            options = initOptions(options, { country: 'us' });
            return this.pick(this.street_suffixes(options));
        };

        Chance.prototype.street_suffixes = function (options) {
            options = initOptions(options, { country: 'us' });
            // These are the most common suffixes.
            return this.get("street_suffixes")[options.country.toLowerCase()];
        };

        // Note: only returning US zip codes, internationalization will be a whole
        // other beast to tackle at some point.
        Chance.prototype.zip = function (options) {
            var zip = this.n(this.natural, 5, {max: 9});

            if (options && options.plusfour === true) {
                zip.push('-');
                zip = zip.concat(this.n(this.natural, 4, {max: 9}));
            }

            return zip.join("");
        };

        // -- End Location --

        // -- Time

        Chance.prototype.ampm = function () {
            return this.bool() ? 'am' : 'pm';
        };

        Chance.prototype.date = function (options) {
            var date_string, date;

            // If interval is specified we ignore preset
            if(options && (options.min || options.max)) {
                options = initOptions(options, {
                    american: true,
                    string: false
                });
                var min = typeof options.min !== "undefined" ? options.min.getTime() : 1;
                // 100,000,000 days measured relative to midnight at the beginning of 01 January, 1970 UTC. http://es5.github.io/#x15.9.1.1
                var max = typeof options.max !== "undefined" ? options.max.getTime() : 8640000000000000;

                date = new Date(this.integer({min: min, max: max}));
            } else {
                var m = this.month({raw: true});
                var daysInMonth = m.days;

                if(options && options.month) {
                    // Mod 12 to allow months outside range of 0-11 (not encouraged, but also not prevented).
                    daysInMonth = this.get('months')[((options.month % 12) + 12) % 12].days;
                }

                options = initOptions(options, {
                    year: parseInt(this.year(), 10),
                    // Necessary to subtract 1 because Date() 0-indexes month but not day or year
                    // for some reason.
                    month: m.numeric - 1,
                    day: this.natural({min: 1, max: daysInMonth}),
                    hour: this.hour({twentyfour: true}),
                    minute: this.minute(),
                    second: this.second(),
                    millisecond: this.millisecond(),
                    american: true,
                    string: false
                });

                date = new Date(options.year, options.month, options.day, options.hour, options.minute, options.second, options.millisecond);
            }

            if (options.american) {
                // Adding 1 to the month is necessary because Date() 0-indexes
                // months but not day for some odd reason.
                date_string = (date.getMonth() + 1) + '/' + date.getDate() + '/' + date.getFullYear();
            } else {
                date_string = date.getDate() + '/' + (date.getMonth() + 1) + '/' + date.getFullYear();
            }

            return options.string ? date_string : date;
        };

        Chance.prototype.hammertime = function (options) {
            return this.date(options).getTime();
        };

        Chance.prototype.hour = function (options) {
            options = initOptions(options, {
                min: options && options.twentyfour ? 0 : 1,
                max: options && options.twentyfour ? 23 : 12
            });

            testRange(options.min < 0, "Chance: Min cannot be less than 0.");
            testRange(options.twentyfour && options.max > 23, "Chance: Max cannot be greater than 23 for twentyfour option.");
            testRange(!options.twentyfour && options.max > 12, "Chance: Max cannot be greater than 12.");
            testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

            return this.natural({min: options.min, max: options.max});
        };

        Chance.prototype.millisecond = function () {
            return this.natural({max: 999});
        };

        Chance.prototype.minute = Chance.prototype.second = function (options) {
            options = initOptions(options, {min: 0, max: 59});

            testRange(options.min < 0, "Chance: Min cannot be less than 0.");
            testRange(options.max > 59, "Chance: Max cannot be greater than 59.");
            testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

            return this.natural({min: options.min, max: options.max});
        };

        Chance.prototype.month = function (options) {
            options = initOptions(options, {min: 1, max: 12});

            testRange(options.min < 1, "Chance: Min cannot be less than 1.");
            testRange(options.max > 12, "Chance: Max cannot be greater than 12.");
            testRange(options.min > options.max, "Chance: Min cannot be greater than Max.");

            var month = this.pick(this.months().slice(options.min - 1, options.max));
            return options.raw ? month : month.name;
        };

        Chance.prototype.months = function () {
            return this.get("months");
        };

        Chance.prototype.second = function () {
            return this.natural({max: 59});
        };

        Chance.prototype.timestamp = function () {
            return this.natural({min: 1, max: parseInt(new Date().getTime() / 1000, 10)});
        };

        Chance.prototype.weekday = function (options) {
            options = initOptions(options, {weekday_only: false});
            var weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];
            if (!options.weekday_only) {
                weekdays.push("Saturday");
                weekdays.push("Sunday");
            }
            return this.pickone(weekdays);
        };

        Chance.prototype.year = function (options) {
            // Default to current year as min if none specified
            options = initOptions(options, {min: new Date().getFullYear()});

            // Default to one century after current year as max if none specified
            options.max = (typeof options.max !== "undefined") ? options.max : options.min + 100;

            return this.natural(options).toString();
        };

        // -- End Time

        // -- Finance --

        Chance.prototype.cc = function (options) {
            options = initOptions(options);

            var type, number, to_generate;

            type = (options.type) ?
                        this.cc_type({ name: options.type, raw: true }) :
                        this.cc_type({ raw: true });

            number = type.prefix.split("");
            to_generate = type.length - type.prefix.length - 1;

            // Generates n - 1 digits
            number = number.concat(this.n(this.integer, to_generate, {min: 0, max: 9}));

            // Generates the last digit according to Luhn algorithm
            number.push(this.luhn_calculate(number.join("")));

            return number.join("");
        };

        Chance.prototype.cc_types = function () {
            // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
            return this.get("cc_types");
        };

        Chance.prototype.cc_type = function (options) {
            options = initOptions(options);
            var types = this.cc_types(),
                type = null;

            if (options.name) {
                for (var i = 0; i < types.length; i++) {
                    // Accept either name or short_name to specify card type
                    if (types[i].name === options.name || types[i].short_name === options.name) {
                        type = types[i];
                        break;
                    }
                }
                if (type === null) {
                    throw new RangeError("Chance: Credit card type '" + options.name + "' is not supported");
                }
            } else {
                type = this.pick(types);
            }

            return options.raw ? type : type.name;
        };

        // return all world currency by ISO 4217
        Chance.prototype.currency_types = function () {
            return this.get("currency_types");
        };

        // return random world currency by ISO 4217
        Chance.prototype.currency = function () {
            return this.pick(this.currency_types());
        };

        // return all timezones available
        Chance.prototype.timezones = function () {
            return this.get("timezones");
        };

        // return random timezone
        Chance.prototype.timezone = function () {
            return this.pick(this.timezones());
        };

        //Return random correct currency exchange pair (e.g. EUR/USD) or array of currency code
        Chance.prototype.currency_pair = function (returnAsString) {
            var currencies = this.unique(this.currency, 2, {
                comparator: function(arr, val) {

                    return arr.reduce(function(acc, item) {
                        // If a match has been found, short circuit check and just return
                        return acc || (item.code === val.code);
                    }, false);
                }
            });

            if (returnAsString) {
                return currencies[0].code + '/' + currencies[1].code;
            } else {
                return currencies;
            }
        };

        Chance.prototype.dollar = function (options) {
            // By default, a somewhat more sane max for dollar than all available numbers
            options = initOptions(options, {max : 10000, min : 0});

            var dollar = this.floating({min: options.min, max: options.max, fixed: 2}).toString(),
                cents = dollar.split('.')[1];

            if (cents === undefined) {
                dollar += '.00';
            } else if (cents.length < 2) {
                dollar = dollar + '0';
            }

            if (dollar < 0) {
                return '-$' + dollar.replace('-', '');
            } else {
                return '$' + dollar;
            }
        };

        Chance.prototype.euro = function (options) {
            return Number(this.dollar(options).replace("$", "")).toLocaleString() + "€";
        };

        Chance.prototype.exp = function (options) {
            options = initOptions(options);
            var exp = {};

            exp.year = this.exp_year();

            // If the year is this year, need to ensure month is greater than the
            // current month or this expiration will not be valid
            if (exp.year === (new Date().getFullYear()).toString()) {
                exp.month = this.exp_month({future: true});
            } else {
                exp.month = this.exp_month();
            }

            return options.raw ? exp : exp.month + '/' + exp.year;
        };

        Chance.prototype.exp_month = function (options) {
            options = initOptions(options);
            var month, month_int,
                // Date object months are 0 indexed
                curMonth = new Date().getMonth() + 1;

            if (options.future && (curMonth !== 12)) {
                do {
                    month = this.month({raw: true}).numeric;
                    month_int = parseInt(month, 10);
                } while (month_int <= curMonth);
            } else {
                month = this.month({raw: true}).numeric;
            }

            return month;
        };

        Chance.prototype.exp_year = function () {
            var curMonth = new Date().getMonth() + 1,
                curYear = new Date().getFullYear();

            return this.year({min: ((curMonth === 12) ? (curYear + 1) : curYear), max: (curYear + 10)});
        };

        Chance.prototype.vat = function (options) {
            options = initOptions(options, { country: 'it' });
            switch (options.country.toLowerCase()) {
                case 'it':
                    return this.it_vat();
            }
        };

        /**
         * Generate a string matching IBAN pattern (https://en.wikipedia.org/wiki/International_Bank_Account_Number).
         * No country-specific formats support (yet)
         */
        Chance.prototype.iban = function () {
            var alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var alphanum = alpha + '0123456789';
            var iban =
                this.string({ length: 2, pool: alpha }) +
                this.pad(this.integer({ min: 0, max: 99 }), 2) +
                this.string({ length: 4, pool: alphanum }) +
                this.pad(this.natural(), this.natural({ min: 6, max: 26 }));
            return iban;
        };

        // -- End Finance

        // -- Regional

        Chance.prototype.it_vat = function () {
            var it_vat = this.natural({min: 1, max: 1800000});

            it_vat = this.pad(it_vat, 7) + this.pad(this.pick(this.provinces({ country: 'it' })).code, 3);
            return it_vat + this.luhn_calculate(it_vat);
        };

        /*
         * this generator is written following the official algorithm
         * all data can be passed explicitely or randomized by calling chance.cf() without options
         * the code does not check that the input data is valid (it goes beyond the scope of the generator)
         *
         * @param  [Object] options = { first: first name,
         *                              last: last name,
         *                              gender: female|male,
                                        birthday: JavaScript date object,
                                        city: string(4), 1 letter + 3 numbers
                                       }
         * @return [string] codice fiscale
         *
        */
        Chance.prototype.cf = function (options) {
            options = options || {};
            var gender = !!options.gender ? options.gender : this.gender(),
                first = !!options.first ? options.first : this.first( { gender: gender, nationality: 'it'} ),
                last = !!options.last ? options.last : this.last( { nationality: 'it'} ),
                birthday = !!options.birthday ? options.birthday : this.birthday(),
                city = !!options.city ? options.city : this.pickone(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'L', 'M', 'Z']) + this.pad(this.natural({max:999}), 3),
                cf = [],
                name_generator = function(name, isLast) {
                    var temp,
                        return_value = [];

                    if (name.length < 3) {
                        return_value = name.split("").concat("XXX".split("")).splice(0,3);
                    }
                    else {
                        temp = name.toUpperCase().split('').map(function(c){
                            return ("BCDFGHJKLMNPRSTVWZ".indexOf(c) !== -1) ? c : undefined;
                        }).join('');
                        if (temp.length > 3) {
                            if (isLast) {
                                temp = temp.substr(0,3);
                            } else {
                                temp = temp[0] + temp.substr(2,2);
                            }
                        }
                        if (temp.length < 3) {
                            return_value = temp;
                            temp = name.toUpperCase().split('').map(function(c){
                                return ("AEIOU".indexOf(c) !== -1) ? c : undefined;
                            }).join('').substr(0, 3 - return_value.length);
                        }
                        return_value = return_value + temp;
                    }

                    return return_value;
                },
                date_generator = function(birthday, gender, that) {
                    var lettermonths = ['A', 'B', 'C', 'D', 'E', 'H', 'L', 'M', 'P', 'R', 'S', 'T'];

                    return  birthday.getFullYear().toString().substr(2) +
                            lettermonths[birthday.getMonth()] +
                            that.pad(birthday.getDate() + ((gender.toLowerCase() === "female") ? 40 : 0), 2);
                },
                checkdigit_generator = function(cf) {
                    var range1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                        range2 = "ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ",
                        evens  = "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                        odds   = "BAKPLCQDREVOSFTGUHMINJWZYX",
                        digit  = 0;


                    for(var i = 0; i < 15; i++) {
                        if (i % 2 !== 0) {
                            digit += evens.indexOf(range2[range1.indexOf(cf[i])]);
                        }
                        else {
                            digit +=  odds.indexOf(range2[range1.indexOf(cf[i])]);
                        }
                    }
                    return evens[digit % 26];
                };

            cf = cf.concat(name_generator(last, true), name_generator(first), date_generator(birthday, gender, this), city.toUpperCase().split("")).join("");
            cf += checkdigit_generator(cf.toUpperCase());

            return cf.toUpperCase();
        };

        Chance.prototype.pl_pesel = function () {
            var number = this.natural({min: 1, max: 9999999999});
            var arr = this.pad(number, 10).split('');
            for (var i = 0; i < arr.length; i++) {
                arr[i] = parseInt(arr[i]);
            }

            var controlNumber = (1 * arr[0] + 3 * arr[1] + 7 * arr[2] + 9 * arr[3] + 1 * arr[4] + 3 * arr[5] + 7 * arr[6] + 9 * arr[7] + 1 * arr[8] + 3 * arr[9]) % 10;
            if(controlNumber !== 0) {
                controlNumber = 10 - controlNumber;
            }

            return arr.join('') + controlNumber;
        };

        Chance.prototype.pl_nip = function () {
            var number = this.natural({min: 1, max: 999999999});
            var arr = this.pad(number, 9).split('');
            for (var i = 0; i < arr.length; i++) {
                arr[i] = parseInt(arr[i]);
            }

            var controlNumber = (6 * arr[0] + 5 * arr[1] + 7 * arr[2] + 2 * arr[3] + 3 * arr[4] + 4 * arr[5] + 5 * arr[6] + 6 * arr[7] + 7 * arr[8]) % 11;
            if(controlNumber === 10) {
                return this.pl_nip();
            }

            return arr.join('') + controlNumber;
        };

        Chance.prototype.pl_regon = function () {
            var number = this.natural({min: 1, max: 99999999});
            var arr = this.pad(number, 8).split('');
            for (var i = 0; i < arr.length; i++) {
                arr[i] = parseInt(arr[i]);
            }

            var controlNumber = (8 * arr[0] + 9 * arr[1] + 2 * arr[2] + 3 * arr[3] + 4 * arr[4] + 5 * arr[5] + 6 * arr[6] + 7 * arr[7]) % 11;
            if(controlNumber === 10) {
                controlNumber = 0;
            }

            return arr.join('') + controlNumber;
        };

        // -- End Regional

        // -- Music --

        Chance.prototype.note = function(options) {
          // choices for 'notes' option:
          // flatKey - chromatic scale with flat notes (default)
          // sharpKey - chromatic scale with sharp notes
          // flats - just flat notes
          // sharps - just sharp notes
          // naturals - just natural notes
          // all - naturals, sharps and flats
          options = initOptions(options, { notes : 'flatKey'});
          var scales = {
            naturals: ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
            flats: ['D♭', 'E♭', 'G♭', 'A♭', 'B♭'],
            sharps: ['C♯', 'D♯', 'F♯', 'G♯', 'A♯']
          };
          scales.all = scales.naturals.concat(scales.flats.concat(scales.sharps));
          scales.flatKey = scales.naturals.concat(scales.flats);
          scales.sharpKey = scales.naturals.concat(scales.sharps);
          return this.pickone(scales[options.notes]);
        };

        Chance.prototype.midi_note = function(options) {
          var min = 0;
          var max = 127;
          options = initOptions(options, { min : min, max : max });
          return this.integer({min: options.min, max: options.max});
        };

        Chance.prototype.chord_quality = function(options) {
          options = initOptions(options, { jazz: true });
          var chord_qualities = ['maj', 'min', 'aug', 'dim'];
          if (options.jazz){
            chord_qualities = [
              'maj7',
              'min7',
              '7',
              'sus',
              'dim',
              'ø'
            ];
          }
          return this.pickone(chord_qualities);
        };

        Chance.prototype.chord = function (options) {
          options = initOptions(options);
          return this.note(options) + this.chord_quality(options);
        };

        Chance.prototype.tempo = function (options) {
          var min = 40;
          var max = 320;
          options = initOptions(options, {min: min, max: max});
          return this.integer({min: options.min, max: options.max});
        };

        // -- End Music

        // -- Miscellaneous --

        // Coin - Flip, flip, flipadelphia
        Chance.prototype.coin = function() {
          return this.bool() ? "heads" : "tails";
        };

        // Dice - For all the board game geeks out there, myself included ;)
        function diceFn (range) {
            return function () {
                return this.natural(range);
            };
        }
        Chance.prototype.d4 = diceFn({min: 1, max: 4});
        Chance.prototype.d6 = diceFn({min: 1, max: 6});
        Chance.prototype.d8 = diceFn({min: 1, max: 8});
        Chance.prototype.d10 = diceFn({min: 1, max: 10});
        Chance.prototype.d12 = diceFn({min: 1, max: 12});
        Chance.prototype.d20 = diceFn({min: 1, max: 20});
        Chance.prototype.d30 = diceFn({min: 1, max: 30});
        Chance.prototype.d100 = diceFn({min: 1, max: 100});

        Chance.prototype.rpg = function (thrown, options) {
            options = initOptions(options);
            if (!thrown) {
                throw new RangeError("Chance: A type of die roll must be included");
            } else {
                var bits = thrown.toLowerCase().split("d"),
                    rolls = [];

                if (bits.length !== 2 || !parseInt(bits[0], 10) || !parseInt(bits[1], 10)) {
                    throw new Error("Chance: Invalid format provided. Please provide #d# where the first # is the number of dice to roll, the second # is the max of each die");
                }
                for (var i = bits[0]; i > 0; i--) {
                    rolls[i - 1] = this.natural({min: 1, max: bits[1]});
                }
                return (typeof options.sum !== 'undefined' && options.sum) ? rolls.reduce(function (p, c) { return p + c; }) : rolls;
            }
        };

        // Guid
        Chance.prototype.guid = function (options) {
            options = initOptions(options, { version: 5 });

            var guid_pool = "abcdef1234567890",
                variant_pool = "ab89",
                guid = this.string({ pool: guid_pool, length: 8 }) + '-' +
                       this.string({ pool: guid_pool, length: 4 }) + '-' +
                       // The Version
                       options.version +
                       this.string({ pool: guid_pool, length: 3 }) + '-' +
                       // The Variant
                       this.string({ pool: variant_pool, length: 1 }) +
                       this.string({ pool: guid_pool, length: 3 }) + '-' +
                       this.string({ pool: guid_pool, length: 12 });
            return guid;
        };

        // Hash
        Chance.prototype.hash = function (options) {
            options = initOptions(options, {length : 40, casing: 'lower'});
            var pool = options.casing === 'upper' ? HEX_POOL.toUpperCase() : HEX_POOL;
            return this.string({pool: pool, length: options.length});
        };

        Chance.prototype.luhn_check = function (num) {
            var str = num.toString();
            var checkDigit = +str.substring(str.length - 1);
            return checkDigit === this.luhn_calculate(+str.substring(0, str.length - 1));
        };

        Chance.prototype.luhn_calculate = function (num) {
            var digits = num.toString().split("").reverse();
            var sum = 0;
            var digit;

            for (var i = 0, l = digits.length; l > i; ++i) {
                digit = +digits[i];
                if (i % 2 === 0) {
                    digit *= 2;
                    if (digit > 9) {
                        digit -= 9;
                    }
                }
                sum += digit;
            }
            return (sum * 9) % 10;
        };

        // MD5 Hash
        Chance.prototype.md5 = function(options) {
            var opts = { str: '', key: null, raw: false };

            if (!options) {
                opts.str = this.string();
                options = {};
            }
            else if (typeof options === 'string') {
                opts.str = options;
                options = {};
            }
            else if (typeof options !== 'object') {
                return null;
            }
            else if(options.constructor === 'Array') {
                return null;
            }

            opts = initOptions(options, opts);

            if(!opts.str){
                throw new Error('A parameter is required to return an md5 hash.');
            }

            return this.bimd5.md5(opts.str, opts.key, opts.raw);
        };

        /**
         * #Description:
         * =====================================================
         * Generate random file name with extension
         *
         * The argument provide extension type
         * -> raster
         * -> vector
         * -> 3d
         * -> document
         *
         * If nothing is provided the function return random file name with random
         * extension type of any kind
         *
         * The user can validate the file name length range
         * If nothing provided the generated file name is random
         *
         * #Extension Pool :
         * * Currently the supported extensions are
         *  -> some of the most popular raster image extensions
         *  -> some of the most popular vector image extensions
         *  -> some of the most popular 3d image extensions
         *  -> some of the most popular document extensions
         *
         * #Examples :
         * =====================================================
         *
         * Return random file name with random extension. The file extension
         * is provided by a predefined collection of extensions. More about the extension
         * pool can be found in #Extension Pool section
         *
         * chance.file()
         * => dsfsdhjf.xml
         *
         * In order to generate a file name with specific length, specify the
         * length property and integer value. The extension is going to be random
         *
         * chance.file({length : 10})
         * => asrtineqos.pdf
         *
         * In order to generate file with extension from some of the predefined groups
         * of the extension pool just specify the extension pool category in fileType property
         *
         * chance.file({fileType : 'raster'})
         * => dshgssds.psd
         *
         * You can provide specific extension for your files
         * chance.file({extension : 'html'})
         * => djfsd.html
         *
         * Or you could pass custom collection of extensions by array or by object
         * chance.file({extensions : [...]})
         * => dhgsdsd.psd
         *
         * chance.file({extensions : { key : [...], key : [...]}})
         * => djsfksdjsd.xml
         *
         * @param  [collection] options
         * @return [string]
         *
         */
        Chance.prototype.file = function(options) {

            var fileOptions = options || {};
            var poolCollectionKey = "fileExtension";
            var typeRange   = Object.keys(this.get("fileExtension"));//['raster', 'vector', '3d', 'document'];
            var fileName;
            var fileExtension;

            // Generate random file name
            fileName = this.word({length : fileOptions.length});

            // Generate file by specific extension provided by the user
            if(fileOptions.extension) {

                fileExtension = fileOptions.extension;
                return (fileName + '.' + fileExtension);
            }

            // Generate file by specific extension collection
            if(fileOptions.extensions) {

                if(Array.isArray(fileOptions.extensions)) {

                    fileExtension = this.pickone(fileOptions.extensions);
                    return (fileName + '.' + fileExtension);
                }
                else if(fileOptions.extensions.constructor === Object) {

                    var extensionObjectCollection = fileOptions.extensions;
                    var keys = Object.keys(extensionObjectCollection);

                    fileExtension = this.pickone(extensionObjectCollection[this.pickone(keys)]);
                    return (fileName + '.' + fileExtension);
                }

                throw new Error("Chance: Extensions must be an Array or Object");
            }

            // Generate file extension based on specific file type
            if(fileOptions.fileType) {

                var fileType = fileOptions.fileType;
                if(typeRange.indexOf(fileType) !== -1) {

                    fileExtension = this.pickone(this.get(poolCollectionKey)[fileType]);
                    return (fileName + '.' + fileExtension);
                }

                throw new RangeError("Chance: Expect file type value to be 'raster', 'vector', '3d' or 'document'");
            }

            // Generate random file name if no extension options are passed
            fileExtension = this.pickone(this.get(poolCollectionKey)[this.pickone(typeRange)]);
            return (fileName + '.' + fileExtension);
        };

        var data = {

            firstNames: {
                "male": {
                    "en": ["James", "John", "Robert", "Michael", "William", "David", "Richard", "Joseph", "Charles", "Thomas", "Christopher", "Daniel", "Matthew", "George", "Donald", "Anthony", "Paul", "Mark", "Edward", "Steven", "Kenneth", "Andrew", "Brian", "Joshua", "Kevin", "Ronald", "Timothy", "Jason", "Jeffrey", "Frank", "Gary", "Ryan", "Nicholas", "Eric", "Stephen", "Jacob", "Larry", "Jonathan", "Scott", "Raymond", "Justin", "Brandon", "Gregory", "Samuel", "Benjamin", "Patrick", "Jack", "Henry", "Walter", "Dennis", "Jerry", "Alexander", "Peter", "Tyler", "Douglas", "Harold", "Aaron", "Jose", "Adam", "Arthur", "Zachary", "Carl", "Nathan", "Albert", "Kyle", "Lawrence", "Joe", "Willie", "Gerald", "Roger", "Keith", "Jeremy", "Terry", "Harry", "Ralph", "Sean", "Jesse", "Roy", "Louis", "Billy", "Austin", "Bruce", "Eugene", "Christian", "Bryan", "Wayne", "Russell", "Howard", "Fred", "Ethan", "Jordan", "Philip", "Alan", "Juan", "Randy", "Vincent", "Bobby", "Dylan", "Johnny", "Phillip", "Victor", "Clarence", "Ernest", "Martin", "Craig", "Stanley", "Shawn", "Travis", "Bradley", "Leonard", "Earl", "Gabriel", "Jimmy", "Francis", "Todd", "Noah", "Danny", "Dale", "Cody", "Carlos", "Allen", "Frederick", "Logan", "Curtis", "Alex", "Joel", "Luis", "Norman", "Marvin", "Glenn", "Tony", "Nathaniel", "Rodney", "Melvin", "Alfred", "Steve", "Cameron", "Chad", "Edwin", "Caleb", "Evan", "Antonio", "Lee", "Herbert", "Jeffery", "Isaac", "Derek", "Ricky", "Marcus", "Theodore", "Elijah", "Luke", "Jesus", "Eddie", "Troy", "Mike", "Dustin", "Ray", "Adrian", "Bernard", "Leroy", "Angel", "Randall", "Wesley", "Ian", "Jared", "Mason", "Hunter", "Calvin", "Oscar", "Clifford", "Jay", "Shane", "Ronnie", "Barry", "Lucas", "Corey", "Manuel", "Leo", "Tommy", "Warren", "Jackson", "Isaiah", "Connor", "Don", "Dean", "Jon", "Julian", "Miguel", "Bill", "Lloyd", "Charlie", "Mitchell", "Leon", "Jerome", "Darrell", "Jeremiah", "Alvin", "Brett", "Seth", "Floyd", "Jim", "Blake", "Micheal", "Gordon", "Trevor", "Lewis", "Erik", "Edgar", "Vernon", "Devin", "Gavin", "Jayden", "Chris", "Clyde", "Tom", "Derrick", "Mario", "Brent", "Marc", "Herman", "Chase", "Dominic", "Ricardo", "Franklin", "Maurice", "Max", "Aiden", "Owen", "Lester", "Gilbert", "Elmer", "Gene", "Francisco", "Glen", "Cory", "Garrett", "Clayton", "Sam", "Jorge", "Chester", "Alejandro", "Jeff", "Harvey", "Milton", "Cole", "Ivan", "Andre", "Duane", "Landon"],
                    // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0163
                    "it": ["Adolfo", "Alberto", "Aldo", "Alessandro", "Alessio", "Alfredo", "Alvaro", "Andrea", "Angelo", "Angiolo", "Antonino", "Antonio", "Attilio", "Benito", "Bernardo", "Bruno", "Carlo", "Cesare", "Christian", "Claudio", "Corrado", "Cosimo", "Cristian", "Cristiano", "Daniele", "Dario", "David", "Davide", "Diego", "Dino", "Domenico", "Duccio", "Edoardo", "Elia", "Elio", "Emanuele", "Emiliano", "Emilio", "Enrico", "Enzo", "Ettore", "Fabio", "Fabrizio", "Federico", "Ferdinando", "Fernando", "Filippo", "Francesco", "Franco", "Gabriele", "Giacomo", "Giampaolo", "Giampiero", "Giancarlo", "Gianfranco", "Gianluca", "Gianmarco", "Gianni", "Gino", "Giorgio", "Giovanni", "Giuliano", "Giulio", "Giuseppe", "Graziano", "Gregorio", "Guido", "Iacopo", "Jacopo", "Lapo", "Leonardo", "Lorenzo", "Luca", "Luciano", "Luigi", "Manuel", "Marcello", "Marco", "Marino", "Mario", "Massimiliano", "Massimo", "Matteo", "Mattia", "Maurizio", "Mauro", "Michele", "Mirko", "Mohamed", "Nello", "Neri", "Niccolò", "Nicola", "Osvaldo", "Otello", "Paolo", "Pier Luigi", "Piero", "Pietro", "Raffaele", "Remo", "Renato", "Renzo", "Riccardo", "Roberto", "Rolando", "Romano", "Salvatore", "Samuele", "Sandro", "Sergio", "Silvano", "Simone", "Stefano", "Thomas", "Tommaso", "Ubaldo", "Ugo", "Umberto", "Valerio", "Valter", "Vasco", "Vincenzo", "Vittorio"],
                    // Data taken from http://www.svbkindernamen.nl/int/nl/kindernamen/index.html
                    "nl": ["Aaron","Abel","Adam","Adriaan","Albert","Alexander","Ali","Arjen","Arno","Bart","Bas","Bastiaan","Benjamin","Bob", "Boris","Bram","Brent","Cas","Casper","Chris","Christiaan","Cornelis","Daan","Daley","Damian","Dani","Daniel","Daniël","David","Dean","Dirk","Dylan","Egbert","Elijah","Erik","Erwin","Evert","Ezra","Fabian","Fedde","Finn","Florian","Floris","Frank","Frans","Frederik","Freek","Geert","Gerard","Gerben","Gerrit","Gijs","Guus","Hans","Hendrik","Henk","Herman","Hidde","Hugo","Jaap","Jan Jaap","Jan-Willem","Jack","Jacob","Jan","Jason","Jasper","Jayden","Jelle","Jelte","Jens","Jeroen","Jesse","Jim","Job","Joep","Johannes","John","Jonathan","Joris","Joshua","Joël","Julian","Kees","Kevin","Koen","Lars","Laurens","Leendert","Lennard","Lodewijk","Luc","Luca","Lucas","Lukas","Luuk","Maarten","Marcus","Martijn","Martin","Matthijs","Maurits","Max","Mees","Melle","Mick","Mika","Milan","Mohamed","Mohammed","Morris","Muhammed","Nathan","Nick","Nico","Niek","Niels","Noah","Noud","Olivier","Oscar","Owen","Paul","Pepijn","Peter","Pieter","Pim","Quinten","Reinier","Rens","Robin","Ruben","Sam","Samuel","Sander","Sebastiaan","Sem","Sep","Sepp","Siem","Simon","Stan","Stef","Steven","Stijn","Sven","Teun","Thijmen","Thijs","Thomas","Tijn","Tim","Timo","Tobias","Tom","Victor","Vince","Willem","Wim","Wouter","Yusuf"],
                    // Data taken from https://fr.wikipedia.org/wiki/Liste_de_pr%C3%A9noms_fran%C3%A7ais_et_de_la_francophonie
                    "fr": ["Aaron","Abdon","Abel","Abélard","Abelin","Abondance","Abraham","Absalon","Acace","Achaire","Achille","Adalard","Adalbald","Adalbéron","Adalbert","Adalric","Adam","Adegrin","Adel","Adelin","Andelin","Adelphe","Adam","Adéodat","Adhémar","Adjutor","Adolphe","Adonis","Adon","Adrien","Agapet","Agathange","Agathon","Agilbert","Agénor","Agnan","Aignan","Agrippin","Aimable","Aimé","Alain","Alban","Albin","Aubin","Albéric","Albert","Albertet","Alcibiade","Alcide","Alcée","Alcime","Aldonce","Aldric","Aldéric","Aleaume","Alexandre","Alexis","Alix","Alliaume","Aleaume","Almine","Almire","Aloïs","Alphée","Alphonse","Alpinien","Alverède","Amalric","Amaury","Amandin","Amant","Ambroise","Amédée","Amélien","Amiel","Amour","Anaël","Anastase","Anatole","Ancelin","Andéol","Andoche","André","Andoche","Ange","Angelin","Angilbe","Anglebert","Angoustan","Anicet","Anne","Annibal","Ansbert","Anselme","Anthelme","Antheaume","Anthime","Antide","Antoine","Antonius","Antonin","Apollinaire","Apollon","Aquilin","Arcade","Archambaud","Archambeau","Archange","Archibald","Arian","Ariel","Ariste","Aristide","Armand","Armel","Armin","Arnould","Arnaud","Arolde","Arsène","Arsinoé","Arthaud","Arthème","Arthur","Ascelin","Athanase","Aubry","Audebert","Audouin","Audran","Audric","Auguste","Augustin","Aurèle","Aurélien","Aurian","Auxence","Axel","Aymard","Aymeric","Aymon","Aymond","Balthazar","Baptiste","Barnabé","Barthélemy","Bartimée","Basile","Bastien","Baudouin","Bénigne","Benjamin","Benoît","Bérenger","Bérard","Bernard","Bertrand","Blaise","Bon","Boniface","Bouchard","Brice","Brieuc","Bruno","Brunon","Calixte","Calliste","Camélien","Camille","Camillien","Candide","Caribert","Carloman","Cassandre","Cassien","Cédric","Céleste","Célestin","Célien","Césaire","César","Charles","Charlemagne","Childebert","Chilpéric","Chrétien","Christian","Christodule","Christophe","Chrysostome","Clarence","Claude","Claudien","Cléandre","Clément","Clotaire","Côme","Constance","Constant","Constantin","Corentin","Cyprien","Cyriaque","Cyrille","Cyril","Damien","Daniel","David","Delphin","Denis","Désiré","Didier","Dieudonné","Dimitri","Dominique","Dorian","Dorothée","Edgard","Edmond","Édouard","Éleuthère","Élie","Élisée","Émeric","Émile","Émilien","Emmanuel","Enguerrand","Épiphane","Éric","Esprit","Ernest","Étienne","Eubert","Eudes","Eudoxe","Eugène","Eusèbe","Eustache","Évariste","Évrard","Fabien","Fabrice","Falba","Félicité","Félix","Ferdinand","Fiacre","Fidèle","Firmin","Flavien","Flodoard","Florent","Florentin","Florestan","Florian","Fortuné","Foulques","Francisque","François","Français","Franciscus","Francs","Frédéric","Fulbert","Fulcran","Fulgence","Gabin","Gabriel","Gaël","Garnier","Gaston","Gaspard","Gatien","Gaud","Gautier","Gédéon","Geoffroy","Georges","Géraud","Gérard","Gerbert","Germain","Gervais","Ghislain","Gilbert","Gilles","Girart","Gislebert","Gondebaud","Gonthier","Gontran","Gonzague","Grégoire","Guérin","Gui","Guillaume","Gustave","Guy","Guyot","Hardouin","Hector","Hédelin","Hélier","Henri","Herbert","Herluin","Hervé","Hilaire","Hildebert","Hincmar","Hippolyte","Honoré","Hubert","Hugues","Innocent","Isabeau","Isidore","Jacques","Japhet","Jason","Jean","Jeannel","Jeannot","Jérémie","Jérôme","Joachim","Joanny","Job","Jocelyn","Joël","Johan","Jonas","Jonathan","Joseph","Josse","Josselin","Jourdain","Jude","Judicaël","Jules","Julien","Juste","Justin","Lambert","Landry","Laurent","Lazare","Léandre","Léon","Léonard","Léopold","Leu","Loup","Leufroy","Libère","Liétald","Lionel","Loïc","Longin","Lorrain","Lorraine","Lothaire","Louis","Loup","Luc","Lucas","Lucien","Ludolphe","Ludovic","Macaire","Malo","Mamert","Manassé","Marc","Marceau","Marcel","Marcelin","Marius","Marseille","Martial","Martin","Mathurin","Matthias","Mathias","Matthieu","Maugis","Maurice","Mauricet","Maxence","Maxime","Maximilien","Mayeul","Médéric","Melchior","Mence","Merlin","Mérovée","Michaël","Michel","Moïse","Morgan","Nathan","Nathanaël","Narcisse","Néhémie","Nestor","Nestor","Nicéphore","Nicolas","Noé","Noël","Norbert","Normand","Normands","Octave","Odilon","Odon","Oger","Olivier","Oury","Pacôme","Palémon","Parfait","Pascal","Paterne","Patrice","Paul","Pépin","Perceval","Philémon","Philibert","Philippe","Philothée","Pie","Pierre","Pierrick","Prosper","Quentin","Raoul","Raphaël","Raymond","Régis","Réjean","Rémi","Renaud","René","Reybaud","Richard","Robert","Roch","Rodolphe","Rodrigue","Roger","Roland","Romain","Romuald","Roméo","Rome","Ronan","Roselin","Salomon","Samuel","Savin","Savinien","Scholastique","Sébastien","Séraphin","Serge","Séverin","Sidoine","Sigebert","Sigismond","Silvère","Simon","Siméon","Sixte","Stanislas","Stéphane","Stephan","Sylvain","Sylvestre","Tancrède","Tanguy","Taurin","Théodore","Théodose","Théophile","Théophraste","Thibault","Thibert","Thierry","Thomas","Timoléon","Timothée","Titien","Tonnin","Toussaint","Trajan","Tristan","Turold","Tim","Ulysse","Urbain","Valentin","Valère","Valéry","Venance","Venant","Venceslas","Vianney","Victor","Victorien","Victorin","Vigile","Vincent","Vital","Vitalien","Vivien","Waleran","Wandrille","Xavier","Xénophon","Yves","Zacharie","Zaché","Zéphirin"]
                },

                "female": {
                    "en": ["Mary", "Emma", "Elizabeth", "Minnie", "Margaret", "Ida", "Alice", "Bertha", "Sarah", "Annie", "Clara", "Ella", "Florence", "Cora", "Martha", "Laura", "Nellie", "Grace", "Carrie", "Maude", "Mabel", "Bessie", "Jennie", "Gertrude", "Julia", "Hattie", "Edith", "Mattie", "Rose", "Catherine", "Lillian", "Ada", "Lillie", "Helen", "Jessie", "Louise", "Ethel", "Lula", "Myrtle", "Eva", "Frances", "Lena", "Lucy", "Edna", "Maggie", "Pearl", "Daisy", "Fannie", "Josephine", "Dora", "Rosa", "Katherine", "Agnes", "Marie", "Nora", "May", "Mamie", "Blanche", "Stella", "Ellen", "Nancy", "Effie", "Sallie", "Nettie", "Della", "Lizzie", "Flora", "Susie", "Maud", "Mae", "Etta", "Harriet", "Sadie", "Caroline", "Katie", "Lydia", "Elsie", "Kate", "Susan", "Mollie", "Alma", "Addie", "Georgia", "Eliza", "Lulu", "Nannie", "Lottie", "Amanda", "Belle", "Charlotte", "Rebecca", "Ruth", "Viola", "Olive", "Amelia", "Hannah", "Jane", "Virginia", "Emily", "Matilda", "Irene", "Kathryn", "Esther", "Willie", "Henrietta", "Ollie", "Amy", "Rachel", "Sara", "Estella", "Theresa", "Augusta", "Ora", "Pauline", "Josie", "Lola", "Sophia", "Leona", "Anne", "Mildred", "Ann", "Beulah", "Callie", "Lou", "Delia", "Eleanor", "Barbara", "Iva", "Louisa", "Maria", "Mayme", "Evelyn", "Estelle", "Nina", "Betty", "Marion", "Bettie", "Dorothy", "Luella", "Inez", "Lela", "Rosie", "Allie", "Millie", "Janie", "Cornelia", "Victoria", "Ruby", "Winifred", "Alta", "Celia", "Christine", "Beatrice", "Birdie", "Harriett", "Mable", "Myra", "Sophie", "Tillie", "Isabel", "Sylvia", "Carolyn", "Isabelle", "Leila", "Sally", "Ina", "Essie", "Bertie", "Nell", "Alberta", "Katharine", "Lora", "Rena", "Mina", "Rhoda", "Mathilda", "Abbie", "Eula", "Dollie", "Hettie", "Eunice", "Fanny", "Ola", "Lenora", "Adelaide", "Christina", "Lelia", "Nelle", "Sue", "Johanna", "Lilly", "Lucinda", "Minerva", "Lettie", "Roxie", "Cynthia", "Helena", "Hilda", "Hulda", "Bernice", "Genevieve", "Jean", "Cordelia", "Marian", "Francis", "Jeanette", "Adeline", "Gussie", "Leah", "Lois", "Lura", "Mittie", "Hallie", "Isabella", "Olga", "Phoebe", "Teresa", "Hester", "Lida", "Lina", "Winnie", "Claudia", "Marguerite", "Vera", "Cecelia", "Bess", "Emilie", "Rosetta", "Verna", "Myrtie", "Cecilia", "Elva", "Olivia", "Ophelia", "Georgie", "Elnora", "Violet", "Adele", "Lily", "Linnie", "Loretta", "Madge", "Polly", "Virgie", "Eugenia", "Lucile", "Lucille", "Mabelle", "Rosalie"],
                    // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0162
                    "it": ["Ada", "Adriana", "Alessandra", "Alessia", "Alice", "Angela", "Anna", "Anna Maria", "Annalisa", "Annita", "Annunziata", "Antonella", "Arianna", "Asia", "Assunta", "Aurora", "Barbara", "Beatrice", "Benedetta", "Bianca", "Bruna", "Camilla", "Carla", "Carlotta", "Carmela", "Carolina", "Caterina", "Catia", "Cecilia", "Chiara", "Cinzia", "Clara", "Claudia", "Costanza", "Cristina", "Daniela", "Debora", "Diletta", "Dina", "Donatella", "Elena", "Eleonora", "Elisa", "Elisabetta", "Emanuela", "Emma", "Eva", "Federica", "Fernanda", "Fiorella", "Fiorenza", "Flora", "Franca", "Francesca", "Gabriella", "Gaia", "Gemma", "Giada", "Gianna", "Gina", "Ginevra", "Giorgia", "Giovanna", "Giulia", "Giuliana", "Giuseppa", "Giuseppina", "Grazia", "Graziella", "Greta", "Ida", "Ilaria", "Ines", "Iolanda", "Irene", "Irma", "Isabella", "Jessica", "Laura", "Lea", "Letizia", "Licia", "Lidia", "Liliana", "Lina", "Linda", "Lisa", "Livia", "Loretta", "Luana", "Lucia", "Luciana", "Lucrezia", "Luisa", "Manuela", "Mara", "Marcella", "Margherita", "Maria", "Maria Cristina", "Maria Grazia", "Maria Luisa", "Maria Pia", "Maria Teresa", "Marina", "Marisa", "Marta", "Martina", "Marzia", "Matilde", "Melissa", "Michela", "Milena", "Mirella", "Monica", "Natalina", "Nella", "Nicoletta", "Noemi", "Olga", "Paola", "Patrizia", "Piera", "Pierina", "Raffaella", "Rebecca", "Renata", "Rina", "Rita", "Roberta", "Rosa", "Rosanna", "Rossana", "Rossella", "Sabrina", "Sandra", "Sara", "Serena", "Silvana", "Silvia", "Simona", "Simonetta", "Sofia", "Sonia", "Stefania", "Susanna", "Teresa", "Tina", "Tiziana", "Tosca", "Valentina", "Valeria", "Vanda", "Vanessa", "Vanna", "Vera", "Veronica", "Vilma", "Viola", "Virginia", "Vittoria"],
                    // Data taken from http://www.svbkindernamen.nl/int/nl/kindernamen/index.html
                    "nl": ["Ada", "Arianne", "Afke", "Amanda", "Amber", "Amy", "Aniek", "Anita", "Anja", "Anna", "Anne", "Annelies", "Annemarie", "Annette", "Anouk", "Astrid", "Aukje", "Barbara", "Bianca", "Carla", "Carlijn", "Carolien", "Chantal", "Charlotte", "Claudia", "Daniëlle", "Debora", "Diane", "Dora", "Eline", "Elise", "Ella", "Ellen", "Emma", "Esmee", "Evelien", "Esther", "Erica", "Eva", "Femke", "Fleur", "Floor", "Froukje", "Gea", "Gerda", "Hanna", "Hanneke", "Heleen", "Hilde", "Ilona", "Ina", "Inge", "Ingrid", "Iris", "Isabel", "Isabelle", "Janneke", "Jasmijn", "Jeanine", "Jennifer", "Jessica", "Johanna", "Joke", "Julia", "Julie", "Karen", "Karin", "Katja", "Kim", "Lara", "Laura", "Lena", "Lianne", "Lieke", "Lilian", "Linda", "Lisa", "Lisanne", "Lotte", "Louise", "Maaike", "Manon", "Marga", "Maria", "Marissa", "Marit", "Marjolein", "Martine", "Marleen", "Melissa", "Merel", "Miranda", "Michelle", "Mirjam", "Mirthe", "Naomi", "Natalie", 'Nienke', "Nina", "Noortje", "Olivia", "Patricia", "Paula", "Paulien", "Ramona", "Ria", "Rianne", "Roos", "Rosanne", "Ruth", "Sabrina", "Sandra", "Sanne", "Sara", "Saskia", "Silvia", "Sofia", "Sophie", "Sonja", "Suzanne", "Tamara", "Tess", "Tessa", "Tineke", "Valerie", "Vanessa", "Veerle", "Vera", "Victoria", "Wendy", "Willeke", "Yvonne", "Zoë"],
                    // Data taken from https://fr.wikipedia.org/wiki/Liste_de_pr%C3%A9noms_fran%C3%A7ais_et_de_la_francophonie
                    "fr": ["Abdon","Abel","Abigaëlle","Abigaïl","Acacius","Acanthe","Adalbert","Adalsinde","Adegrine","Adélaïde","Adèle","Adélie","Adeline","Adeltrude","Adolphe","Adonis","Adrastée","Adrehilde","Adrienne","Agathe","Agilbert","Aglaé","Aignan","Agneflète","Agnès","Agrippine","Aimé","Alaine","Alaïs","Albane","Albérade","Alberte","Alcide","Alcine","Alcyone","Aldegonde","Aleth","Alexandrine","Alexine","Alice","Aliénor","Aliette","Aline","Alix","Alizé","Aloïse","Aloyse","Alphonsine","Althée","Amaliane","Amalthée","Amande","Amandine","Amant","Amarande","Amaranthe","Amaryllis","Ambre","Ambroisie","Amélie","Améthyste","Aminte","Anaël","Anaïs","Anastasie","Anatole","Ancelin","Andrée","Anémone","Angadrême","Angèle","Angeline","Angélique","Angilbert","Anicet","Annabelle","Anne","Annette","Annick","Annie","Annonciade","Ansbert","Anstrudie","Anthelme","Antigone","Antoinette","Antonine","Aphélie","Apolline","Apollonie","Aquiline","Arabelle","Arcadie","Archange","Argine","Ariane","Aricie","Ariel","Arielle","Arlette","Armance","Armande","Armandine","Armelle","Armide","Armelle","Armin","Arnaud","Arsène","Arsinoé","Artémis","Arthur","Ascelin","Ascension","Assomption","Astarté","Astérie","Astrée","Astrid","Athalie","Athanasie","Athina","Aube","Albert","Aude","Audrey","Augustine","Aure","Aurélie","Aurélien","Aurèle","Aurore","Auxence","Aveline","Abigaëlle","Avoye","Axelle","Aymard","Azalée","Adèle","Adeline","Barbe","Basilisse","Bathilde","Béatrice","Béatrix","Bénédicte","Bérengère","Bernadette","Berthe","Bertille","Beuve","Blanche","Blanc","Blandine","Brigitte","Brune","Brunehilde","Callista","Camille","Capucine","Carine","Caroline","Cassandre","Catherine","Cécile","Céleste","Célestine","Céline","Chantal","Charlène","Charline","Charlotte","Chloé","Christelle","Christiane","Christine","Claire","Clara","Claude","Claudine","Clarisse","Clémence","Clémentine","Cléo","Clio","Clotilde","Coline","Conception","Constance","Coralie","Coraline","Corentine","Corinne","Cyrielle","Daniel","Daniel","Daphné","Débora","Delphine","Denise","Diane","Dieudonné","Dominique","Doriane","Dorothée","Douce","Édith","Edmée","Éléonore","Éliane","Élia","Éliette","Élisabeth","Élise","Ella","Élodie","Éloïse","Elsa","Émeline","Émérance","Émérentienne","Émérencie","Émilie","Emma","Emmanuelle","Emmelie","Ernestine","Esther","Estelle","Eudoxie","Eugénie","Eulalie","Euphrasie","Eusébie","Évangéline","Eva","Ève","Évelyne","Fanny","Fantine","Faustine","Félicie","Fernande","Flavie","Fleur","Flore","Florence","Florie","Fortuné","France","Francia","Françoise","Francine","Gabrielle","Gaëlle","Garance","Geneviève","Georgette","Gerberge","Germaine","Gertrude","Gisèle","Guenièvre","Guilhemine","Guillemette","Gustave","Gwenael","Hélène","Héloïse","Henriette","Hermine","Hermione","Hippolyte","Honorine","Hortense","Huguette","Ines","Irène","Irina","Iris","Isabeau","Isabelle","Iseult","Isolde","Ismérie","Jacinthe","Jacqueline","Jade","Janine","Jeanne","Jocelyne","Joëlle","Joséphine","Judith","Julia","Julie","Jules","Juliette","Justine","Katy","Kathy","Katie","Laura","Laure","Laureline","Laurence","Laurene","Lauriane","Laurianne","Laurine","Léa","Léna","Léonie","Léon","Léontine","Lorraine","Lucie","Lucienne","Lucille","Ludivine","Lydie","Lydie","Megane","Madeleine","Magali","Maguelone","Mallaury","Manon","Marceline","Margot","Marguerite","Marianne","Marie","Myriam","Marie","Marine","Marion","Marlène","Marthe","Martine","Mathilde","Maud","Maureen","Mauricette","Maxime","Mélanie","Melissa","Mélissandre","Mélisande","Mélodie","Michel","Micheline","Mireille","Miriam","Moïse","Monique","Morgane","Muriel","Mylène","Nadège","Nadine","Nathalie","Nicole","Nicolette","Nine","Noël","Noémie","Océane","Odette","Odile","Olive","Olivia","Olympe","Ombline","Ombeline","Ophélie","Oriande","Oriane","Ozanne","Pascale","Pascaline","Paule","Paulette","Pauline","Priscille","Prisca","Prisque","Pécine","Pélagie","Pénélope","Perrine","Pétronille","Philippine","Philomène","Philothée","Primerose","Prudence","Pulchérie","Quentine","Quiéta","Quintia","Quintilla","Rachel","Raphaëlle","Raymonde","Rebecca","Régine","Réjeanne","René","Rita","Rita","Rolande","Romane","Rosalie","Rose","Roseline","Sabine","Salomé","Sandra","Sandrine","Sarah","Ségolène","Séverine","Sibylle","Simone","Sixt","Solange","Soline","Solène","Sophie","Stéphanie","Suzanne","Sylvain","Sylvie","Tatiana","Thaïs","Théodora","Thérèse","Tiphaine","Ursule","Valentine","Valérie","Véronique","Victoire","Victorine","Vinciane","Violette","Virginie","Viviane","Xavière","Yolande","Ysaline","Yvette","Yvonne","Zélie","Zita","Zoé"]
                }
            },

            lastNames: {
                "en": ['Smith', 'Johnson', 'Williams', 'Jones', 'Brown', 'Davis', 'Miller', 'Wilson', 'Moore', 'Taylor', 'Anderson', 'Thomas', 'Jackson', 'White', 'Harris', 'Martin', 'Thompson', 'Garcia', 'Martinez', 'Robinson', 'Clark', 'Rodriguez', 'Lewis', 'Lee', 'Walker', 'Hall', 'Allen', 'Young', 'Hernandez', 'King', 'Wright', 'Lopez', 'Hill', 'Scott', 'Green', 'Adams', 'Baker', 'Gonzalez', 'Nelson', 'Carter', 'Mitchell', 'Perez', 'Roberts', 'Turner', 'Phillips', 'Campbell', 'Parker', 'Evans', 'Edwards', 'Collins', 'Stewart', 'Sanchez', 'Morris', 'Rogers', 'Reed', 'Cook', 'Morgan', 'Bell', 'Murphy', 'Bailey', 'Rivera', 'Cooper', 'Richardson', 'Cox', 'Howard', 'Ward', 'Torres', 'Peterson', 'Gray', 'Ramirez', 'James', 'Watson', 'Brooks', 'Kelly', 'Sanders', 'Price', 'Bennett', 'Wood', 'Barnes', 'Ross', 'Henderson', 'Coleman', 'Jenkins', 'Perry', 'Powell', 'Long', 'Patterson', 'Hughes', 'Flores', 'Washington', 'Butler', 'Simmons', 'Foster', 'Gonzales', 'Bryant', 'Alexander', 'Russell', 'Griffin', 'Diaz', 'Hayes', 'Myers', 'Ford', 'Hamilton', 'Graham', 'Sullivan', 'Wallace', 'Woods', 'Cole', 'West', 'Jordan', 'Owens', 'Reynolds', 'Fisher', 'Ellis', 'Harrison', 'Gibson', 'McDonald', 'Cruz', 'Marshall', 'Ortiz', 'Gomez', 'Murray', 'Freeman', 'Wells', 'Webb', 'Simpson', 'Stevens', 'Tucker', 'Porter', 'Hunter', 'Hicks', 'Crawford', 'Henry', 'Boyd', 'Mason', 'Morales', 'Kennedy', 'Warren', 'Dixon', 'Ramos', 'Reyes', 'Burns', 'Gordon', 'Shaw', 'Holmes', 'Rice', 'Robertson', 'Hunt', 'Black', 'Daniels', 'Palmer', 'Mills', 'Nichols', 'Grant', 'Knight', 'Ferguson', 'Rose', 'Stone', 'Hawkins', 'Dunn', 'Perkins', 'Hudson', 'Spencer', 'Gardner', 'Stephens', 'Payne', 'Pierce', 'Berry', 'Matthews', 'Arnold', 'Wagner', 'Willis', 'Ray', 'Watkins', 'Olson', 'Carroll', 'Duncan', 'Snyder', 'Hart', 'Cunningham', 'Bradley', 'Lane', 'Andrews', 'Ruiz', 'Harper', 'Fox', 'Riley', 'Armstrong', 'Carpenter', 'Weaver', 'Greene', 'Lawrence', 'Elliott', 'Chavez', 'Sims', 'Austin', 'Peters', 'Kelley', 'Franklin', 'Lawson', 'Fields', 'Gutierrez', 'Ryan', 'Schmidt', 'Carr', 'Vasquez', 'Castillo', 'Wheeler', 'Chapman', 'Oliver', 'Montgomery', 'Richards', 'Williamson', 'Johnston', 'Banks', 'Meyer', 'Bishop', 'McCoy', 'Howell', 'Alvarez', 'Morrison', 'Hansen', 'Fernandez', 'Garza', 'Harvey', 'Little', 'Burton', 'Stanley', 'Nguyen', 'George', 'Jacobs', 'Reid', 'Kim', 'Fuller', 'Lynch', 'Dean', 'Gilbert', 'Garrett', 'Romero', 'Welch', 'Larson', 'Frazier', 'Burke', 'Hanson', 'Day', 'Mendoza', 'Moreno', 'Bowman', 'Medina', 'Fowler', 'Brewer', 'Hoffman', 'Carlson', 'Silva', 'Pearson', 'Holland', 'Douglas', 'Fleming', 'Jensen', 'Vargas', 'Byrd', 'Davidson', 'Hopkins', 'May', 'Terry', 'Herrera', 'Wade', 'Soto', 'Walters', 'Curtis', 'Neal', 'Caldwell', 'Lowe', 'Jennings', 'Barnett', 'Graves', 'Jimenez', 'Horton', 'Shelton', 'Barrett', 'Obrien', 'Castro', 'Sutton', 'Gregory', 'McKinney', 'Lucas', 'Miles', 'Craig', 'Rodriquez', 'Chambers', 'Holt', 'Lambert', 'Fletcher', 'Watts', 'Bates', 'Hale', 'Rhodes', 'Pena', 'Beck', 'Newman', 'Haynes', 'McDaniel', 'Mendez', 'Bush', 'Vaughn', 'Parks', 'Dawson', 'Santiago', 'Norris', 'Hardy', 'Love', 'Steele', 'Curry', 'Powers', 'Schultz', 'Barker', 'Guzman', 'Page', 'Munoz', 'Ball', 'Keller', 'Chandler', 'Weber', 'Leonard', 'Walsh', 'Lyons', 'Ramsey', 'Wolfe', 'Schneider', 'Mullins', 'Benson', 'Sharp', 'Bowen', 'Daniel', 'Barber', 'Cummings', 'Hines', 'Baldwin', 'Griffith', 'Valdez', 'Hubbard', 'Salazar', 'Reeves', 'Warner', 'Stevenson', 'Burgess', 'Santos', 'Tate', 'Cross', 'Garner', 'Mann', 'Mack', 'Moss', 'Thornton', 'Dennis', 'McGee', 'Farmer', 'Delgado', 'Aguilar', 'Vega', 'Glover', 'Manning', 'Cohen', 'Harmon', 'Rodgers', 'Robbins', 'Newton', 'Todd', 'Blair', 'Higgins', 'Ingram', 'Reese', 'Cannon', 'Strickland', 'Townsend', 'Potter', 'Goodwin', 'Walton', 'Rowe', 'Hampton', 'Ortega', 'Patton', 'Swanson', 'Joseph', 'Francis', 'Goodman', 'Maldonado', 'Yates', 'Becker', 'Erickson', 'Hodges', 'Rios', 'Conner', 'Adkins', 'Webster', 'Norman', 'Malone', 'Hammond', 'Flowers', 'Cobb', 'Moody', 'Quinn', 'Blake', 'Maxwell', 'Pope', 'Floyd', 'Osborne', 'Paul', 'McCarthy', 'Guerrero', 'Lindsey', 'Estrada', 'Sandoval', 'Gibbs', 'Tyler', 'Gross', 'Fitzgerald', 'Stokes', 'Doyle', 'Sherman', 'Saunders', 'Wise', 'Colon', 'Gill', 'Alvarado', 'Greer', 'Padilla', 'Simon', 'Waters', 'Nunez', 'Ballard', 'Schwartz', 'McBride', 'Houston', 'Christensen', 'Klein', 'Pratt', 'Briggs', 'Parsons', 'McLaughlin', 'Zimmerman', 'French', 'Buchanan', 'Moran', 'Copeland', 'Roy', 'Pittman', 'Brady', 'McCormick', 'Holloway', 'Brock', 'Poole', 'Frank', 'Logan', 'Owen', 'Bass', 'Marsh', 'Drake', 'Wong', 'Jefferson', 'Park', 'Morton', 'Abbott', 'Sparks', 'Patrick', 'Norton', 'Huff', 'Clayton', 'Massey', 'Lloyd', 'Figueroa', 'Carson', 'Bowers', 'Roberson', 'Barton', 'Tran', 'Lamb', 'Harrington', 'Casey', 'Boone', 'Cortez', 'Clarke', 'Mathis', 'Singleton', 'Wilkins', 'Cain', 'Bryan', 'Underwood', 'Hogan', 'McKenzie', 'Collier', 'Luna', 'Phelps', 'McGuire', 'Allison', 'Bridges', 'Wilkerson', 'Nash', 'Summers', 'Atkins'],
                    // Data taken from http://www.dati.gov.it/dataset/comune-di-firenze_0164 (first 1000)
                "it": ["Acciai", "Aglietti", "Agostini", "Agresti", "Ahmed", "Aiazzi", "Albanese", "Alberti", "Alessi", "Alfani", "Alinari", "Alterini", "Amato", "Ammannati", "Ancillotti", "Andrei", "Andreini", "Andreoni", "Angeli", "Anichini", "Antonelli", "Antonini", "Arena", "Ariani", "Arnetoli", "Arrighi", "Baccani", "Baccetti", "Bacci", "Bacherini", "Badii", "Baggiani", "Baglioni", "Bagni", "Bagnoli", "Baldassini", "Baldi", "Baldini", "Ballerini", "Balli", "Ballini", "Balloni", "Bambi", "Banchi", "Bandinelli", "Bandini", "Bani", "Barbetti", "Barbieri", "Barchielli", "Bardazzi", "Bardelli", "Bardi", "Barducci", "Bargellini", "Bargiacchi", "Barni", "Baroncelli", "Baroncini", "Barone", "Baroni", "Baronti", "Bartalesi", "Bartoletti", "Bartoli", "Bartolini", "Bartoloni", "Bartolozzi", "Basagni", "Basile", "Bassi", "Batacchi", "Battaglia", "Battaglini", "Bausi", "Becagli", "Becattini", "Becchi", "Becucci", "Bellandi", "Bellesi", "Belli", "Bellini", "Bellucci", "Bencini", "Benedetti", "Benelli", "Beni", "Benini", "Bensi", "Benucci", "Benvenuti", "Berlincioni", "Bernacchioni", "Bernardi", "Bernardini", "Berni", "Bernini", "Bertelli", "Berti", "Bertini", "Bessi", "Betti", "Bettini", "Biagi", "Biagini", "Biagioni", "Biagiotti", "Biancalani", "Bianchi", "Bianchini", "Bianco", "Biffoli", "Bigazzi", "Bigi", "Biliotti", "Billi", "Binazzi", "Bindi", "Bini", "Biondi", "Bizzarri", "Bocci", "Bogani", "Bolognesi", "Bonaiuti", "Bonanni", "Bonciani", "Boncinelli", "Bondi", "Bonechi", "Bongini", "Boni", "Bonini", "Borchi", "Boretti", "Borghi", "Borghini", "Borgioli", "Borri", "Borselli", "Boschi", "Bottai", "Bracci", "Braccini", "Brandi", "Braschi", "Bravi", "Brazzini", "Breschi", "Brilli", "Brizzi", "Brogelli", "Brogi", "Brogioni", "Brunelli", "Brunetti", "Bruni", "Bruno", "Brunori", "Bruschi", "Bucci", "Bucciarelli", "Buccioni", "Bucelli", "Bulli", "Burberi", "Burchi", "Burgassi", "Burroni", "Bussotti", "Buti", "Caciolli", "Caiani", "Calabrese", "Calamai", "Calamandrei", "Caldini", "Calo'", "Calonaci", "Calosi", "Calvelli", "Cambi", "Camiciottoli", "Cammelli", "Cammilli", "Campolmi", "Cantini", "Capanni", "Capecchi", "Caponi", "Cappelletti", "Cappelli", "Cappellini", "Cappugi", "Capretti", "Caputo", "Carbone", "Carboni", "Cardini", "Carlesi", "Carletti", "Carli", "Caroti", "Carotti", "Carrai", "Carraresi", "Carta", "Caruso", "Casalini", "Casati", "Caselli", "Casini", "Castagnoli", "Castellani", "Castelli", "Castellucci", "Catalano", "Catarzi", "Catelani", "Cavaciocchi", "Cavallaro", "Cavallini", "Cavicchi", "Cavini", "Ceccarelli", "Ceccatelli", "Ceccherelli", "Ceccherini", "Cecchi", "Cecchini", "Cecconi", "Cei", "Cellai", "Celli", "Cellini", "Cencetti", "Ceni", "Cenni", "Cerbai", "Cesari", "Ceseri", "Checcacci", "Checchi", "Checcucci", "Cheli", "Chellini", "Chen", "Cheng", "Cherici", "Cherubini", "Chiaramonti", "Chiarantini", "Chiarelli", "Chiari", "Chiarini", "Chiarugi", "Chiavacci", "Chiesi", "Chimenti", "Chini", "Chirici", "Chiti", "Ciabatti", "Ciampi", "Cianchi", "Cianfanelli", "Cianferoni", "Ciani", "Ciapetti", "Ciappi", "Ciardi", "Ciatti", "Cicali", "Ciccone", "Cinelli", "Cini", "Ciobanu", "Ciolli", "Cioni", "Cipriani", "Cirillo", "Cirri", "Ciucchi", "Ciuffi", "Ciulli", "Ciullini", "Clemente", "Cocchi", "Cognome", "Coli", "Collini", "Colombo", "Colzi", "Comparini", "Conforti", "Consigli", "Conte", "Conti", "Contini", "Coppini", "Coppola", "Corsi", "Corsini", "Corti", "Cortini", "Cosi", "Costa", "Costantini", "Costantino", "Cozzi", "Cresci", "Crescioli", "Cresti", "Crini", "Curradi", "D'Agostino", "D'Alessandro", "D'Amico", "D'Angelo", "Daddi", "Dainelli", "Dallai", "Danti", "Davitti", "De Angelis", "De Luca", "De Marco", "De Rosa", "De Santis", "De Simone", "De Vita", "Degl'Innocenti", "Degli Innocenti", "Dei", "Del Lungo", "Del Re", "Di Marco", "Di Stefano", "Dini", "Diop", "Dobre", "Dolfi", "Donati", "Dondoli", "Dong", "Donnini", "Ducci", "Dumitru", "Ermini", "Esposito", "Evangelisti", "Fabbri", "Fabbrini", "Fabbrizzi", "Fabbroni", "Fabbrucci", "Fabiani", "Facchini", "Faggi", "Fagioli", "Failli", "Faini", "Falciani", "Falcini", "Falcone", "Fallani", "Falorni", "Falsini", "Falugiani", "Fancelli", "Fanelli", "Fanetti", "Fanfani", "Fani", "Fantappie'", "Fantechi", "Fanti", "Fantini", "Fantoni", "Farina", "Fattori", "Favilli", "Fedi", "Fei", "Ferrante", "Ferrara", "Ferrari", "Ferraro", "Ferretti", "Ferri", "Ferrini", "Ferroni", "Fiaschi", "Fibbi", "Fiesoli", "Filippi", "Filippini", "Fini", "Fioravanti", "Fiore", "Fiorentini", "Fiorini", "Fissi", "Focardi", "Foggi", "Fontana", "Fontanelli", "Fontani", "Forconi", "Formigli", "Forte", "Forti", "Fortini", "Fossati", "Fossi", "Francalanci", "Franceschi", "Franceschini", "Franchi", "Franchini", "Franci", "Francini", "Francioni", "Franco", "Frassineti", "Frati", "Fratini", "Frilli", "Frizzi", "Frosali", "Frosini", "Frullini", "Fusco", "Fusi", "Gabbrielli", "Gabellini", "Gagliardi", "Galanti", "Galardi", "Galeotti", "Galletti", "Galli", "Gallo", "Gallori", "Gambacciani", "Gargani", "Garofalo", "Garuglieri", "Gashi", "Gasperini", "Gatti", "Gelli", "Gensini", "Gentile", "Gentili", "Geri", "Gerini", "Gheri", "Ghini", "Giachetti", "Giachi", "Giacomelli", "Gianassi", "Giani", "Giannelli", "Giannetti", "Gianni", "Giannini", "Giannoni", "Giannotti", "Giannozzi", "Gigli", "Giordano", "Giorgetti", "Giorgi", "Giovacchini", "Giovannelli", "Giovannetti", "Giovannini", "Giovannoni", "Giuliani", "Giunti", "Giuntini", "Giusti", "Gonnelli", "Goretti", "Gori", "Gradi", "Gramigni", "Grassi", "Grasso", "Graziani", "Grazzini", "Greco", "Grifoni", "Grillo", "Grimaldi", "Grossi", "Gualtieri", "Guarducci", "Guarino", "Guarnieri", "Guasti", "Guerra", "Guerri", "Guerrini", "Guidi", "Guidotti", "He", "Hoxha", "Hu", "Huang", "Iandelli", "Ignesti", "Innocenti", "Jin", "La Rosa", "Lai", "Landi", "Landini", "Lanini", "Lapi", "Lapini", "Lari", "Lascialfari", "Lastrucci", "Latini", "Lazzeri", "Lazzerini", "Lelli", "Lenzi", "Leonardi", "Leoncini", "Leone", "Leoni", "Lepri", "Li", "Liao", "Lin", "Linari", "Lippi", "Lisi", "Livi", "Lombardi", "Lombardini", "Lombardo", "Longo", "Lopez", "Lorenzi", "Lorenzini", "Lorini", "Lotti", "Lu", "Lucchesi", "Lucherini", "Lunghi", "Lupi", "Madiai", "Maestrini", "Maffei", "Maggi", "Maggini", "Magherini", "Magini", "Magnani", "Magnelli", "Magni", "Magnolfi", "Magrini", "Malavolti", "Malevolti", "Manca", "Mancini", "Manetti", "Manfredi", "Mangani", "Mannelli", "Manni", "Mannini", "Mannucci", "Manuelli", "Manzini", "Marcelli", "Marchese", "Marchetti", "Marchi", "Marchiani", "Marchionni", "Marconi", "Marcucci", "Margheri", "Mari", "Mariani", "Marilli", "Marinai", "Marinari", "Marinelli", "Marini", "Marino", "Mariotti", "Marsili", "Martelli", "Martinelli", "Martini", "Martino", "Marzi", "Masi", "Masini", "Masoni", "Massai", "Materassi", "Mattei", "Matteini", "Matteucci", "Matteuzzi", "Mattioli", "Mattolini", "Matucci", "Mauro", "Mazzanti", "Mazzei", "Mazzetti", "Mazzi", "Mazzini", "Mazzocchi", "Mazzoli", "Mazzoni", "Mazzuoli", "Meacci", "Mecocci", "Meini", "Melani", "Mele", "Meli", "Mengoni", "Menichetti", "Meoni", "Merlini", "Messeri", "Messina", "Meucci", "Miccinesi", "Miceli", "Micheli", "Michelini", "Michelozzi", "Migliori", "Migliorini", "Milani", "Miniati", "Misuri", "Monaco", "Montagnani", "Montagni", "Montanari", "Montelatici", "Monti", "Montigiani", "Montini", "Morandi", "Morandini", "Morelli", "Moretti", "Morganti", "Mori", "Morini", "Moroni", "Morozzi", "Mugnai", "Mugnaini", "Mustafa", "Naldi", "Naldini", "Nannelli", "Nanni", "Nannini", "Nannucci", "Nardi", "Nardini", "Nardoni", "Natali", "Ndiaye", "Nencetti", "Nencini", "Nencioni", "Neri", "Nesi", "Nesti", "Niccolai", "Niccoli", "Niccolini", "Nigi", "Nistri", "Nocentini", "Noferini", "Novelli", "Nucci", "Nuti", "Nutini", "Oliva", "Olivieri", "Olmi", "Orlandi", "Orlandini", "Orlando", "Orsini", "Ortolani", "Ottanelli", "Pacciani", "Pace", "Paci", "Pacini", "Pagani", "Pagano", "Paggetti", "Pagliai", "Pagni", "Pagnini", "Paladini", "Palagi", "Palchetti", "Palloni", "Palmieri", "Palumbo", "Pampaloni", "Pancani", "Pandolfi", "Pandolfini", "Panerai", "Panichi", "Paoletti", "Paoli", "Paolini", "Papi", "Papini", "Papucci", "Parenti", "Parigi", "Parisi", "Parri", "Parrini", "Pasquini", "Passeri", "Pecchioli", "Pecorini", "Pellegrini", "Pepi", "Perini", "Perrone", "Peruzzi", "Pesci", "Pestelli", "Petri", "Petrini", "Petrucci", "Pettini", "Pezzati", "Pezzatini", "Piani", "Piazza", "Piazzesi", "Piazzini", "Piccardi", "Picchi", "Piccini", "Piccioli", "Pieraccini", "Pieraccioni", "Pieralli", "Pierattini", "Pieri", "Pierini", "Pieroni", "Pietrini", "Pini", "Pinna", "Pinto", "Pinzani", "Pinzauti", "Piras", "Pisani", "Pistolesi", "Poggesi", "Poggi", "Poggiali", "Poggiolini", "Poli", "Pollastri", "Porciani", "Pozzi", "Pratellesi", "Pratesi", "Prosperi", "Pruneti", "Pucci", "Puccini", "Puccioni", "Pugi", "Pugliese", "Puliti", "Querci", "Quercioli", "Raddi", "Radu", "Raffaelli", "Ragazzini", "Ranfagni", "Ranieri", "Rastrelli", "Raugei", "Raveggi", "Renai", "Renzi", "Rettori", "Ricci", "Ricciardi", "Ridi", "Ridolfi", "Rigacci", "Righi", "Righini", "Rinaldi", "Risaliti", "Ristori", "Rizzo", "Rocchi", "Rocchini", "Rogai", "Romagnoli", "Romanelli", "Romani", "Romano", "Romei", "Romeo", "Romiti", "Romoli", "Romolini", "Rontini", "Rosati", "Roselli", "Rosi", "Rossetti", "Rossi", "Rossini", "Rovai", "Ruggeri", "Ruggiero", "Russo", "Sabatini", "Saccardi", "Sacchetti", "Sacchi", "Sacco", "Salerno", "Salimbeni", "Salucci", "Salvadori", "Salvestrini", "Salvi", "Salvini", "Sanesi", "Sani", "Sanna", "Santi", "Santini", "Santoni", "Santoro", "Santucci", "Sardi", "Sarri", "Sarti", "Sassi", "Sbolci", "Scali", "Scarpelli", "Scarselli", "Scopetani", "Secci", "Selvi", "Senatori", "Senesi", "Serafini", "Sereni", "Serra", "Sestini", "Sguanci", "Sieni", "Signorini", "Silvestri", "Simoncini", "Simonetti", "Simoni", "Singh", "Sodi", "Soldi", "Somigli", "Sorbi", "Sorelli", "Sorrentino", "Sottili", "Spina", "Spinelli", "Staccioli", "Staderini", "Stefanelli", "Stefani", "Stefanini", "Stella", "Susini", "Tacchi", "Tacconi", "Taddei", "Tagliaferri", "Tamburini", "Tanganelli", "Tani", "Tanini", "Tapinassi", "Tarchi", "Tarchiani", "Targioni", "Tassi", "Tassini", "Tempesti", "Terzani", "Tesi", "Testa", "Testi", "Tilli", "Tinti", "Tirinnanzi", "Toccafondi", "Tofanari", "Tofani", "Tognaccini", "Tonelli", "Tonini", "Torelli", "Torrini", "Tosi", "Toti", "Tozzi", "Trambusti", "Trapani", "Tucci", "Turchi", "Ugolini", "Ulivi", "Valente", "Valenti", "Valentini", "Vangelisti", "Vanni", "Vannini", "Vannoni", "Vannozzi", "Vannucchi", "Vannucci", "Ventura", "Venturi", "Venturini", "Vestri", "Vettori", "Vichi", "Viciani", "Vieri", "Vigiani", "Vignoli", "Vignolini", "Vignozzi", "Villani", "Vinci", "Visani", "Vitale", "Vitali", "Viti", "Viviani", "Vivoli", "Volpe", "Volpi", "Wang", "Wu", "Xu", "Yang", "Ye", "Zagli", "Zani", "Zanieri", "Zanobini", "Zecchi", "Zetti", "Zhang", "Zheng", "Zhou", "Zhu", "Zingoni", "Zini", "Zoppi"],
                // http://www.voornamelijk.nl/meest-voorkomende-achternamen-in-nederland-en-amsterdam/
                "nl":["Albers", "Alblas", "Appelman", "Baars", "Baas", "Bakker", "Blank", "Bleeker", "Blok", "Blom", "Boer", "Boers", "Boldewijn", "Boon", "Boot", "Bos", "Bosch", "Bosma", "Bosman", "Bouma", "Bouman", "Bouwman", "Brands", "Brouwer", "Burger", "Buijs", "Buitenhuis", "Ceder", "Cohen", "Dekker", "Dekkers", "Dijkman", "Dijkstra", "Driessen", "Drost", "Engel", "Evers", "Faber", "Franke", "Gerritsen", "Goedhart", "Goossens", "Groen", "Groenenberg", "Groot", "Haan", "Hart", "Heemskerk", "Hendriks", "Hermans", "Hoekstra", "Hofman", "Hopman", "Huisman", "Jacobs", "Jansen", "Janssen", "Jonker", "Jaspers", "Keijzer", "Klaassen", "Klein", "Koek", "Koenders", "Kok", "Kool", "Koopman", "Koopmans", "Koning", "Koster", "Kramer", "Kroon", "Kuijpers", "Kuiper", "Kuipers", "Kurt", "Koster", "Kwakman", "Los", "Lubbers", "Maas", "Markus", "Martens", "Meijer", "Mol", "Molenaar", "Mulder", "Nieuwenhuis", "Peeters", "Peters", "Pengel", "Pieters", "Pool", "Post", "Postma", "Prins", "Pronk", "Reijnders", "Rietveld", "Roest", "Roos", "Sanders", "Schaap", "Scheffer", "Schenk", "Schilder", "Schipper", "Schmidt", "Scholten", "Schouten", "Schut", "Schutte", "Schuurman", "Simons", "Smeets", "Smit", "Smits", "Snel", "Swinkels", "Tas", "Terpstra", "Timmermans", "Tol", "Tromp", "Troost", "Valk", "Veenstra", "Veldkamp", "Verbeek", "Verheul", "Verhoeven", "Vermeer", "Vermeulen", "Verweij", "Vink", "Visser", "Voorn", "Vos", "Wagenaar", "Wiersema", "Willems", "Willemsen", "Witteveen", "Wolff", "Wolters", "Zijlstra", "Zwart", "de Beer", "de Boer", "de Bruijn", "de Bruin", "de Graaf", "de Groot", "de Haan", "de Haas", "de Jager", "de Jong", "de Jonge", "de Koning", "de Lange", "de Leeuw", "de Ridder", "de Rooij", "de Ruiter", "de Vos", "de Vries", "de Waal", "de Wit", "de Zwart", "van Beek", "van Boven", "van Dam", "van Dijk", "van Dongen", "van Doorn", "van Egmond", "van Eijk", "van Es", "van Gelder", "van Gelderen", "van Houten", "van Hulst", "van Kempen", "van Kesteren", "van Leeuwen", "van Loon", "van Mill", "van Noord", "van Ommen", "van Ommeren", "van Oosten", "van Oostveen", "van Rijn", "van Schaik", "van Veen", "van Vliet", "van Wijk", "van Wijngaarden", "van den Poel", "van de Pol", "van den Ploeg", "van de Ven", "van den Berg", "van den Bosch", "van den Brink", "van den Broek", "van den Heuvel", "van der Heijden", "van der Horst", "van der Hulst", "van der Kroon", "van der Laan", "van der Linden", "van der Meer", "van der Meij", "van der Meulen", "van der Molen", "van der Sluis", "van der Spek", "van der Veen", "van der Velde", "van der Velden", "van der Vliet", "van der Wal"],
                // https://surnames.behindthename.com/top/lists/england-wales/1991
                "uk":["Smith","Jones","Williams","Taylor","Brown","Davies","Evans","Wilson","Thomas","Johnson","Roberts","Robinson","Thompson","Wright","Walker","White","Edwards","Hughes","Green","Hall","Lewis","Harris","Clarke","Patel","Jackson","Wood","Turner","Martin","Cooper","Hill","Ward","Morris","Moore","Clark","Lee","King","Baker","Harrison","Morgan","Allen","James","Scott","Phillips","Watson","Davis","Parker","Price","Bennett","Young","Griffiths","Mitchell","Kelly","Cook","Carter","Richardson","Bailey","Collins","Bell","Shaw","Murphy","Miller","Cox","Richards","Khan","Marshall","Anderson","Simpson","Ellis","Adams","Singh","Begum","Wilkinson","Foster","Chapman","Powell","Webb","Rogers","Gray","Mason","Ali","Hunt","Hussain","Campbell","Matthews","Owen","Palmer","Holmes","Mills","Barnes","Knight","Lloyd","Butler","Russell","Barker","Fisher","Stevens","Jenkins","Murray","Dixon","Harvey","Graham","Pearson","Ahmed","Fletcher","Walsh","Kaur","Gibson","Howard","Andrews","Stewart","Elliott","Reynolds","Saunders","Payne","Fox","Ford","Pearce","Day","Brooks","West","Lawrence","Cole","Atkinson","Bradley","Spencer","Gill","Dawson","Ball","Burton","O'brien","Watts","Rose","Booth","Perry","Ryan","Grant","Wells","Armstrong","Francis","Rees","Hayes","Hart","Hudson","Newman","Barrett","Webster","Hunter","Gregory","Carr","Lowe","Page","Marsh","Riley","Dunn","Woods","Parsons","Berry","Stone","Reid","Holland","Hawkins","Harding","Porter","Robertson","Newton","Oliver","Reed","Kennedy","Williamson","Bird","Gardner","Shah","Dean","Lane","Cooke","Bates","Henderson","Parry","Burgess","Bishop","Walton","Burns","Nicholson","Shepherd","Ross","Cross","Long","Freeman","Warren","Nicholls","Hamilton","Byrne","Sutton","Mcdonald","Yates","Hodgson","Robson","Curtis","Hopkins","O'connor","Harper","Coleman","Watkins","Moss","Mccarthy","Chambers","O'neill","Griffin","Sharp","Hardy","Wheeler","Potter","Osborne","Johnston","Gordon","Doyle","Wallace","George","Jordan","Hutchinson","Rowe","Burke","May","Pritchard","Gilbert","Willis","Higgins","Read","Miles","Stevenson","Stephenson","Hammond","Arnold","Buckley","Walters","Hewitt","Barber","Nelson","Slater","Austin","Sullivan","Whitehead","Mann","Frost","Lambert","Stephens","Blake","Akhtar","Lynch","Goodwin","Barton","Woodward","Thomson","Cunningham","Quinn","Barnett","Baxter","Bibi","Clayton","Nash","Greenwood","Jennings","Holt","Kemp","Poole","Gallagher","Bond","Stokes","Tucker","Davidson","Fowler","Heath","Norman","Middleton","Lawson","Banks","French","Stanley","Jarvis","Gibbs","Ferguson","Hayward","Carroll","Douglas","Dickinson","Todd","Barlow","Peters","Lucas","Knowles","Hartley","Miah","Simmons","Morton","Alexander","Field","Morrison","Norris","Townsend","Preston","Hancock","Thornton","Baldwin","Burrows","Briggs","Parkinson","Reeves","Macdonald","Lamb","Black","Abbott","Sanders","Thorpe","Holden","Tomlinson","Perkins","Ashton","Rhodes","Fuller","Howe","Bryant","Vaughan","Dale","Davey","Weston","Bartlett","Whittaker","Davison","Kent","Skinner","Birch","Morley","Daniels","Glover","Howell","Cartwright","Pugh","Humphreys","Goddard","Brennan","Wall","Kirby","Bowen","Savage","Bull","Wong","Dobson","Smart","Wilkins","Kirk","Fraser","Duffy","Hicks","Patterson","Bradshaw","Little","Archer","Warner","Waters","O'sullivan","Farrell","Brookes","Atkins","Kay","Dodd","Bentley","Flynn","John","Schofield","Short","Haynes","Wade","Butcher","Henry","Sanderson","Crawford","Sheppard","Bolton","Coates","Giles","Gould","Houghton","Gibbons","Pratt","Manning","Law","Hooper","Noble","Dyer","Rahman","Clements","Moran","Sykes","Chan","Doherty","Connolly","Joyce","Franklin","Hobbs","Coles","Herbert","Steele","Kerr","Leach","Winter","Owens","Duncan","Naylor","Fleming","Horton","Finch","Fitzgerald","Randall","Carpenter","Marsden","Browne","Garner","Pickering","Hale","Dennis","Vincent","Chadwick","Chandler","Sharpe","Nolan","Lyons","Hurst","Collier","Peacock","Howarth","Faulkner","Rice","Pollard","Welch","Norton","Gough","Sinclair","Blackburn","Bryan","Conway","Power","Cameron","Daly","Allan","Hanson","Gardiner","Boyle","Myers","Turnbull","Wallis","Mahmood","Sims","Swift","Iqbal","Pope","Brady","Chamberlain","Rowley","Tyler","Farmer","Metcalfe","Hilton","Godfrey","Holloway","Parkin","Bray","Talbot","Donnelly","Nixon","Charlton","Benson","Whitehouse","Barry","Hope","Lord","North","Storey","Connor","Potts","Bevan","Hargreaves","Mclean","Mistry","Bruce","Howells","Hyde","Parkes","Wyatt","Fry","Lees","O'donnell","Craig","Forster","Mckenzie","Humphries","Mellor","Carey","Ingram","Summers","Leonard"],
                // https://surnames.behindthename.com/top/lists/germany/2017
                "de": ["Müller","Schmidt","Schneider","Fischer","Weber","Meyer","Wagner","Becker","Schulz","Hoffmann","Schäfer","Koch","Bauer","Richter","Klein","Wolf","Schröder","Neumann","Schwarz","Zimmermann","Braun","Krüger","Hofmann","Hartmann","Lange","Schmitt","Werner","Schmitz","Krause","Meier","Lehmann","Schmid","Schulze","Maier","Köhler","Herrmann","König","Walter","Mayer","Huber","Kaiser","Fuchs","Peters","Lang","Scholz","Möller","Weiß","Jung","Hahn","Schubert","Vogel","Friedrich","Keller","Günther","Frank","Berger","Winkler","Roth","Beck","Lorenz","Baumann","Franke","Albrecht","Schuster","Simon","Ludwig","Böhm","Winter","Kraus","Martin","Schumacher","Krämer","Vogt","Stein","Jäger","Otto","Sommer","Groß","Seidel","Heinrich","Brandt","Haas","Schreiber","Graf","Schulte","Dietrich","Ziegler","Kuhn","Kühn","Pohl","Engel","Horn","Busch","Bergmann","Thomas","Voigt","Sauer","Arnold","Wolff","Pfeiffer"],
                // http://www.japantimes.co.jp/life/2009/10/11/lifestyle/japans-top-100-most-common-family-names/
                "jp": ["Sato","Suzuki","Takahashi","Tanaka","Watanabe","Ito","Yamamoto","Nakamura","Kobayashi","Kato","Yoshida","Yamada","Sasaki","Yamaguchi","Saito","Matsumoto","Inoue","Kimura","Hayashi","Shimizu","Yamazaki","Mori","Abe","Ikeda","Hashimoto","Yamashita","Ishikawa","Nakajima","Maeda","Fujita","Ogawa","Goto","Okada","Hasegawa","Murakami","Kondo","Ishii","Saito","Sakamoto","Endo","Aoki","Fujii","Nishimura","Fukuda","Ota","Miura","Fujiwara","Okamoto","Matsuda","Nakagawa","Nakano","Harada","Ono","Tamura","Takeuchi","Kaneko","Wada","Nakayama","Ishida","Ueda","Morita","Hara","Shibata","Sakai","Kudo","Yokoyama","Miyazaki","Miyamoto","Uchida","Takagi","Ando","Taniguchi","Ohno","Maruyama","Imai","Takada","Fujimoto","Takeda","Murata","Ueno","Sugiyama","Masuda","Sugawara","Hirano","Kojima","Otsuka","Chiba","Kubo","Matsui","Iwasaki","Sakurai","Kinoshita","Noguchi","Matsuo","Nomura","Kikuchi","Sano","Onishi","Sugimoto","Arai"],
                // http://www.lowchensaustralia.com/names/popular-spanish-names.htm
                "es": ["Garcia","Fernandez","Lopez","Martinez","Gonzalez","Rodriguez","Sanchez","Perez","Martin","Gomez","Ruiz","Diaz","Hernandez","Alvarez","Jimenez","Moreno","Munoz","Alonso","Romero","Navarro","Gutierrez","Torres","Dominguez","Gil","Vazquez","Blanco","Serrano","Ramos","Castro","Suarez","Sanz","Rubio","Ortega","Molina","Delgado","Ortiz","Morales","Ramirez","Marin","Iglesias","Santos","Castillo","Garrido","Calvo","Pena","Cruz","Cano","Nunez","Prieto","Diez","Lozano","Vidal","Pascual","Ferrer","Medina","Vega","Leon","Herrero","Vicente","Mendez","Guerrero","Fuentes","Campos","Nieto","Cortes","Caballero","Ibanez","Lorenzo","Pastor","Gimenez","Saez","Soler","Marquez","Carrasco","Herrera","Montero","Arias","Crespo","Flores","Andres","Aguilar","Hidalgo","Cabrera","Mora","Duran","Velasco","Rey","Pardo","Roman","Vila","Bravo","Merino","Moya","Soto","Izquierdo","Reyes","Redondo","Marcos","Carmona","Menendez"],
                // Data taken from https://fr.wikipedia.org/wiki/Liste_des_noms_de_famille_les_plus_courants_en_France
                "fr": ["Martin","Bernard","Thomas","Petit","Robert","Richard","Durand","Dubois","Moreau","Laurent","Simon","Michel","Lefèvre","Leroy","Roux","David","Bertrand","Morel","Fournier","Girard","Bonnet","Dupont","Lambert","Fontaine","Rousseau","Vincent","Müller","Lefèvre","Faure","André","Mercier","Blanc","Guérin","Boyer","Garnier","Chevalier","François","Legrand","Gauthier","Garcia","Perrin","Robin","Clément","Morin","Nicolas","Henry","Roussel","Matthieu","Gautier","Masson","Marchand","Duval","Denis","Dumont","Marie","Lemaire","Noël","Meyer","Dufour","Meunier","Brun","Blanchard","Giraud","Joly","Rivière","Lucas","Brunet","Gaillard","Barbier","Arnaud","Martínez","Gérard","Roche","Renard","Schmitt","Roy","Leroux","Colin","Vidal","Caron","Picard","Roger","Fabre","Aubert","Lemoine","Renaud","Dumas","Lacroix","Olivier","Philippe","Bourgeois","Pierre","Benoît","Rey","Leclerc","Payet","Rolland","Leclercq","Guillaume","Lecomte","López","Jean","Dupuy","Guillot","Hubert","Berger","Carpentier","Sánchez","Dupuis","Moulin","Louis","Deschamps","Huet","Vasseur","Perez","Boucher","Fleury","Royer","Klein","Jacquet","Adam","Paris","Poirier","Marty","Aubry","Guyot","Carré","Charles","Renault","Charpentier","Ménard","Maillard","Baron","Bertin","Bailly","Hervé","Schneider","Fernández","Le GallGall","Collet","Léger","Bouvier","Julien","Prévost","Millet","Perrot","Daniel","Le RouxRoux","Cousin","Germain","Breton","Besson","Langlois","Rémi","Le GoffGoff","Pelletier","Lévêque","Perrier","Leblanc","Barré","Lebrun","Marchal","Weber","Mallet","Hamon","Boulanger","Jacob","Monnier","Michaud","Rodríguez","Guichard","Gillet","Étienne","Grondin","Poulain","Tessier","Chevallier","Collin","Chauvin","Da SilvaSilva","Bouchet","Gay","Lemaître","Bénard","Maréchal","Humbert","Reynaud","Antoine","Hoarau","Perret","Barthélemy","Cordier","Pichon","Lejeune","Gilbert","Lamy","Delaunay","Pasquier","Carlier","LaporteLaporte"]
            },

            // Data taken from http://geoportal.statistics.gov.uk/datasets/ons-postcode-directory-latest-centroids
            postcodeAreas: [{code: 'AB'}, {code: 'AL'}, {code: 'B'}, {code: 'BA'}, {code: 'BB'}, {code: 'BD'}, {code: 'BH'}, {code: 'BL'}, {code: 'BN'}, {code: 'BR'}, {code: 'BS'}, {code: 'BT'}, {code: 'CA'}, {code: 'CB'}, {code: 'CF'}, {code: 'CH'}, {code: 'CM'}, {code: 'CO'}, {code: 'CR'}, {code: 'CT'}, {code: 'CV'}, {code: 'CW'}, {code: 'DA'}, {code: 'DD'}, {code: 'DE'}, {code: 'DG'}, {code: 'DH'}, {code: 'DL'}, {code: 'DN'}, {code: 'DT'}, {code: 'DY'}, {code: 'E'}, {code: 'EC'}, {code: 'EH'}, {code: 'EN'}, {code: 'EX'}, {code: 'FK'}, {code: 'FY'}, {code: 'G'}, {code: 'GL'}, {code: 'GU'}, {code: 'GY'}, {code: 'HA'}, {code: 'HD'}, {code: 'HG'}, {code: 'HP'}, {code: 'HR'}, {code: 'HS'}, {code: 'HU'}, {code: 'HX'}, {code: 'IG'}, {code: 'IM'}, {code: 'IP'}, {code: 'IV'}, {code: 'JE'}, {code: 'KA'}, {code: 'KT'}, {code: 'KW'}, {code: 'KY'}, {code: 'L'}, {code: 'LA'}, {code: 'LD'}, {code: 'LE'}, {code: 'LL'}, {code: 'LN'}, {code: 'LS'}, {code: 'LU'}, {code: 'M'}, {code: 'ME'}, {code: 'MK'}, {code: 'ML'}, {code: 'N'}, {code: 'NE'}, {code: 'NG'}, {code: 'NN'}, {code: 'NP'}, {code: 'NR'}, {code: 'NW'}, {code: 'OL'}, {code: 'OX'}, {code: 'PA'}, {code: 'PE'}, {code: 'PH'}, {code: 'PL'}, {code: 'PO'}, {code: 'PR'}, {code: 'RG'}, {code: 'RH'}, {code: 'RM'}, {code: 'S'}, {code: 'SA'}, {code: 'SE'}, {code: 'SG'}, {code: 'SK'}, {code: 'SL'}, {code: 'SM'}, {code: 'SN'}, {code: 'SO'}, {code: 'SP'}, {code: 'SR'}, {code: 'SS'}, {code: 'ST'}, {code: 'SW'}, {code: 'SY'}, {code: 'TA'}, {code: 'TD'}, {code: 'TF'}, {code: 'TN'}, {code: 'TQ'}, {code: 'TR'}, {code: 'TS'}, {code: 'TW'}, {code: 'UB'}, {code: 'W'}, {code: 'WA'}, {code: 'WC'}, {code: 'WD'}, {code: 'WF'}, {code: 'WN'}, {code: 'WR'}, {code: 'WS'}, {code: 'WV'}, {code: 'YO'}, {code: 'ZE'}],

            // Data taken from https://github.com/umpirsky/country-list/blob/master/data/en_US/country.json
            countries: [{"name":"Afghanistan","abbreviation":"AF"},{"name":"Åland Islands","abbreviation":"AX"},{"name":"Albania","abbreviation":"AL"},{"name":"Algeria","abbreviation":"DZ"},{"name":"American Samoa","abbreviation":"AS"},{"name":"Andorra","abbreviation":"AD"},{"name":"Angola","abbreviation":"AO"},{"name":"Anguilla","abbreviation":"AI"},{"name":"Antarctica","abbreviation":"AQ"},{"name":"Antigua & Barbuda","abbreviation":"AG"},{"name":"Argentina","abbreviation":"AR"},{"name":"Armenia","abbreviation":"AM"},{"name":"Aruba","abbreviation":"AW"},{"name":"Ascension Island","abbreviation":"AC"},{"name":"Australia","abbreviation":"AU"},{"name":"Austria","abbreviation":"AT"},{"name":"Azerbaijan","abbreviation":"AZ"},{"name":"Bahamas","abbreviation":"BS"},{"name":"Bahrain","abbreviation":"BH"},{"name":"Bangladesh","abbreviation":"BD"},{"name":"Barbados","abbreviation":"BB"},{"name":"Belarus","abbreviation":"BY"},{"name":"Belgium","abbreviation":"BE"},{"name":"Belize","abbreviation":"BZ"},{"name":"Benin","abbreviation":"BJ"},{"name":"Bermuda","abbreviation":"BM"},{"name":"Bhutan","abbreviation":"BT"},{"name":"Bolivia","abbreviation":"BO"},{"name":"Bosnia & Herzegovina","abbreviation":"BA"},{"name":"Botswana","abbreviation":"BW"},{"name":"Brazil","abbreviation":"BR"},{"name":"British Indian Ocean Territory","abbreviation":"IO"},{"name":"British Virgin Islands","abbreviation":"VG"},{"name":"Brunei","abbreviation":"BN"},{"name":"Bulgaria","abbreviation":"BG"},{"name":"Burkina Faso","abbreviation":"BF"},{"name":"Burundi","abbreviation":"BI"},{"name":"Cambodia","abbreviation":"KH"},{"name":"Cameroon","abbreviation":"CM"},{"name":"Canada","abbreviation":"CA"},{"name":"Canary Islands","abbreviation":"IC"},{"name":"Cape Verde","abbreviation":"CV"},{"name":"Caribbean Netherlands","abbreviation":"BQ"},{"name":"Cayman Islands","abbreviation":"KY"},{"name":"Central African Republic","abbreviation":"CF"},{"name":"Ceuta & Melilla","abbreviation":"EA"},{"name":"Chad","abbreviation":"TD"},{"name":"Chile","abbreviation":"CL"},{"name":"China","abbreviation":"CN"},{"name":"Christmas Island","abbreviation":"CX"},{"name":"Cocos (Keeling) Islands","abbreviation":"CC"},{"name":"Colombia","abbreviation":"CO"},{"name":"Comoros","abbreviation":"KM"},{"name":"Congo - Brazzaville","abbreviation":"CG"},{"name":"Congo - Kinshasa","abbreviation":"CD"},{"name":"Cook Islands","abbreviation":"CK"},{"name":"Costa Rica","abbreviation":"CR"},{"name":"Côte d'Ivoire","abbreviation":"CI"},{"name":"Croatia","abbreviation":"HR"},{"name":"Cuba","abbreviation":"CU"},{"name":"Curaçao","abbreviation":"CW"},{"name":"Cyprus","abbreviation":"CY"},{"name":"Czech Republic","abbreviation":"CZ"},{"name":"Denmark","abbreviation":"DK"},{"name":"Diego Garcia","abbreviation":"DG"},{"name":"Djibouti","abbreviation":"DJ"},{"name":"Dominica","abbreviation":"DM"},{"name":"Dominican Republic","abbreviation":"DO"},{"name":"Ecuador","abbreviation":"EC"},{"name":"Egypt","abbreviation":"EG"},{"name":"El Salvador","abbreviation":"SV"},{"name":"Equatorial Guinea","abbreviation":"GQ"},{"name":"Eritrea","abbreviation":"ER"},{"name":"Estonia","abbreviation":"EE"},{"name":"Ethiopia","abbreviation":"ET"},{"name":"Falkland Islands","abbreviation":"FK"},{"name":"Faroe Islands","abbreviation":"FO"},{"name":"Fiji","abbreviation":"FJ"},{"name":"Finland","abbreviation":"FI"},{"name":"France","abbreviation":"FR"},{"name":"French Guiana","abbreviation":"GF"},{"name":"French Polynesia","abbreviation":"PF"},{"name":"French Southern Territories","abbreviation":"TF"},{"name":"Gabon","abbreviation":"GA"},{"name":"Gambia","abbreviation":"GM"},{"name":"Georgia","abbreviation":"GE"},{"name":"Germany","abbreviation":"DE"},{"name":"Ghana","abbreviation":"GH"},{"name":"Gibraltar","abbreviation":"GI"},{"name":"Greece","abbreviation":"GR"},{"name":"Greenland","abbreviation":"GL"},{"name":"Grenada","abbreviation":"GD"},{"name":"Guadeloupe","abbreviation":"GP"},{"name":"Guam","abbreviation":"GU"},{"name":"Guatemala","abbreviation":"GT"},{"name":"Guernsey","abbreviation":"GG"},{"name":"Guinea","abbreviation":"GN"},{"name":"Guinea-Bissau","abbreviation":"GW"},{"name":"Guyana","abbreviation":"GY"},{"name":"Haiti","abbreviation":"HT"},{"name":"Honduras","abbreviation":"HN"},{"name":"Hong Kong SAR China","abbreviation":"HK"},{"name":"Hungary","abbreviation":"HU"},{"name":"Iceland","abbreviation":"IS"},{"name":"India","abbreviation":"IN"},{"name":"Indonesia","abbreviation":"ID"},{"name":"Iran","abbreviation":"IR"},{"name":"Iraq","abbreviation":"IQ"},{"name":"Ireland","abbreviation":"IE"},{"name":"Isle of Man","abbreviation":"IM"},{"name":"Israel","abbreviation":"IL"},{"name":"Italy","abbreviation":"IT"},{"name":"Jamaica","abbreviation":"JM"},{"name":"Japan","abbreviation":"JP"},{"name":"Jersey","abbreviation":"JE"},{"name":"Jordan","abbreviation":"JO"},{"name":"Kazakhstan","abbreviation":"KZ"},{"name":"Kenya","abbreviation":"KE"},{"name":"Kiribati","abbreviation":"KI"},{"name":"Kosovo","abbreviation":"XK"},{"name":"Kuwait","abbreviation":"KW"},{"name":"Kyrgyzstan","abbreviation":"KG"},{"name":"Laos","abbreviation":"LA"},{"name":"Latvia","abbreviation":"LV"},{"name":"Lebanon","abbreviation":"LB"},{"name":"Lesotho","abbreviation":"LS"},{"name":"Liberia","abbreviation":"LR"},{"name":"Libya","abbreviation":"LY"},{"name":"Liechtenstein","abbreviation":"LI"},{"name":"Lithuania","abbreviation":"LT"},{"name":"Luxembourg","abbreviation":"LU"},{"name":"Macau SAR China","abbreviation":"MO"},{"name":"Macedonia","abbreviation":"MK"},{"name":"Madagascar","abbreviation":"MG"},{"name":"Malawi","abbreviation":"MW"},{"name":"Malaysia","abbreviation":"MY"},{"name":"Maldives","abbreviation":"MV"},{"name":"Mali","abbreviation":"ML"},{"name":"Malta","abbreviation":"MT"},{"name":"Marshall Islands","abbreviation":"MH"},{"name":"Martinique","abbreviation":"MQ"},{"name":"Mauritania","abbreviation":"MR"},{"name":"Mauritius","abbreviation":"MU"},{"name":"Mayotte","abbreviation":"YT"},{"name":"Mexico","abbreviation":"MX"},{"name":"Micronesia","abbreviation":"FM"},{"name":"Moldova","abbreviation":"MD"},{"name":"Monaco","abbreviation":"MC"},{"name":"Mongolia","abbreviation":"MN"},{"name":"Montenegro","abbreviation":"ME"},{"name":"Montserrat","abbreviation":"MS"},{"name":"Morocco","abbreviation":"MA"},{"name":"Mozambique","abbreviation":"MZ"},{"name":"Myanmar (Burma)","abbreviation":"MM"},{"name":"Namibia","abbreviation":"NA"},{"name":"Nauru","abbreviation":"NR"},{"name":"Nepal","abbreviation":"NP"},{"name":"Netherlands","abbreviation":"NL"},{"name":"New Caledonia","abbreviation":"NC"},{"name":"New Zealand","abbreviation":"NZ"},{"name":"Nicaragua","abbreviation":"NI"},{"name":"Niger","abbreviation":"NE"},{"name":"Nigeria","abbreviation":"NG"},{"name":"Niue","abbreviation":"NU"},{"name":"Norfolk Island","abbreviation":"NF"},{"name":"North Korea","abbreviation":"KP"},{"name":"Northern Mariana Islands","abbreviation":"MP"},{"name":"Norway","abbreviation":"NO"},{"name":"Oman","abbreviation":"OM"},{"name":"Pakistan","abbreviation":"PK"},{"name":"Palau","abbreviation":"PW"},{"name":"Palestinian Territories","abbreviation":"PS"},{"name":"Panama","abbreviation":"PA"},{"name":"Papua New Guinea","abbreviation":"PG"},{"name":"Paraguay","abbreviation":"PY"},{"name":"Peru","abbreviation":"PE"},{"name":"Philippines","abbreviation":"PH"},{"name":"Pitcairn Islands","abbreviation":"PN"},{"name":"Poland","abbreviation":"PL"},{"name":"Portugal","abbreviation":"PT"},{"name":"Puerto Rico","abbreviation":"PR"},{"name":"Qatar","abbreviation":"QA"},{"name":"Réunion","abbreviation":"RE"},{"name":"Romania","abbreviation":"RO"},{"name":"Russia","abbreviation":"RU"},{"name":"Rwanda","abbreviation":"RW"},{"name":"Samoa","abbreviation":"WS"},{"name":"San Marino","abbreviation":"SM"},{"name":"São Tomé and Príncipe","abbreviation":"ST"},{"name":"Saudi Arabia","abbreviation":"SA"},{"name":"Senegal","abbreviation":"SN"},{"name":"Serbia","abbreviation":"RS"},{"name":"Seychelles","abbreviation":"SC"},{"name":"Sierra Leone","abbreviation":"SL"},{"name":"Singapore","abbreviation":"SG"},{"name":"Sint Maarten","abbreviation":"SX"},{"name":"Slovakia","abbreviation":"SK"},{"name":"Slovenia","abbreviation":"SI"},{"name":"Solomon Islands","abbreviation":"SB"},{"name":"Somalia","abbreviation":"SO"},{"name":"South Africa","abbreviation":"ZA"},{"name":"South Georgia & South Sandwich Islands","abbreviation":"GS"},{"name":"South Korea","abbreviation":"KR"},{"name":"South Sudan","abbreviation":"SS"},{"name":"Spain","abbreviation":"ES"},{"name":"Sri Lanka","abbreviation":"LK"},{"name":"St. Barthélemy","abbreviation":"BL"},{"name":"St. Helena","abbreviation":"SH"},{"name":"St. Kitts & Nevis","abbreviation":"KN"},{"name":"St. Lucia","abbreviation":"LC"},{"name":"St. Martin","abbreviation":"MF"},{"name":"St. Pierre & Miquelon","abbreviation":"PM"},{"name":"St. Vincent & Grenadines","abbreviation":"VC"},{"name":"Sudan","abbreviation":"SD"},{"name":"Suriname","abbreviation":"SR"},{"name":"Svalbard & Jan Mayen","abbreviation":"SJ"},{"name":"Swaziland","abbreviation":"SZ"},{"name":"Sweden","abbreviation":"SE"},{"name":"Switzerland","abbreviation":"CH"},{"name":"Syria","abbreviation":"SY"},{"name":"Taiwan","abbreviation":"TW"},{"name":"Tajikistan","abbreviation":"TJ"},{"name":"Tanzania","abbreviation":"TZ"},{"name":"Thailand","abbreviation":"TH"},{"name":"Timor-Leste","abbreviation":"TL"},{"name":"Togo","abbreviation":"TG"},{"name":"Tokelau","abbreviation":"TK"},{"name":"Tonga","abbreviation":"TO"},{"name":"Trinidad & Tobago","abbreviation":"TT"},{"name":"Tristan da Cunha","abbreviation":"TA"},{"name":"Tunisia","abbreviation":"TN"},{"name":"Turkey","abbreviation":"TR"},{"name":"Turkmenistan","abbreviation":"TM"},{"name":"Turks & Caicos Islands","abbreviation":"TC"},{"name":"Tuvalu","abbreviation":"TV"},{"name":"U.S. Outlying Islands","abbreviation":"UM"},{"name":"U.S. Virgin Islands","abbreviation":"VI"},{"name":"Uganda","abbreviation":"UG"},{"name":"Ukraine","abbreviation":"UA"},{"name":"United Arab Emirates","abbreviation":"AE"},{"name":"United Kingdom","abbreviation":"GB"},{"name":"United States","abbreviation":"US"},{"name":"Uruguay","abbreviation":"UY"},{"name":"Uzbekistan","abbreviation":"UZ"},{"name":"Vanuatu","abbreviation":"VU"},{"name":"Vatican City","abbreviation":"VA"},{"name":"Venezuela","abbreviation":"VE"},{"name":"Vietnam","abbreviation":"VN"},{"name":"Wallis & Futuna","abbreviation":"WF"},{"name":"Western Sahara","abbreviation":"EH"},{"name":"Yemen","abbreviation":"YE"},{"name":"Zambia","abbreviation":"ZM"},{"name":"Zimbabwe","abbreviation":"ZW"}],

                    counties: {
                // Data taken from http://www.downloadexcelfiles.com/gb_en/download-excel-file-list-counties-uk
                "uk": [
                    {name: 'Bath and North East Somerset'},
                    {name: 'Aberdeenshire'},
                    {name: 'Anglesey'},
                    {name: 'Angus'},
                    {name: 'Bedford'},
                    {name: 'Blackburn with Darwen'},
                    {name: 'Blackpool'},
                    {name: 'Bournemouth'},
                    {name: 'Bracknell Forest'},
                    {name: 'Brighton & Hove'},
                    {name: 'Bristol'},
                    {name: 'Buckinghamshire'},
                    {name: 'Cambridgeshire'},
                    {name: 'Carmarthenshire'},
                    {name: 'Central Bedfordshire'},
                    {name: 'Ceredigion'},
                    {name: 'Cheshire East'},
                    {name: 'Cheshire West and Chester'},
                    {name: 'Clackmannanshire'},
                    {name: 'Conwy'},
                    {name: 'Cornwall'},
                    {name: 'County Antrim'},
                    {name: 'County Armagh'},
                    {name: 'County Down'},
                    {name: 'County Durham'},
                    {name: 'County Fermanagh'},
                    {name: 'County Londonderry'},
                    {name: 'County Tyrone'},
                    {name: 'Cumbria'},
                    {name: 'Darlington'},
                    {name: 'Denbighshire'},
                    {name: 'Derby'},
                    {name: 'Derbyshire'},
                    {name: 'Devon'},
                    {name: 'Dorset'},
                    {name: 'Dumfries and Galloway'},
                    {name: 'Dundee'},
                    {name: 'East Lothian'},
                    {name: 'East Riding of Yorkshire'},
                    {name: 'East Sussex'},
                    {name: 'Edinburgh?'},
                    {name: 'Essex'},
                    {name: 'Falkirk'},
                    {name: 'Fife'},
                    {name: 'Flintshire'},
                    {name: 'Gloucestershire'},
                    {name: 'Greater London'},
                    {name: 'Greater Manchester'},
                    {name: 'Gwent'},
                    {name: 'Gwynedd'},
                    {name: 'Halton'},
                    {name: 'Hampshire'},
                    {name: 'Hartlepool'},
                    {name: 'Herefordshire'},
                    {name: 'Hertfordshire'},
                    {name: 'Highlands'},
                    {name: 'Hull'},
                    {name: 'Isle of Wight'},
                    {name: 'Isles of Scilly'},
                    {name: 'Kent'},
                    {name: 'Lancashire'},
                    {name: 'Leicester'},
                    {name: 'Leicestershire'},
                    {name: 'Lincolnshire'},
                    {name: 'Lothian'},
                    {name: 'Luton'},
                    {name: 'Medway'},
                    {name: 'Merseyside'},
                    {name: 'Mid Glamorgan'},
                    {name: 'Middlesbrough'},
                    {name: 'Milton Keynes'},
                    {name: 'Monmouthshire'},
                    {name: 'Moray'},
                    {name: 'Norfolk'},
                    {name: 'North East Lincolnshire'},
                    {name: 'North Lincolnshire'},
                    {name: 'North Somerset'},
                    {name: 'North Yorkshire'},
                    {name: 'Northamptonshire'},
                    {name: 'Northumberland'},
                    {name: 'Nottingham'},
                    {name: 'Nottinghamshire'},
                    {name: 'Oxfordshire'},
                    {name: 'Pembrokeshire'},
                    {name: 'Perth and Kinross'},
                    {name: 'Peterborough'},
                    {name: 'Plymouth'},
                    {name: 'Poole'},
                    {name: 'Portsmouth'},
                    {name: 'Powys'},
                    {name: 'Reading'},
                    {name: 'Redcar and Cleveland'},
                    {name: 'Rutland'},
                    {name: 'Scottish Borders'},
                    {name: 'Shropshire'},
                    {name: 'Slough'},
                    {name: 'Somerset'},
                    {name: 'South Glamorgan'},
                    {name: 'South Gloucestershire'},
                    {name: 'South Yorkshire'},
                    {name: 'Southampton'},
                    {name: 'Southend-on-Sea'},
                    {name: 'Staffordshire'},
                    {name: 'Stirlingshire'},
                    {name: 'Stockton-on-Tees'},
                    {name: 'Stoke-on-Trent'},
                    {name: 'Strathclyde'},
                    {name: 'Suffolk'},
                    {name: 'Surrey'},
                    {name: 'Swindon'},
                    {name: 'Telford and Wrekin'},
                    {name: 'Thurrock'},
                    {name: 'Torbay'},
                    {name: 'Tyne and Wear'},
                    {name: 'Warrington'},
                    {name: 'Warwickshire'},
                    {name: 'West Berkshire'},
                    {name: 'West Glamorgan'},
                    {name: 'West Lothian'},
                    {name: 'West Midlands'},
                    {name: 'West Sussex'},
                    {name: 'West Yorkshire'},
                    {name: 'Western Isles'},
                    {name: 'Wiltshire'},
                    {name: 'Windsor and Maidenhead'},
                    {name: 'Wokingham'},
                    {name: 'Worcestershire'},
                    {name: 'Wrexham'},
                    {name: 'York'}]
                                    },
            provinces: {
                "ca": [
                    {name: 'Alberta', abbreviation: 'AB'},
                    {name: 'British Columbia', abbreviation: 'BC'},
                    {name: 'Manitoba', abbreviation: 'MB'},
                    {name: 'New Brunswick', abbreviation: 'NB'},
                    {name: 'Newfoundland and Labrador', abbreviation: 'NL'},
                    {name: 'Nova Scotia', abbreviation: 'NS'},
                    {name: 'Ontario', abbreviation: 'ON'},
                    {name: 'Prince Edward Island', abbreviation: 'PE'},
                    {name: 'Quebec', abbreviation: 'QC'},
                    {name: 'Saskatchewan', abbreviation: 'SK'},

                    // The case could be made that the following are not actually provinces
                    // since they are technically considered "territories" however they all
                    // look the same on an envelope!
                    {name: 'Northwest Territories', abbreviation: 'NT'},
                    {name: 'Nunavut', abbreviation: 'NU'},
                    {name: 'Yukon', abbreviation: 'YT'}
                ],
                "it": [
                    { name: "Agrigento", abbreviation: "AG", code: 84 },
                    { name: "Alessandria", abbreviation: "AL", code: 6 },
                    { name: "Ancona", abbreviation: "AN", code: 42 },
                    { name: "Aosta", abbreviation: "AO", code: 7 },
                    { name: "L'Aquila", abbreviation: "AQ", code: 66 },
                    { name: "Arezzo", abbreviation: "AR", code: 51 },
                    { name: "Ascoli-Piceno", abbreviation: "AP", code: 44 },
                    { name: "Asti", abbreviation: "AT", code: 5 },
                    { name: "Avellino", abbreviation: "AV", code: 64 },
                    { name: "Bari", abbreviation: "BA", code: 72 },
                    { name: "Barletta-Andria-Trani", abbreviation: "BT", code: 72 },
                    { name: "Belluno", abbreviation: "BL", code: 25 },
                    { name: "Benevento", abbreviation: "BN", code: 62 },
                    { name: "Bergamo", abbreviation: "BG", code: 16 },
                    { name: "Biella", abbreviation: "BI", code: 96 },
                    { name: "Bologna", abbreviation: "BO", code: 37 },
                    { name: "Bolzano", abbreviation: "BZ", code: 21 },
                    { name: "Brescia", abbreviation: "BS", code: 17 },
                    { name: "Brindisi", abbreviation: "BR", code: 74 },
                    { name: "Cagliari", abbreviation: "CA", code: 92 },
                    { name: "Caltanissetta", abbreviation: "CL", code: 85 },
                    { name: "Campobasso", abbreviation: "CB", code: 70 },
                    { name: "Carbonia Iglesias", abbreviation: "CI", code: 70 },
                    { name: "Caserta", abbreviation: "CE", code: 61 },
                    { name: "Catania", abbreviation: "CT", code: 87 },
                    { name: "Catanzaro", abbreviation: "CZ", code: 79 },
                    { name: "Chieti", abbreviation: "CH", code: 69 },
                    { name: "Como", abbreviation: "CO", code: 13 },
                    { name: "Cosenza", abbreviation: "CS", code: 78 },
                    { name: "Cremona", abbreviation: "CR", code: 19 },
                    { name: "Crotone", abbreviation: "KR", code: 101 },
                    { name: "Cuneo", abbreviation: "CN", code: 4 },
                    { name: "Enna", abbreviation: "EN", code: 86 },
                    { name: "Fermo", abbreviation: "FM", code: 86 },
                    { name: "Ferrara", abbreviation: "FE", code: 38 },
                    { name: "Firenze", abbreviation: "FI", code: 48 },
                    { name: "Foggia", abbreviation: "FG", code: 71 },
                    { name: "Forli-Cesena", abbreviation: "FC", code: 71 },
                    { name: "Frosinone", abbreviation: "FR", code: 60 },
                    { name: "Genova", abbreviation: "GE", code: 10 },
                    { name: "Gorizia", abbreviation: "GO", code: 31 },
                    { name: "Grosseto", abbreviation: "GR", code: 53 },
                    { name: "Imperia", abbreviation: "IM", code: 8 },
                    { name: "Isernia", abbreviation: "IS", code: 94 },
                    { name: "La-Spezia", abbreviation: "SP", code: 66 },
                    { name: "Latina", abbreviation: "LT", code: 59 },
                    { name: "Lecce", abbreviation: "LE", code: 75 },
                    { name: "Lecco", abbreviation: "LC", code: 97 },
                    { name: "Livorno", abbreviation: "LI", code: 49 },
                    { name: "Lodi", abbreviation: "LO", code: 98 },
                    { name: "Lucca", abbreviation: "LU", code: 46 },
                    { name: "Macerata", abbreviation: "MC", code: 43 },
                    { name: "Mantova", abbreviation: "MN", code: 20 },
                    { name: "Massa-Carrara", abbreviation: "MS", code: 45 },
                    { name: "Matera", abbreviation: "MT", code: 77 },
                    { name: "Medio Campidano", abbreviation: "VS", code: 77 },
                    { name: "Messina", abbreviation: "ME", code: 83 },
                    { name: "Milano", abbreviation: "MI", code: 15 },
                    { name: "Modena", abbreviation: "MO", code: 36 },
                    { name: "Monza-Brianza", abbreviation: "MB", code: 36 },
                    { name: "Napoli", abbreviation: "NA", code: 63 },
                    { name: "Novara", abbreviation: "NO", code: 3 },
                    { name: "Nuoro", abbreviation: "NU", code: 91 },
                    { name: "Ogliastra", abbreviation: "OG", code: 91 },
                    { name: "Olbia Tempio", abbreviation: "OT", code: 91 },
                    { name: "Oristano", abbreviation: "OR", code: 95 },
                    { name: "Padova", abbreviation: "PD", code: 28 },
                    { name: "Palermo", abbreviation: "PA", code: 82 },
                    { name: "Parma", abbreviation: "PR", code: 34 },
                    { name: "Pavia", abbreviation: "PV", code: 18 },
                    { name: "Perugia", abbreviation: "PG", code: 54 },
                    { name: "Pesaro-Urbino", abbreviation: "PU", code: 41 },
                    { name: "Pescara", abbreviation: "PE", code: 68 },
                    { name: "Piacenza", abbreviation: "PC", code: 33 },
                    { name: "Pisa", abbreviation: "PI", code: 50 },
                    { name: "Pistoia", abbreviation: "PT", code: 47 },
                    { name: "Pordenone", abbreviation: "PN", code: 93 },
                    { name: "Potenza", abbreviation: "PZ", code: 76 },
                    { name: "Prato", abbreviation: "PO", code: 100 },
                    { name: "Ragusa", abbreviation: "RG", code: 88 },
                    { name: "Ravenna", abbreviation: "RA", code: 39 },
                    { name: "Reggio-Calabria", abbreviation: "RC", code: 35 },
                    { name: "Reggio-Emilia", abbreviation: "RE", code: 35 },
                    { name: "Rieti", abbreviation: "RI", code: 57 },
                    { name: "Rimini", abbreviation: "RN", code: 99 },
                    { name: "Roma", abbreviation: "Roma", code: 58 },
                    { name: "Rovigo", abbreviation: "RO", code: 29 },
                    { name: "Salerno", abbreviation: "SA", code: 65 },
                    { name: "Sassari", abbreviation: "SS", code: 90 },
                    { name: "Savona", abbreviation: "SV", code: 9 },
                    { name: "Siena", abbreviation: "SI", code: 52 },
                    { name: "Siracusa", abbreviation: "SR", code: 89 },
                    { name: "Sondrio", abbreviation: "SO", code: 14 },
                    { name: "Taranto", abbreviation: "TA", code: 73 },
                    { name: "Teramo", abbreviation: "TE", code: 67 },
                    { name: "Terni", abbreviation: "TR", code: 55 },
                    { name: "Torino", abbreviation: "TO", code: 1 },
                    { name: "Trapani", abbreviation: "TP", code: 81 },
                    { name: "Trento", abbreviation: "TN", code: 22 },
                    { name: "Treviso", abbreviation: "TV", code: 26 },
                    { name: "Trieste", abbreviation: "TS", code: 32 },
                    { name: "Udine", abbreviation: "UD", code: 30 },
                    { name: "Varese", abbreviation: "VA", code: 12 },
                    { name: "Venezia", abbreviation: "VE", code: 27 },
                    { name: "Verbania", abbreviation: "VB", code: 27 },
                    { name: "Vercelli", abbreviation: "VC", code: 2 },
                    { name: "Verona", abbreviation: "VR", code: 23 },
                    { name: "Vibo-Valentia", abbreviation: "VV", code: 102 },
                    { name: "Vicenza", abbreviation: "VI", code: 24 },
                    { name: "Viterbo", abbreviation: "VT", code: 56 }
                ]
            },

                // from: https://github.com/samsargent/Useful-Autocomplete-Data/blob/master/data/nationalities.json
            nationalities: [
               {name: 'Afghan'},
               {name: 'Albanian'},
               {name: 'Algerian'},
               {name: 'American'},
               {name: 'Andorran'},
               {name: 'Angolan'},
               {name: 'Antiguans'},
               {name: 'Argentinean'},
               {name: 'Armenian'},
               {name: 'Australian'},
               {name: 'Austrian'},
               {name: 'Azerbaijani'},
               {name: 'Bahami'},
               {name: 'Bahraini'},
               {name: 'Bangladeshi'},
               {name: 'Barbadian'},
               {name: 'Barbudans'},
               {name: 'Batswana'},
               {name: 'Belarusian'},
               {name: 'Belgian'},
               {name: 'Belizean'},
               {name: 'Beninese'},
               {name: 'Bhutanese'},
               {name: 'Bolivian'},
               {name: 'Bosnian'},
               {name: 'Brazilian'},
               {name: 'British'},
               {name: 'Bruneian'},
               {name: 'Bulgarian'},
               {name: 'Burkinabe'},
               {name: 'Burmese'},
               {name: 'Burundian'},
               {name: 'Cambodian'},
               {name: 'Cameroonian'},
               {name: 'Canadian'},
               {name: 'Cape Verdean'},
               {name: 'Central African'},
               {name: 'Chadian'},
               {name: 'Chilean'},
               {name: 'Chinese'},
               {name: 'Colombian'},
               {name: 'Comoran'},
               {name: 'Congolese'},
               {name: 'Costa Rican'},
               {name: 'Croatian'},
               {name: 'Cuban'},
               {name: 'Cypriot'},
               {name: 'Czech'},
               {name: 'Danish'},
               {name: 'Djibouti'},
               {name: 'Dominican'},
               {name: 'Dutch'},
               {name: 'East Timorese'},
               {name: 'Ecuadorean'},
               {name: 'Egyptian'},
               {name: 'Emirian'},
               {name: 'Equatorial Guinean'},
               {name: 'Eritrean'},
               {name: 'Estonian'},
               {name: 'Ethiopian'},
               {name: 'Fijian'},
               {name: 'Filipino'},
               {name: 'Finnish'},
               {name: 'French'},
               {name: 'Gabonese'},
               {name: 'Gambian'},
               {name: 'Georgian'},
               {name: 'German'},
               {name: 'Ghanaian'},
               {name: 'Greek'},
               {name: 'Grenadian'},
               {name: 'Guatemalan'},
               {name: 'Guinea-Bissauan'},
               {name: 'Guinean'},
               {name: 'Guyanese'},
               {name: 'Haitian'},
               {name: 'Herzegovinian'},
               {name: 'Honduran'},
               {name: 'Hungarian'},
               {name: 'I-Kiribati'},
               {name: 'Icelander'},
               {name: 'Indian'},
               {name: 'Indonesian'},
               {name: 'Iranian'},
               {name: 'Iraqi'},
               {name: 'Irish'},
               {name: 'Israeli'},
               {name: 'Italian'},
               {name: 'Ivorian'},
               {name: 'Jamaican'},
               {name: 'Japanese'},
               {name: 'Jordanian'},
               {name: 'Kazakhstani'},
               {name: 'Kenyan'},
               {name: 'Kittian and Nevisian'},
               {name: 'Kuwaiti'},
               {name: 'Kyrgyz'},
               {name: 'Laotian'},
               {name: 'Latvian'},
               {name: 'Lebanese'},
               {name: 'Liberian'},
               {name: 'Libyan'},
               {name: 'Liechtensteiner'},
               {name: 'Lithuanian'},
               {name: 'Luxembourger'},
               {name: 'Macedonian'},
               {name: 'Malagasy'},
               {name: 'Malawian'},
               {name: 'Malaysian'},
               {name: 'Maldivan'},
               {name: 'Malian'},
               {name: 'Maltese'},
               {name: 'Marshallese'},
               {name: 'Mauritanian'},
               {name: 'Mauritian'},
               {name: 'Mexican'},
               {name: 'Micronesian'},
               {name: 'Moldovan'},
               {name: 'Monacan'},
               {name: 'Mongolian'},
               {name: 'Moroccan'},
               {name: 'Mosotho'},
               {name: 'Motswana'},
               {name: 'Mozambican'},
               {name: 'Namibian'},
               {name: 'Nauruan'},
               {name: 'Nepalese'},
               {name: 'New Zealander'},
               {name: 'Nicaraguan'},
               {name: 'Nigerian'},
               {name: 'Nigerien'},
               {name: 'North Korean'},
               {name: 'Northern Irish'},
               {name: 'Norwegian'},
               {name: 'Omani'},
               {name: 'Pakistani'},
               {name: 'Palauan'},
               {name: 'Panamanian'},
               {name: 'Papua New Guinean'},
               {name: 'Paraguayan'},
               {name: 'Peruvian'},
               {name: 'Polish'},
               {name: 'Portuguese'},
               {name: 'Qatari'},
               {name: 'Romani'},
               {name: 'Russian'},
               {name: 'Rwandan'},
               {name: 'Saint Lucian'},
               {name: 'Salvadoran'},
               {name: 'Samoan'},
               {name: 'San Marinese'},
               {name: 'Sao Tomean'},
               {name: 'Saudi'},
               {name: 'Scottish'},
               {name: 'Senegalese'},
               {name: 'Serbian'},
               {name: 'Seychellois'},
               {name: 'Sierra Leonean'},
               {name: 'Singaporean'},
               {name: 'Slovakian'},
               {name: 'Slovenian'},
               {name: 'Solomon Islander'},
               {name: 'Somali'},
               {name: 'South African'},
               {name: 'South Korean'},
               {name: 'Spanish'},
               {name: 'Sri Lankan'},
               {name: 'Sudanese'},
               {name: 'Surinamer'},
               {name: 'Swazi'},
               {name: 'Swedish'},
               {name: 'Swiss'},
               {name: 'Syrian'},
               {name: 'Taiwanese'},
               {name: 'Tajik'},
               {name: 'Tanzanian'},
               {name: 'Thai'},
               {name: 'Togolese'},
               {name: 'Tongan'},
               {name: 'Trinidadian or Tobagonian'},
               {name: 'Tunisian'},
               {name: 'Turkish'},
               {name: 'Tuvaluan'},
               {name: 'Ugandan'},
               {name: 'Ukrainian'},
               {name: 'Uruguaya'},
               {name: 'Uzbekistani'},
               {name: 'Venezuela'},
               {name: 'Vietnamese'},
               {name: 'Wels'},
               {name: 'Yemenit'},
               {name: 'Zambia'},
               {name: 'Zimbabwe'},
            ],
              // http://www.loc.gov/standards/iso639-2/php/code_list.php (ISO-639-1 codes)
            locale_languages: [
              "aa",
              "ab",
              "ae",
              "af",
              "ak",
              "am",
              "an",
              "ar",
              "as",
              "av",
              "ay",
              "az",
              "ba",
              "be",
              "bg",
              "bh",
              "bi",
              "bm",
              "bn",
              "bo",
              "br",
              "bs",
              "ca",
              "ce",
              "ch",
              "co",
              "cr",
              "cs",
              "cu",
              "cv",
              "cy",
              "da",
              "de",
              "dv",
              "dz",
              "ee",
              "el",
              "en",
              "eo",
              "es",
              "et",
              "eu",
              "fa",
              "ff",
              "fi",
              "fj",
              "fo",
              "fr",
              "fy",
              "ga",
              "gd",
              "gl",
              "gn",
              "gu",
              "gv",
              "ha",
              "he",
              "hi",
              "ho",
              "hr",
              "ht",
              "hu",
              "hy",
              "hz",
              "ia",
              "id",
              "ie",
              "ig",
              "ii",
              "ik",
              "io",
              "is",
              "it",
              "iu",
              "ja",
              "jv",
              "ka",
              "kg",
              "ki",
              "kj",
              "kk",
              "kl",
              "km",
              "kn",
              "ko",
              "kr",
              "ks",
              "ku",
              "kv",
              "kw",
              "ky",
              "la",
              "lb",
              "lg",
              "li",
              "ln",
              "lo",
              "lt",
              "lu",
              "lv",
              "mg",
              "mh",
              "mi",
              "mk",
              "ml",
              "mn",
              "mr",
              "ms",
              "mt",
              "my",
              "na",
              "nb",
              "nd",
              "ne",
              "ng",
              "nl",
              "nn",
              "no",
              "nr",
              "nv",
              "ny",
              "oc",
              "oj",
              "om",
              "or",
              "os",
              "pa",
              "pi",
              "pl",
              "ps",
              "pt",
              "qu",
              "rm",
              "rn",
              "ro",
              "ru",
              "rw",
              "sa",
              "sc",
              "sd",
              "se",
              "sg",
              "si",
              "sk",
              "sl",
              "sm",
              "sn",
              "so",
              "sq",
              "sr",
              "ss",
              "st",
              "su",
              "sv",
              "sw",
              "ta",
              "te",
              "tg",
              "th",
              "ti",
              "tk",
              "tl",
              "tn",
              "to",
              "tr",
              "ts",
              "tt",
              "tw",
              "ty",
              "ug",
              "uk",
              "ur",
              "uz",
              "ve",
              "vi",
              "vo",
              "wa",
              "wo",
              "xh",
              "yi",
              "yo",
              "za",
              "zh",
              "zu"
            ],

            // From http://data.okfn.org/data/core/language-codes#resource-language-codes-full (IETF language tags)
            locale_regions: [
              "agq-CM",
              "asa-TZ",
              "ast-ES",
              "bas-CM",
              "bem-ZM",
              "bez-TZ",
              "brx-IN",
              "cgg-UG",
              "chr-US",
              "dav-KE",
              "dje-NE",
              "dsb-DE",
              "dua-CM",
              "dyo-SN",
              "ebu-KE",
              "ewo-CM",
              "fil-PH",
              "fur-IT",
              "gsw-CH",
              "gsw-FR",
              "gsw-LI",
              "guz-KE",
              "haw-US",
              "hsb-DE",
              "jgo-CM",
              "jmc-TZ",
              "kab-DZ",
              "kam-KE",
              "kde-TZ",
              "kea-CV",
              "khq-ML",
              "kkj-CM",
              "kln-KE",
              "kok-IN",
              "ksb-TZ",
              "ksf-CM",
              "ksh-DE",
              "lag-TZ",
              "lkt-US",
              "luo-KE",
              "luy-KE",
              "mas-KE",
              "mas-TZ",
              "mer-KE",
              "mfe-MU",
              "mgh-MZ",
              "mgo-CM",
              "mua-CM",
              "naq-NA",
              "nmg-CM",
              "nnh-CM",
              "nus-SD",
              "nyn-UG",
              "rof-TZ",
              "rwk-TZ",
              "sah-RU",
              "saq-KE",
              "sbp-TZ",
              "seh-MZ",
              "ses-ML",
              "shi-Latn",
              "shi-Latn-MA",
              "shi-Tfng",
              "shi-Tfng-MA",
              "smn-FI",
              "teo-KE",
              "teo-UG",
              "twq-NE",
              "tzm-Latn",
              "tzm-Latn-MA",
              "vai-Latn",
              "vai-Latn-LR",
              "vai-Vaii",
              "vai-Vaii-LR",
              "vun-TZ",
              "wae-CH",
              "xog-UG",
              "yav-CM",
              "zgh-MA",
              "af-NA",
              "af-ZA",
              "ak-GH",
              "am-ET",
              "ar-001",
              "ar-AE",
              "ar-BH",
              "ar-DJ",
              "ar-DZ",
              "ar-EG",
              "ar-EH",
              "ar-ER",
              "ar-IL",
              "ar-IQ",
              "ar-JO",
              "ar-KM",
              "ar-KW",
              "ar-LB",
              "ar-LY",
              "ar-MA",
              "ar-MR",
              "ar-OM",
              "ar-PS",
              "ar-QA",
              "ar-SA",
              "ar-SD",
              "ar-SO",
              "ar-SS",
              "ar-SY",
              "ar-TD",
              "ar-TN",
              "ar-YE",
              "as-IN",
              "az-Cyrl",
              "az-Cyrl-AZ",
              "az-Latn",
              "az-Latn-AZ",
              "be-BY",
              "bg-BG",
              "bm-Latn",
              "bm-Latn-ML",
              "bn-BD",
              "bn-IN",
              "bo-CN",
              "bo-IN",
              "br-FR",
              "bs-Cyrl",
              "bs-Cyrl-BA",
              "bs-Latn",
              "bs-Latn-BA",
              "ca-AD",
              "ca-ES",
              "ca-ES-VALENCIA",
              "ca-FR",
              "ca-IT",
              "cs-CZ",
              "cy-GB",
              "da-DK",
              "da-GL",
              "de-AT",
              "de-BE",
              "de-CH",
              "de-DE",
              "de-LI",
              "de-LU",
              "dz-BT",
              "ee-GH",
              "ee-TG",
              "el-CY",
              "el-GR",
              "en-001",
              "en-150",
              "en-AG",
              "en-AI",
              "en-AS",
              "en-AU",
              "en-BB",
              "en-BE",
              "en-BM",
              "en-BS",
              "en-BW",
              "en-BZ",
              "en-CA",
              "en-CC",
              "en-CK",
              "en-CM",
              "en-CX",
              "en-DG",
              "en-DM",
              "en-ER",
              "en-FJ",
              "en-FK",
              "en-FM",
              "en-GB",
              "en-GD",
              "en-GG",
              "en-GH",
              "en-GI",
              "en-GM",
              "en-GU",
              "en-GY",
              "en-HK",
              "en-IE",
              "en-IM",
              "en-IN",
              "en-IO",
              "en-JE",
              "en-JM",
              "en-KE",
              "en-KI",
              "en-KN",
              "en-KY",
              "en-LC",
              "en-LR",
              "en-LS",
              "en-MG",
              "en-MH",
              "en-MO",
              "en-MP",
              "en-MS",
              "en-MT",
              "en-MU",
              "en-MW",
              "en-MY",
              "en-NA",
              "en-NF",
              "en-NG",
              "en-NR",
              "en-NU",
              "en-NZ",
              "en-PG",
              "en-PH",
              "en-PK",
              "en-PN",
              "en-PR",
              "en-PW",
              "en-RW",
              "en-SB",
              "en-SC",
              "en-SD",
              "en-SG",
              "en-SH",
              "en-SL",
              "en-SS",
              "en-SX",
              "en-SZ",
              "en-TC",
              "en-TK",
              "en-TO",
              "en-TT",
              "en-TV",
              "en-TZ",
              "en-UG",
              "en-UM",
              "en-US",
              "en-US-POSIX",
              "en-VC",
              "en-VG",
              "en-VI",
              "en-VU",
              "en-WS",
              "en-ZA",
              "en-ZM",
              "en-ZW",
              "eo-001",
              "es-419",
              "es-AR",
              "es-BO",
              "es-CL",
              "es-CO",
              "es-CR",
              "es-CU",
              "es-DO",
              "es-EA",
              "es-EC",
              "es-ES",
              "es-GQ",
              "es-GT",
              "es-HN",
              "es-IC",
              "es-MX",
              "es-NI",
              "es-PA",
              "es-PE",
              "es-PH",
              "es-PR",
              "es-PY",
              "es-SV",
              "es-US",
              "es-UY",
              "es-VE",
              "et-EE",
              "eu-ES",
              "fa-AF",
              "fa-IR",
              "ff-CM",
              "ff-GN",
              "ff-MR",
              "ff-SN",
              "fi-FI",
              "fo-FO",
              "fr-BE",
              "fr-BF",
              "fr-BI",
              "fr-BJ",
              "fr-BL",
              "fr-CA",
              "fr-CD",
              "fr-CF",
              "fr-CG",
              "fr-CH",
              "fr-CI",
              "fr-CM",
              "fr-DJ",
              "fr-DZ",
              "fr-FR",
              "fr-GA",
              "fr-GF",
              "fr-GN",
              "fr-GP",
              "fr-GQ",
              "fr-HT",
              "fr-KM",
              "fr-LU",
              "fr-MA",
              "fr-MC",
              "fr-MF",
              "fr-MG",
              "fr-ML",
              "fr-MQ",
              "fr-MR",
              "fr-MU",
              "fr-NC",
              "fr-NE",
              "fr-PF",
              "fr-PM",
              "fr-RE",
              "fr-RW",
              "fr-SC",
              "fr-SN",
              "fr-SY",
              "fr-TD",
              "fr-TG",
              "fr-TN",
              "fr-VU",
              "fr-WF",
              "fr-YT",
              "fy-NL",
              "ga-IE",
              "gd-GB",
              "gl-ES",
              "gu-IN",
              "gv-IM",
              "ha-Latn",
              "ha-Latn-GH",
              "ha-Latn-NE",
              "ha-Latn-NG",
              "he-IL",
              "hi-IN",
              "hr-BA",
              "hr-HR",
              "hu-HU",
              "hy-AM",
              "id-ID",
              "ig-NG",
              "ii-CN",
              "is-IS",
              "it-CH",
              "it-IT",
              "it-SM",
              "ja-JP",
              "ka-GE",
              "ki-KE",
              "kk-Cyrl",
              "kk-Cyrl-KZ",
              "kl-GL",
              "km-KH",
              "kn-IN",
              "ko-KP",
              "ko-KR",
              "ks-Arab",
              "ks-Arab-IN",
              "kw-GB",
              "ky-Cyrl",
              "ky-Cyrl-KG",
              "lb-LU",
              "lg-UG",
              "ln-AO",
              "ln-CD",
              "ln-CF",
              "ln-CG",
              "lo-LA",
              "lt-LT",
              "lu-CD",
              "lv-LV",
              "mg-MG",
              "mk-MK",
              "ml-IN",
              "mn-Cyrl",
              "mn-Cyrl-MN",
              "mr-IN",
              "ms-Latn",
              "ms-Latn-BN",
              "ms-Latn-MY",
              "ms-Latn-SG",
              "mt-MT",
              "my-MM",
              "nb-NO",
              "nb-SJ",
              "nd-ZW",
              "ne-IN",
              "ne-NP",
              "nl-AW",
              "nl-BE",
              "nl-BQ",
              "nl-CW",
              "nl-NL",
              "nl-SR",
              "nl-SX",
              "nn-NO",
              "om-ET",
              "om-KE",
              "or-IN",
              "os-GE",
              "os-RU",
              "pa-Arab",
              "pa-Arab-PK",
              "pa-Guru",
              "pa-Guru-IN",
              "pl-PL",
              "ps-AF",
              "pt-AO",
              "pt-BR",
              "pt-CV",
              "pt-GW",
              "pt-MO",
              "pt-MZ",
              "pt-PT",
              "pt-ST",
              "pt-TL",
              "qu-BO",
              "qu-EC",
              "qu-PE",
              "rm-CH",
              "rn-BI",
              "ro-MD",
              "ro-RO",
              "ru-BY",
              "ru-KG",
              "ru-KZ",
              "ru-MD",
              "ru-RU",
              "ru-UA",
              "rw-RW",
              "se-FI",
              "se-NO",
              "se-SE",
              "sg-CF",
              "si-LK",
              "sk-SK",
              "sl-SI",
              "sn-ZW",
              "so-DJ",
              "so-ET",
              "so-KE",
              "so-SO",
              "sq-AL",
              "sq-MK",
              "sq-XK",
              "sr-Cyrl",
              "sr-Cyrl-BA",
              "sr-Cyrl-ME",
              "sr-Cyrl-RS",
              "sr-Cyrl-XK",
              "sr-Latn",
              "sr-Latn-BA",
              "sr-Latn-ME",
              "sr-Latn-RS",
              "sr-Latn-XK",
              "sv-AX",
              "sv-FI",
              "sv-SE",
              "sw-CD",
              "sw-KE",
              "sw-TZ",
              "sw-UG",
              "ta-IN",
              "ta-LK",
              "ta-MY",
              "ta-SG",
              "te-IN",
              "th-TH",
              "ti-ER",
              "ti-ET",
              "to-TO",
              "tr-CY",
              "tr-TR",
              "ug-Arab",
              "ug-Arab-CN",
              "uk-UA",
              "ur-IN",
              "ur-PK",
              "uz-Arab",
              "uz-Arab-AF",
              "uz-Cyrl",
              "uz-Cyrl-UZ",
              "uz-Latn",
              "uz-Latn-UZ",
              "vi-VN",
              "yi-001",
              "yo-BJ",
              "yo-NG",
              "zh-Hans",
              "zh-Hans-CN",
              "zh-Hans-HK",
              "zh-Hans-MO",
              "zh-Hans-SG",
              "zh-Hant",
              "zh-Hant-HK",
              "zh-Hant-MO",
              "zh-Hant-TW",
              "zu-ZA"
            ],

            us_states_and_dc: [
                {name: 'Alabama', abbreviation: 'AL'},
                {name: 'Alaska', abbreviation: 'AK'},
                {name: 'Arizona', abbreviation: 'AZ'},
                {name: 'Arkansas', abbreviation: 'AR'},
                {name: 'California', abbreviation: 'CA'},
                {name: 'Colorado', abbreviation: 'CO'},
                {name: 'Connecticut', abbreviation: 'CT'},
                {name: 'Delaware', abbreviation: 'DE'},
                {name: 'District of Columbia', abbreviation: 'DC'},
                {name: 'Florida', abbreviation: 'FL'},
                {name: 'Georgia', abbreviation: 'GA'},
                {name: 'Hawaii', abbreviation: 'HI'},
                {name: 'Idaho', abbreviation: 'ID'},
                {name: 'Illinois', abbreviation: 'IL'},
                {name: 'Indiana', abbreviation: 'IN'},
                {name: 'Iowa', abbreviation: 'IA'},
                {name: 'Kansas', abbreviation: 'KS'},
                {name: 'Kentucky', abbreviation: 'KY'},
                {name: 'Louisiana', abbreviation: 'LA'},
                {name: 'Maine', abbreviation: 'ME'},
                {name: 'Maryland', abbreviation: 'MD'},
                {name: 'Massachusetts', abbreviation: 'MA'},
                {name: 'Michigan', abbreviation: 'MI'},
                {name: 'Minnesota', abbreviation: 'MN'},
                {name: 'Mississippi', abbreviation: 'MS'},
                {name: 'Missouri', abbreviation: 'MO'},
                {name: 'Montana', abbreviation: 'MT'},
                {name: 'Nebraska', abbreviation: 'NE'},
                {name: 'Nevada', abbreviation: 'NV'},
                {name: 'New Hampshire', abbreviation: 'NH'},
                {name: 'New Jersey', abbreviation: 'NJ'},
                {name: 'New Mexico', abbreviation: 'NM'},
                {name: 'New York', abbreviation: 'NY'},
                {name: 'North Carolina', abbreviation: 'NC'},
                {name: 'North Dakota', abbreviation: 'ND'},
                {name: 'Ohio', abbreviation: 'OH'},
                {name: 'Oklahoma', abbreviation: 'OK'},
                {name: 'Oregon', abbreviation: 'OR'},
                {name: 'Pennsylvania', abbreviation: 'PA'},
                {name: 'Rhode Island', abbreviation: 'RI'},
                {name: 'South Carolina', abbreviation: 'SC'},
                {name: 'South Dakota', abbreviation: 'SD'},
                {name: 'Tennessee', abbreviation: 'TN'},
                {name: 'Texas', abbreviation: 'TX'},
                {name: 'Utah', abbreviation: 'UT'},
                {name: 'Vermont', abbreviation: 'VT'},
                {name: 'Virginia', abbreviation: 'VA'},
                {name: 'Washington', abbreviation: 'WA'},
                {name: 'West Virginia', abbreviation: 'WV'},
                {name: 'Wisconsin', abbreviation: 'WI'},
                {name: 'Wyoming', abbreviation: 'WY'}
            ],

            territories: [
                {name: 'American Samoa', abbreviation: 'AS'},
                {name: 'Federated States of Micronesia', abbreviation: 'FM'},
                {name: 'Guam', abbreviation: 'GU'},
                {name: 'Marshall Islands', abbreviation: 'MH'},
                {name: 'Northern Mariana Islands', abbreviation: 'MP'},
                {name: 'Puerto Rico', abbreviation: 'PR'},
                {name: 'Virgin Islands, U.S.', abbreviation: 'VI'}
            ],

            armed_forces: [
                {name: 'Armed Forces Europe', abbreviation: 'AE'},
                {name: 'Armed Forces Pacific', abbreviation: 'AP'},
                {name: 'Armed Forces the Americas', abbreviation: 'AA'}
            ],

            country_regions: {
                it: [
                    { name: "Valle d'Aosta", abbreviation: "VDA" },
                    { name: "Piemonte", abbreviation: "PIE" },
                    { name: "Lombardia", abbreviation: "LOM" },
                    { name: "Veneto", abbreviation: "VEN" },
                    { name: "Trentino Alto Adige", abbreviation: "TAA" },
                    { name: "Friuli Venezia Giulia", abbreviation: "FVG" },
                    { name: "Liguria", abbreviation: "LIG" },
                    { name: "Emilia Romagna", abbreviation: "EMR" },
                    { name: "Toscana", abbreviation: "TOS" },
                    { name: "Umbria", abbreviation: "UMB" },
                    { name: "Marche", abbreviation: "MAR" },
                    { name: "Abruzzo", abbreviation: "ABR" },
                    { name: "Lazio", abbreviation: "LAZ" },
                    { name: "Campania", abbreviation: "CAM" },
                    { name: "Puglia", abbreviation: "PUG" },
                    { name: "Basilicata", abbreviation: "BAS" },
                    { name: "Molise", abbreviation: "MOL" },
                    { name: "Calabria", abbreviation: "CAL" },
                    { name: "Sicilia", abbreviation: "SIC" },
                    { name: "Sardegna", abbreviation: "SAR" }
                ],
                mx: [
                    { name: 'Aguascalientes', abbreviation: 'AGU' },
                    { name: 'Baja California', abbreviation: 'BCN' },
                    { name: 'Baja California Sur', abbreviation: 'BCS' },
                    { name: 'Campeche', abbreviation: 'CAM' },
                    { name: 'Chiapas', abbreviation: 'CHP' },
                    { name: 'Chihuahua', abbreviation: 'CHH' },
                    { name: 'Ciudad de México', abbreviation: 'DIF' },
                    { name: 'Coahuila', abbreviation: 'COA' },
                    { name: 'Colima', abbreviation: 'COL' },
                    { name: 'Durango', abbreviation: 'DUR' },
                    { name: 'Guanajuato', abbreviation: 'GUA' },
                    { name: 'Guerrero', abbreviation: 'GRO' },
                    { name: 'Hidalgo', abbreviation: 'HID' },
                    { name: 'Jalisco', abbreviation: 'JAL' },
                    { name: 'México', abbreviation: 'MEX' },
                    { name: 'Michoacán', abbreviation: 'MIC' },
                    { name: 'Morelos', abbreviation: 'MOR' },
                    { name: 'Nayarit', abbreviation: 'NAY' },
                    { name: 'Nuevo León', abbreviation: 'NLE' },
                    { name: 'Oaxaca', abbreviation: 'OAX' },
                    { name: 'Puebla', abbreviation: 'PUE' },
                    { name: 'Querétaro', abbreviation: 'QUE' },
                    { name: 'Quintana Roo', abbreviation: 'ROO' },
                    { name: 'San Luis Potosí', abbreviation: 'SLP' },
                    { name: 'Sinaloa', abbreviation: 'SIN' },
                    { name: 'Sonora', abbreviation: 'SON' },
                    { name: 'Tabasco', abbreviation: 'TAB' },
                    { name: 'Tamaulipas', abbreviation: 'TAM' },
                    { name: 'Tlaxcala', abbreviation: 'TLA' },
                    { name: 'Veracruz', abbreviation: 'VER' },
                    { name: 'Yucatán', abbreviation: 'YUC' },
                    { name: 'Zacatecas', abbreviation: 'ZAC' }
                ]
            },

            street_suffixes: {
                'us': [
                    {name: 'Avenue', abbreviation: 'Ave'},
                    {name: 'Boulevard', abbreviation: 'Blvd'},
                    {name: 'Center', abbreviation: 'Ctr'},
                    {name: 'Circle', abbreviation: 'Cir'},
                    {name: 'Court', abbreviation: 'Ct'},
                    {name: 'Drive', abbreviation: 'Dr'},
                    {name: 'Extension', abbreviation: 'Ext'},
                    {name: 'Glen', abbreviation: 'Gln'},
                    {name: 'Grove', abbreviation: 'Grv'},
                    {name: 'Heights', abbreviation: 'Hts'},
                    {name: 'Highway', abbreviation: 'Hwy'},
                    {name: 'Junction', abbreviation: 'Jct'},
                    {name: 'Key', abbreviation: 'Key'},
                    {name: 'Lane', abbreviation: 'Ln'},
                    {name: 'Loop', abbreviation: 'Loop'},
                    {name: 'Manor', abbreviation: 'Mnr'},
                    {name: 'Mill', abbreviation: 'Mill'},
                    {name: 'Park', abbreviation: 'Park'},
                    {name: 'Parkway', abbreviation: 'Pkwy'},
                    {name: 'Pass', abbreviation: 'Pass'},
                    {name: 'Path', abbreviation: 'Path'},
                    {name: 'Pike', abbreviation: 'Pike'},
                    {name: 'Place', abbreviation: 'Pl'},
                    {name: 'Plaza', abbreviation: 'Plz'},
                    {name: 'Point', abbreviation: 'Pt'},
                    {name: 'Ridge', abbreviation: 'Rdg'},
                    {name: 'River', abbreviation: 'Riv'},
                    {name: 'Road', abbreviation: 'Rd'},
                    {name: 'Square', abbreviation: 'Sq'},
                    {name: 'Street', abbreviation: 'St'},
                    {name: 'Terrace', abbreviation: 'Ter'},
                    {name: 'Trail', abbreviation: 'Trl'},
                    {name: 'Turnpike', abbreviation: 'Tpke'},
                    {name: 'View', abbreviation: 'Vw'},
                    {name: 'Way', abbreviation: 'Way'}
                ],
                'it': [
                    { name: 'Accesso', abbreviation: 'Acc.' },
                    { name: 'Alzaia', abbreviation: 'Alz.' },
                    { name: 'Arco', abbreviation: 'Arco' },
                    { name: 'Archivolto', abbreviation: 'Acv.' },
                    { name: 'Arena', abbreviation: 'Arena' },
                    { name: 'Argine', abbreviation: 'Argine' },
                    { name: 'Bacino', abbreviation: 'Bacino' },
                    { name: 'Banchi', abbreviation: 'Banchi' },
                    { name: 'Banchina', abbreviation: 'Ban.' },
                    { name: 'Bastioni', abbreviation: 'Bas.' },
                    { name: 'Belvedere', abbreviation: 'Belv.' },
                    { name: 'Borgata', abbreviation: 'B.ta' },
                    { name: 'Borgo', abbreviation: 'B.go' },
                    { name: 'Calata', abbreviation: 'Cal.' },
                    { name: 'Calle', abbreviation: 'Calle' },
                    { name: 'Campiello', abbreviation: 'Cam.' },
                    { name: 'Campo', abbreviation: 'Cam.' },
                    { name: 'Canale', abbreviation: 'Can.' },
                    { name: 'Carraia', abbreviation: 'Carr.' },
                    { name: 'Cascina', abbreviation: 'Cascina' },
                    { name: 'Case sparse', abbreviation: 'c.s.' },
                    { name: 'Cavalcavia', abbreviation: 'Cv.' },
                    { name: 'Circonvallazione', abbreviation: 'Cv.' },
                    { name: 'Complanare', abbreviation: 'C.re' },
                    { name: 'Contrada', abbreviation: 'C.da' },
                    { name: 'Corso', abbreviation: 'C.so' },
                    { name: 'Corte', abbreviation: 'C.te' },
                    { name: 'Cortile', abbreviation: 'C.le' },
                    { name: 'Diramazione', abbreviation: 'Dir.' },
                    { name: 'Fondaco', abbreviation: 'F.co' },
                    { name: 'Fondamenta', abbreviation: 'F.ta' },
                    { name: 'Fondo', abbreviation: 'F.do' },
                    { name: 'Frazione', abbreviation: 'Fr.' },
                    { name: 'Isola', abbreviation: 'Is.' },
                    { name: 'Largo', abbreviation: 'L.go' },
                    { name: 'Litoranea', abbreviation: 'Lit.' },
                    { name: 'Lungolago', abbreviation: 'L.go lago' },
                    { name: 'Lungo Po', abbreviation: 'l.go Po' },
                    { name: 'Molo', abbreviation: 'Molo' },
                    { name: 'Mura', abbreviation: 'Mura' },
                    { name: 'Passaggio privato', abbreviation: 'pass. priv.' },
                    { name: 'Passeggiata', abbreviation: 'Pass.' },
                    { name: 'Piazza', abbreviation: 'P.zza' },
                    { name: 'Piazzale', abbreviation: 'P.le' },
                    { name: 'Ponte', abbreviation: 'P.te' },
                    { name: 'Portico', abbreviation: 'P.co' },
                    { name: 'Rampa', abbreviation: 'Rampa' },
                    { name: 'Regione', abbreviation: 'Reg.' },
                    { name: 'Rione', abbreviation: 'R.ne' },
                    { name: 'Rio', abbreviation: 'Rio' },
                    { name: 'Ripa', abbreviation: 'Ripa' },
                    { name: 'Riva', abbreviation: 'Riva' },
                    { name: 'Rondò', abbreviation: 'Rondò' },
                    { name: 'Rotonda', abbreviation: 'Rot.' },
                    { name: 'Sagrato', abbreviation: 'Sagr.' },
                    { name: 'Salita', abbreviation: 'Sal.' },
                    { name: 'Scalinata', abbreviation: 'Scal.' },
                    { name: 'Scalone', abbreviation: 'Scal.' },
                    { name: 'Slargo', abbreviation: 'Sl.' },
                    { name: 'Sottoportico', abbreviation: 'Sott.' },
                    { name: 'Strada', abbreviation: 'Str.' },
                    { name: 'Stradale', abbreviation: 'Str.le' },
                    { name: 'Strettoia', abbreviation: 'Strett.' },
                    { name: 'Traversa', abbreviation: 'Trav.' },
                    { name: 'Via', abbreviation: 'V.' },
                    { name: 'Viale', abbreviation: 'V.le' },
                    { name: 'Vicinale', abbreviation: 'Vic.le' },
                    { name: 'Vicolo', abbreviation: 'Vic.' }
                ],
                'uk' : [
                    {name: 'Avenue', abbreviation: 'Ave'},
                    {name: 'Close', abbreviation: 'Cl'},
                    {name: 'Court', abbreviation: 'Ct'},
                    {name: 'Crescent', abbreviation: 'Cr'},
                    {name: 'Drive', abbreviation: 'Dr'},
                    {name: 'Garden', abbreviation: 'Gdn'},
                    {name: 'Gardens', abbreviation: 'Gdns'},
                    {name: 'Green', abbreviation: 'Gn'},
                    {name: 'Grove', abbreviation: 'Gr'},
                    {name: 'Lane', abbreviation: 'Ln'},
                    {name: 'Mount', abbreviation: 'Mt'},
                    {name: 'Place', abbreviation: 'Pl'},
                    {name: 'Park', abbreviation: 'Pk'},
                    {name: 'Ridge', abbreviation: 'Rdg'},
                    {name: 'Road', abbreviation: 'Rd'},
                    {name: 'Square', abbreviation: 'Sq'},
                    {name: 'Street', abbreviation: 'St'},
                    {name: 'Terrace', abbreviation: 'Ter'},
                    {name: 'Valley', abbreviation: 'Val'}
                ]
            },

            months: [
                {name: 'January', short_name: 'Jan', numeric: '01', days: 31},
                // Not messing with leap years...
                {name: 'February', short_name: 'Feb', numeric: '02', days: 28},
                {name: 'March', short_name: 'Mar', numeric: '03', days: 31},
                {name: 'April', short_name: 'Apr', numeric: '04', days: 30},
                {name: 'May', short_name: 'May', numeric: '05', days: 31},
                {name: 'June', short_name: 'Jun', numeric: '06', days: 30},
                {name: 'July', short_name: 'Jul', numeric: '07', days: 31},
                {name: 'August', short_name: 'Aug', numeric: '08', days: 31},
                {name: 'September', short_name: 'Sep', numeric: '09', days: 30},
                {name: 'October', short_name: 'Oct', numeric: '10', days: 31},
                {name: 'November', short_name: 'Nov', numeric: '11', days: 30},
                {name: 'December', short_name: 'Dec', numeric: '12', days: 31}
            ],

            // http://en.wikipedia.org/wiki/Bank_card_number#Issuer_identification_number_.28IIN.29
            cc_types: [
                {name: "American Express", short_name: 'amex', prefix: '34', length: 15},
                {name: "Bankcard", short_name: 'bankcard', prefix: '5610', length: 16},
                {name: "China UnionPay", short_name: 'chinaunion', prefix: '62', length: 16},
                {name: "Diners Club Carte Blanche", short_name: 'dccarte', prefix: '300', length: 14},
                {name: "Diners Club enRoute", short_name: 'dcenroute', prefix: '2014', length: 15},
                {name: "Diners Club International", short_name: 'dcintl', prefix: '36', length: 14},
                {name: "Diners Club United States & Canada", short_name: 'dcusc', prefix: '54', length: 16},
                {name: "Discover Card", short_name: 'discover', prefix: '6011', length: 16},
                {name: "InstaPayment", short_name: 'instapay', prefix: '637', length: 16},
                {name: "JCB", short_name: 'jcb', prefix: '3528', length: 16},
                {name: "Laser", short_name: 'laser', prefix: '6304', length: 16},
                {name: "Maestro", short_name: 'maestro', prefix: '5018', length: 16},
                {name: "Mastercard", short_name: 'mc', prefix: '51', length: 16},
                {name: "Solo", short_name: 'solo', prefix: '6334', length: 16},
                {name: "Switch", short_name: 'switch', prefix: '4903', length: 16},
                {name: "Visa", short_name: 'visa', prefix: '4', length: 16},
                {name: "Visa Electron", short_name: 'electron', prefix: '4026', length: 16}
            ],

            //return all world currency by ISO 4217
            currency_types: [
                {'code' : 'AED', 'name' : 'United Arab Emirates Dirham'},
                {'code' : 'AFN', 'name' : 'Afghanistan Afghani'},
                {'code' : 'ALL', 'name' : 'Albania Lek'},
                {'code' : 'AMD', 'name' : 'Armenia Dram'},
                {'code' : 'ANG', 'name' : 'Netherlands Antilles Guilder'},
                {'code' : 'AOA', 'name' : 'Angola Kwanza'},
                {'code' : 'ARS', 'name' : 'Argentina Peso'},
                {'code' : 'AUD', 'name' : 'Australia Dollar'},
                {'code' : 'AWG', 'name' : 'Aruba Guilder'},
                {'code' : 'AZN', 'name' : 'Azerbaijan New Manat'},
                {'code' : 'BAM', 'name' : 'Bosnia and Herzegovina Convertible Marka'},
                {'code' : 'BBD', 'name' : 'Barbados Dollar'},
                {'code' : 'BDT', 'name' : 'Bangladesh Taka'},
                {'code' : 'BGN', 'name' : 'Bulgaria Lev'},
                {'code' : 'BHD', 'name' : 'Bahrain Dinar'},
                {'code' : 'BIF', 'name' : 'Burundi Franc'},
                {'code' : 'BMD', 'name' : 'Bermuda Dollar'},
                {'code' : 'BND', 'name' : 'Brunei Darussalam Dollar'},
                {'code' : 'BOB', 'name' : 'Bolivia Boliviano'},
                {'code' : 'BRL', 'name' : 'Brazil Real'},
                {'code' : 'BSD', 'name' : 'Bahamas Dollar'},
                {'code' : 'BTN', 'name' : 'Bhutan Ngultrum'},
                {'code' : 'BWP', 'name' : 'Botswana Pula'},
                {'code' : 'BYR', 'name' : 'Belarus Ruble'},
                {'code' : 'BZD', 'name' : 'Belize Dollar'},
                {'code' : 'CAD', 'name' : 'Canada Dollar'},
                {'code' : 'CDF', 'name' : 'Congo/Kinshasa Franc'},
                {'code' : 'CHF', 'name' : 'Switzerland Franc'},
                {'code' : 'CLP', 'name' : 'Chile Peso'},
                {'code' : 'CNY', 'name' : 'China Yuan Renminbi'},
                {'code' : 'COP', 'name' : 'Colombia Peso'},
                {'code' : 'CRC', 'name' : 'Costa Rica Colon'},
                {'code' : 'CUC', 'name' : 'Cuba Convertible Peso'},
                {'code' : 'CUP', 'name' : 'Cuba Peso'},
                {'code' : 'CVE', 'name' : 'Cape Verde Escudo'},
                {'code' : 'CZK', 'name' : 'Czech Republic Koruna'},
                {'code' : 'DJF', 'name' : 'Djibouti Franc'},
                {'code' : 'DKK', 'name' : 'Denmark Krone'},
                {'code' : 'DOP', 'name' : 'Dominican Republic Peso'},
                {'code' : 'DZD', 'name' : 'Algeria Dinar'},
                {'code' : 'EGP', 'name' : 'Egypt Pound'},
                {'code' : 'ERN', 'name' : 'Eritrea Nakfa'},
                {'code' : 'ETB', 'name' : 'Ethiopia Birr'},
                {'code' : 'EUR', 'name' : 'Euro Member Countries'},
                {'code' : 'FJD', 'name' : 'Fiji Dollar'},
                {'code' : 'FKP', 'name' : 'Falkland Islands (Malvinas) Pound'},
                {'code' : 'GBP', 'name' : 'United Kingdom Pound'},
                {'code' : 'GEL', 'name' : 'Georgia Lari'},
                {'code' : 'GGP', 'name' : 'Guernsey Pound'},
                {'code' : 'GHS', 'name' : 'Ghana Cedi'},
                {'code' : 'GIP', 'name' : 'Gibraltar Pound'},
                {'code' : 'GMD', 'name' : 'Gambia Dalasi'},
                {'code' : 'GNF', 'name' : 'Guinea Franc'},
                {'code' : 'GTQ', 'name' : 'Guatemala Quetzal'},
                {'code' : 'GYD', 'name' : 'Guyana Dollar'},
                {'code' : 'HKD', 'name' : 'Hong Kong Dollar'},
                {'code' : 'HNL', 'name' : 'Honduras Lempira'},
                {'code' : 'HRK', 'name' : 'Croatia Kuna'},
                {'code' : 'HTG', 'name' : 'Haiti Gourde'},
                {'code' : 'HUF', 'name' : 'Hungary Forint'},
                {'code' : 'IDR', 'name' : 'Indonesia Rupiah'},
                {'code' : 'ILS', 'name' : 'Israel Shekel'},
                {'code' : 'IMP', 'name' : 'Isle of Man Pound'},
                {'code' : 'INR', 'name' : 'India Rupee'},
                {'code' : 'IQD', 'name' : 'Iraq Dinar'},
                {'code' : 'IRR', 'name' : 'Iran Rial'},
                {'code' : 'ISK', 'name' : 'Iceland Krona'},
                {'code' : 'JEP', 'name' : 'Jersey Pound'},
                {'code' : 'JMD', 'name' : 'Jamaica Dollar'},
                {'code' : 'JOD', 'name' : 'Jordan Dinar'},
                {'code' : 'JPY', 'name' : 'Japan Yen'},
                {'code' : 'KES', 'name' : 'Kenya Shilling'},
                {'code' : 'KGS', 'name' : 'Kyrgyzstan Som'},
                {'code' : 'KHR', 'name' : 'Cambodia Riel'},
                {'code' : 'KMF', 'name' : 'Comoros Franc'},
                {'code' : 'KPW', 'name' : 'Korea (North) Won'},
                {'code' : 'KRW', 'name' : 'Korea (South) Won'},
                {'code' : 'KWD', 'name' : 'Kuwait Dinar'},
                {'code' : 'KYD', 'name' : 'Cayman Islands Dollar'},
                {'code' : 'KZT', 'name' : 'Kazakhstan Tenge'},
                {'code' : 'LAK', 'name' : 'Laos Kip'},
                {'code' : 'LBP', 'name' : 'Lebanon Pound'},
                {'code' : 'LKR', 'name' : 'Sri Lanka Rupee'},
                {'code' : 'LRD', 'name' : 'Liberia Dollar'},
                {'code' : 'LSL', 'name' : 'Lesotho Loti'},
                {'code' : 'LTL', 'name' : 'Lithuania Litas'},
                {'code' : 'LYD', 'name' : 'Libya Dinar'},
                {'code' : 'MAD', 'name' : 'Morocco Dirham'},
                {'code' : 'MDL', 'name' : 'Moldova Leu'},
                {'code' : 'MGA', 'name' : 'Madagascar Ariary'},
                {'code' : 'MKD', 'name' : 'Macedonia Denar'},
                {'code' : 'MMK', 'name' : 'Myanmar (Burma) Kyat'},
                {'code' : 'MNT', 'name' : 'Mongolia Tughrik'},
                {'code' : 'MOP', 'name' : 'Macau Pataca'},
                {'code' : 'MRO', 'name' : 'Mauritania Ouguiya'},
                {'code' : 'MUR', 'name' : 'Mauritius Rupee'},
                {'code' : 'MVR', 'name' : 'Maldives (Maldive Islands) Rufiyaa'},
                {'code' : 'MWK', 'name' : 'Malawi Kwacha'},
                {'code' : 'MXN', 'name' : 'Mexico Peso'},
                {'code' : 'MYR', 'name' : 'Malaysia Ringgit'},
                {'code' : 'MZN', 'name' : 'Mozambique Metical'},
                {'code' : 'NAD', 'name' : 'Namibia Dollar'},
                {'code' : 'NGN', 'name' : 'Nigeria Naira'},
                {'code' : 'NIO', 'name' : 'Nicaragua Cordoba'},
                {'code' : 'NOK', 'name' : 'Norway Krone'},
                {'code' : 'NPR', 'name' : 'Nepal Rupee'},
                {'code' : 'NZD', 'name' : 'New Zealand Dollar'},
                {'code' : 'OMR', 'name' : 'Oman Rial'},
                {'code' : 'PAB', 'name' : 'Panama Balboa'},
                {'code' : 'PEN', 'name' : 'Peru Nuevo Sol'},
                {'code' : 'PGK', 'name' : 'Papua New Guinea Kina'},
                {'code' : 'PHP', 'name' : 'Philippines Peso'},
                {'code' : 'PKR', 'name' : 'Pakistan Rupee'},
                {'code' : 'PLN', 'name' : 'Poland Zloty'},
                {'code' : 'PYG', 'name' : 'Paraguay Guarani'},
                {'code' : 'QAR', 'name' : 'Qatar Riyal'},
                {'code' : 'RON', 'name' : 'Romania New Leu'},
                {'code' : 'RSD', 'name' : 'Serbia Dinar'},
                {'code' : 'RUB', 'name' : 'Russia Ruble'},
                {'code' : 'RWF', 'name' : 'Rwanda Franc'},
                {'code' : 'SAR', 'name' : 'Saudi Arabia Riyal'},
                {'code' : 'SBD', 'name' : 'Solomon Islands Dollar'},
                {'code' : 'SCR', 'name' : 'Seychelles Rupee'},
                {'code' : 'SDG', 'name' : 'Sudan Pound'},
                {'code' : 'SEK', 'name' : 'Sweden Krona'},
                {'code' : 'SGD', 'name' : 'Singapore Dollar'},
                {'code' : 'SHP', 'name' : 'Saint Helena Pound'},
                {'code' : 'SLL', 'name' : 'Sierra Leone Leone'},
                {'code' : 'SOS', 'name' : 'Somalia Shilling'},
                {'code' : 'SPL', 'name' : 'Seborga Luigino'},
                {'code' : 'SRD', 'name' : 'Suriname Dollar'},
                {'code' : 'STD', 'name' : 'São Tomé and Príncipe Dobra'},
                {'code' : 'SVC', 'name' : 'El Salvador Colon'},
                {'code' : 'SYP', 'name' : 'Syria Pound'},
                {'code' : 'SZL', 'name' : 'Swaziland Lilangeni'},
                {'code' : 'THB', 'name' : 'Thailand Baht'},
                {'code' : 'TJS', 'name' : 'Tajikistan Somoni'},
                {'code' : 'TMT', 'name' : 'Turkmenistan Manat'},
                {'code' : 'TND', 'name' : 'Tunisia Dinar'},
                {'code' : 'TOP', 'name' : 'Tonga Pa\'anga'},
                {'code' : 'TRY', 'name' : 'Turkey Lira'},
                {'code' : 'TTD', 'name' : 'Trinidad and Tobago Dollar'},
                {'code' : 'TVD', 'name' : 'Tuvalu Dollar'},
                {'code' : 'TWD', 'name' : 'Taiwan New Dollar'},
                {'code' : 'TZS', 'name' : 'Tanzania Shilling'},
                {'code' : 'UAH', 'name' : 'Ukraine Hryvnia'},
                {'code' : 'UGX', 'name' : 'Uganda Shilling'},
                {'code' : 'USD', 'name' : 'United States Dollar'},
                {'code' : 'UYU', 'name' : 'Uruguay Peso'},
                {'code' : 'UZS', 'name' : 'Uzbekistan Som'},
                {'code' : 'VEF', 'name' : 'Venezuela Bolivar'},
                {'code' : 'VND', 'name' : 'Viet Nam Dong'},
                {'code' : 'VUV', 'name' : 'Vanuatu Vatu'},
                {'code' : 'WST', 'name' : 'Samoa Tala'},
                {'code' : 'XAF', 'name' : 'Communauté Financière Africaine (BEAC) CFA Franc BEAC'},
                {'code' : 'XCD', 'name' : 'East Caribbean Dollar'},
                {'code' : 'XDR', 'name' : 'International Monetary Fund (IMF) Special Drawing Rights'},
                {'code' : 'XOF', 'name' : 'Communauté Financière Africaine (BCEAO) Franc'},
                {'code' : 'XPF', 'name' : 'Comptoirs Français du Pacifique (CFP) Franc'},
                {'code' : 'YER', 'name' : 'Yemen Rial'},
                {'code' : 'ZAR', 'name' : 'South Africa Rand'},
                {'code' : 'ZMW', 'name' : 'Zambia Kwacha'},
                {'code' : 'ZWD', 'name' : 'Zimbabwe Dollar'}
            ],

            // return the names of all valide colors
            colorNames : [  "AliceBlue", "Black", "Navy", "DarkBlue", "MediumBlue", "Blue", "DarkGreen", "Green", "Teal", "DarkCyan", "DeepSkyBlue", "DarkTurquoise", "MediumSpringGreen", "Lime", "SpringGreen",
                "Aqua", "Cyan", "MidnightBlue", "DodgerBlue", "LightSeaGreen", "ForestGreen", "SeaGreen", "DarkSlateGray", "LimeGreen", "MediumSeaGreen", "Turquoise", "RoyalBlue", "SteelBlue", "DarkSlateBlue", "MediumTurquoise",
                "Indigo", "DarkOliveGreen", "CadetBlue", "CornflowerBlue", "RebeccaPurple", "MediumAquaMarine", "DimGray", "SlateBlue", "OliveDrab", "SlateGray", "LightSlateGray", "MediumSlateBlue", "LawnGreen", "Chartreuse",
                "Aquamarine", "Maroon", "Purple", "Olive", "Gray", "SkyBlue", "LightSkyBlue", "BlueViolet", "DarkRed", "DarkMagenta", "SaddleBrown", "Ivory", "White",
                "DarkSeaGreen", "LightGreen", "MediumPurple", "DarkViolet", "PaleGreen", "DarkOrchid", "YellowGreen", "Sienna", "Brown", "DarkGray", "LightBlue", "GreenYellow", "PaleTurquoise", "LightSteelBlue", "PowderBlue",
                "FireBrick", "DarkGoldenRod", "MediumOrchid", "RosyBrown", "DarkKhaki", "Silver", "MediumVioletRed", "IndianRed", "Peru", "Chocolate", "Tan", "LightGray", "Thistle", "Orchid", "GoldenRod", "PaleVioletRed",
                "Crimson", "Gainsboro", "Plum", "BurlyWood", "LightCyan", "Lavender", "DarkSalmon", "Violet", "PaleGoldenRod", "LightCoral", "Khaki", "AliceBlue", "HoneyDew", "Azure", "SandyBrown", "Wheat", "Beige", "WhiteSmoke",
                "MintCream", "GhostWhite", "Salmon", "AntiqueWhite", "Linen", "LightGoldenRodYellow", "OldLace", "Red", "Fuchsia", "Magenta", "DeepPink", "OrangeRed", "Tomato", "HotPink", "Coral", "DarkOrange", "LightSalmon", "Orange",
                "LightPink", "Pink", "Gold", "PeachPuff", "NavajoWhite", "Moccasin", "Bisque", "MistyRose", "BlanchedAlmond", "PapayaWhip", "LavenderBlush", "SeaShell", "Cornsilk", "LemonChiffon", "FloralWhite", "Snow", "Yellow", "LightYellow"
            ],

            // Data taken from https://www.sec.gov/rules/other/4-460list.htm
            company: [ "3Com Corp",
            "3M Company",
            "A.G. Edwards Inc.",
            "Abbott Laboratories",
            "Abercrombie & Fitch Co.",
            "ABM Industries Incorporated",
            "Ace Hardware Corporation",
            "ACT Manufacturing Inc.",
            "Acterna Corp.",
            "Adams Resources & Energy, Inc.",
            "ADC Telecommunications, Inc.",
            "Adelphia Communications Corporation",
            "Administaff, Inc.",
            "Adobe Systems Incorporated",
            "Adolph Coors Company",
            "Advance Auto Parts, Inc.",
            "Advanced Micro Devices, Inc.",
            "AdvancePCS, Inc.",
            "Advantica Restaurant Group, Inc.",
            "The AES Corporation",
            "Aetna Inc.",
            "Affiliated Computer Services, Inc.",
            "AFLAC Incorporated",
            "AGCO Corporation",
            "Agilent Technologies, Inc.",
            "Agway Inc.",
            "Apartment Investment and Management Company",
            "Air Products and Chemicals, Inc.",
            "Airborne, Inc.",
            "Airgas, Inc.",
            "AK Steel Holding Corporation",
            "Alaska Air Group, Inc.",
            "Alberto-Culver Company",
            "Albertson's, Inc.",
            "Alcoa Inc.",
            "Alleghany Corporation",
            "Allegheny Energy, Inc.",
            "Allegheny Technologies Incorporated",
            "Allergan, Inc.",
            "ALLETE, Inc.",
            "Alliant Energy Corporation",
            "Allied Waste Industries, Inc.",
            "Allmerica Financial Corporation",
            "The Allstate Corporation",
            "ALLTEL Corporation",
            "The Alpine Group, Inc.",
            "Amazon.com, Inc.",
            "AMC Entertainment Inc.",
            "American Power Conversion Corporation",
            "Amerada Hess Corporation",
            "AMERCO",
            "Ameren Corporation",
            "America West Holdings Corporation",
            "American Axle & Manufacturing Holdings, Inc.",
            "American Eagle Outfitters, Inc.",
            "American Electric Power Company, Inc.",
            "American Express Company",
            "American Financial Group, Inc.",
            "American Greetings Corporation",
            "American International Group, Inc.",
            "American Standard Companies Inc.",
            "American Water Works Company, Inc.",
            "AmerisourceBergen Corporation",
            "Ames Department Stores, Inc.",
            "Amgen Inc.",
            "Amkor Technology, Inc.",
            "AMR Corporation",
            "AmSouth Bancorp.",
            "Amtran, Inc.",
            "Anadarko Petroleum Corporation",
            "Analog Devices, Inc.",
            "Anheuser-Busch Companies, Inc.",
            "Anixter International Inc.",
            "AnnTaylor Inc.",
            "Anthem, Inc.",
            "AOL Time Warner Inc.",
            "Aon Corporation",
            "Apache Corporation",
            "Apple Computer, Inc.",
            "Applera Corporation",
            "Applied Industrial Technologies, Inc.",
            "Applied Materials, Inc.",
            "Aquila, Inc.",
            "ARAMARK Corporation",
            "Arch Coal, Inc.",
            "Archer Daniels Midland Company",
            "Arkansas Best Corporation",
            "Armstrong Holdings, Inc.",
            "Arrow Electronics, Inc.",
            "ArvinMeritor, Inc.",
            "Ashland Inc.",
            "Astoria Financial Corporation",
            "AT&T Corp.",
            "Atmel Corporation",
            "Atmos Energy Corporation",
            "Audiovox Corporation",
            "Autoliv, Inc.",
            "Automatic Data Processing, Inc.",
            "AutoNation, Inc.",
            "AutoZone, Inc.",
            "Avaya Inc.",
            "Avery Dennison Corporation",
            "Avista Corporation",
            "Avnet, Inc.",
            "Avon Products, Inc.",
            "Baker Hughes Incorporated",
            "Ball Corporation",
            "Bank of America Corporation",
            "The Bank of New York Company, Inc.",
            "Bank One Corporation",
            "Banknorth Group, Inc.",
            "Banta Corporation",
            "Barnes & Noble, Inc.",
            "Bausch & Lomb Incorporated",
            "Baxter International Inc.",
            "BB&T Corporation",
            "The Bear Stearns Companies Inc.",
            "Beazer Homes USA, Inc.",
            "Beckman Coulter, Inc.",
            "Becton, Dickinson and Company",
            "Bed Bath & Beyond Inc.",
            "Belk, Inc.",
            "Bell Microproducts Inc.",
            "BellSouth Corporation",
            "Belo Corp.",
            "Bemis Company, Inc.",
            "Benchmark Electronics, Inc.",
            "Berkshire Hathaway Inc.",
            "Best Buy Co., Inc.",
            "Bethlehem Steel Corporation",
            "Beverly Enterprises, Inc.",
            "Big Lots, Inc.",
            "BJ Services Company",
            "BJ's Wholesale Club, Inc.",
            "The Black & Decker Corporation",
            "Black Hills Corporation",
            "BMC Software, Inc.",
            "The Boeing Company",
            "Boise Cascade Corporation",
            "Borders Group, Inc.",
            "BorgWarner Inc.",
            "Boston Scientific Corporation",
            "Bowater Incorporated",
            "Briggs & Stratton Corporation",
            "Brightpoint, Inc.",
            "Brinker International, Inc.",
            "Bristol-Myers Squibb Company",
            "Broadwing, Inc.",
            "Brown Shoe Company, Inc.",
            "Brown-Forman Corporation",
            "Brunswick Corporation",
            "Budget Group, Inc.",
            "Burlington Coat Factory Warehouse Corporation",
            "Burlington Industries, Inc.",
            "Burlington Northern Santa Fe Corporation",
            "Burlington Resources Inc.",
            "C. H. Robinson Worldwide Inc.",
            "Cablevision Systems Corp",
            "Cabot Corp",
            "Cadence Design Systems, Inc.",
            "Calpine Corp.",
            "Campbell Soup Co.",
            "Capital One Financial Corp.",
            "Cardinal Health Inc.",
            "Caremark Rx Inc.",
            "Carlisle Cos. Inc.",
            "Carpenter Technology Corp.",
            "Casey's General Stores Inc.",
            "Caterpillar Inc.",
            "CBRL Group Inc.",
            "CDI Corp.",
            "CDW Computer Centers Inc.",
            "CellStar Corp.",
            "Cendant Corp",
            "Cenex Harvest States Cooperatives",
            "Centex Corp.",
            "CenturyTel Inc.",
            "Ceridian Corp.",
            "CH2M Hill Cos. Ltd.",
            "Champion Enterprises Inc.",
            "Charles Schwab Corp.",
            "Charming Shoppes Inc.",
            "Charter Communications Inc.",
            "Charter One Financial Inc.",
            "ChevronTexaco Corp.",
            "Chiquita Brands International Inc.",
            "Chubb Corp",
            "Ciena Corp.",
            "Cigna Corp",
            "Cincinnati Financial Corp.",
            "Cinergy Corp.",
            "Cintas Corp.",
            "Circuit City Stores Inc.",
            "Cisco Systems Inc.",
            "Citigroup, Inc",
            "Citizens Communications Co.",
            "CKE Restaurants Inc.",
            "Clear Channel Communications Inc.",
            "The Clorox Co.",
            "CMGI Inc.",
            "CMS Energy Corp.",
            "CNF Inc.",
            "Coca-Cola Co.",
            "Coca-Cola Enterprises Inc.",
            "Colgate-Palmolive Co.",
            "Collins & Aikman Corp.",
            "Comcast Corp.",
            "Comdisco Inc.",
            "Comerica Inc.",
            "Comfort Systems USA Inc.",
            "Commercial Metals Co.",
            "Community Health Systems Inc.",
            "Compass Bancshares Inc",
            "Computer Associates International Inc.",
            "Computer Sciences Corp.",
            "Compuware Corp.",
            "Comverse Technology Inc.",
            "ConAgra Foods Inc.",
            "Concord EFS Inc.",
            "Conectiv, Inc",
            "Conoco Inc",
            "Conseco Inc.",
            "Consolidated Freightways Corp.",
            "Consolidated Edison Inc.",
            "Constellation Brands Inc.",
            "Constellation Emergy Group Inc.",
            "Continental Airlines Inc.",
            "Convergys Corp.",
            "Cooper Cameron Corp.",
            "Cooper Industries Ltd.",
            "Cooper Tire & Rubber Co.",
            "Corn Products International Inc.",
            "Corning Inc.",
            "Costco Wholesale Corp.",
            "Countrywide Credit Industries Inc.",
            "Coventry Health Care Inc.",
            "Cox Communications Inc.",
            "Crane Co.",
            "Crompton Corp.",
            "Crown Cork & Seal Co. Inc.",
            "CSK Auto Corp.",
            "CSX Corp.",
            "Cummins Inc.",
            "CVS Corp.",
            "Cytec Industries Inc.",
            "D&K Healthcare Resources, Inc.",
            "D.R. Horton Inc.",
            "Dana Corporation",
            "Danaher Corporation",
            "Darden Restaurants Inc.",
            "DaVita Inc.",
            "Dean Foods Company",
            "Deere & Company",
            "Del Monte Foods Co",
            "Dell Computer Corporation",
            "Delphi Corp.",
            "Delta Air Lines Inc.",
            "Deluxe Corporation",
            "Devon Energy Corporation",
            "Di Giorgio Corporation",
            "Dial Corporation",
            "Diebold Incorporated",
            "Dillard's Inc.",
            "DIMON Incorporated",
            "Dole Food Company, Inc.",
            "Dollar General Corporation",
            "Dollar Tree Stores, Inc.",
            "Dominion Resources, Inc.",
            "Domino's Pizza LLC",
            "Dover Corporation, Inc.",
            "Dow Chemical Company",
            "Dow Jones & Company, Inc.",
            "DPL Inc.",
            "DQE Inc.",
            "Dreyer's Grand Ice Cream, Inc.",
            "DST Systems, Inc.",
            "DTE Energy Co.",
            "E.I. Du Pont de Nemours and Company",
            "Duke Energy Corp",
            "Dun & Bradstreet Inc.",
            "DURA Automotive Systems Inc.",
            "DynCorp",
            "Dynegy Inc.",
            "E*Trade Group, Inc.",
            "E.W. Scripps Company",
            "Earthlink, Inc.",
            "Eastman Chemical Company",
            "Eastman Kodak Company",
            "Eaton Corporation",
            "Echostar Communications Corporation",
            "Ecolab Inc.",
            "Edison International",
            "EGL Inc.",
            "El Paso Corporation",
            "Electronic Arts Inc.",
            "Electronic Data Systems Corp.",
            "Eli Lilly and Company",
            "EMC Corporation",
            "Emcor Group Inc.",
            "Emerson Electric Co.",
            "Encompass Services Corporation",
            "Energizer Holdings Inc.",
            "Energy East Corporation",
            "Engelhard Corporation",
            "Enron Corp.",
            "Entergy Corporation",
            "Enterprise Products Partners L.P.",
            "EOG Resources, Inc.",
            "Equifax Inc.",
            "Equitable Resources Inc.",
            "Equity Office Properties Trust",
            "Equity Residential Properties Trust",
            "Estee Lauder Companies Inc.",
            "Exelon Corporation",
            "Exide Technologies",
            "Expeditors International of Washington Inc.",
            "Express Scripts Inc.",
            "ExxonMobil Corporation",
            "Fairchild Semiconductor International Inc.",
            "Family Dollar Stores Inc.",
            "Farmland Industries Inc.",
            "Federal Mogul Corp.",
            "Federated Department Stores Inc.",
            "Federal Express Corp.",
            "Felcor Lodging Trust Inc.",
            "Ferro Corp.",
            "Fidelity National Financial Inc.",
            "Fifth Third Bancorp",
            "First American Financial Corp.",
            "First Data Corp.",
            "First National of Nebraska Inc.",
            "First Tennessee National Corp.",
            "FirstEnergy Corp.",
            "Fiserv Inc.",
            "Fisher Scientific International Inc.",
            "FleetBoston Financial Co.",
            "Fleetwood Enterprises Inc.",
            "Fleming Companies Inc.",
            "Flowers Foods Inc.",
            "Flowserv Corp",
            "Fluor Corp",
            "FMC Corp",
            "Foamex International Inc",
            "Foot Locker Inc",
            "Footstar Inc.",
            "Ford Motor Co",
            "Forest Laboratories Inc.",
            "Fortune Brands Inc.",
            "Foster Wheeler Ltd.",
            "FPL Group Inc.",
            "Franklin Resources Inc.",
            "Freeport McMoran Copper & Gold Inc.",
            "Frontier Oil Corp",
            "Furniture Brands International Inc.",
            "Gannett Co., Inc.",
            "Gap Inc.",
            "Gateway Inc.",
            "GATX Corporation",
            "Gemstar-TV Guide International Inc.",
            "GenCorp Inc.",
            "General Cable Corporation",
            "General Dynamics Corporation",
            "General Electric Company",
            "General Mills Inc",
            "General Motors Corporation",
            "Genesis Health Ventures Inc.",
            "Gentek Inc.",
            "Gentiva Health Services Inc.",
            "Genuine Parts Company",
            "Genuity Inc.",
            "Genzyme Corporation",
            "Georgia Gulf Corporation",
            "Georgia-Pacific Corporation",
            "Gillette Company",
            "Gold Kist Inc.",
            "Golden State Bancorp Inc.",
            "Golden West Financial Corporation",
            "Goldman Sachs Group Inc.",
            "Goodrich Corporation",
            "The Goodyear Tire & Rubber Company",
            "Granite Construction Incorporated",
            "Graybar Electric Company Inc.",
            "Great Lakes Chemical Corporation",
            "Great Plains Energy Inc.",
            "GreenPoint Financial Corp.",
            "Greif Bros. Corporation",
            "Grey Global Group Inc.",
            "Group 1 Automotive Inc.",
            "Guidant Corporation",
            "H&R Block Inc.",
            "H.B. Fuller Company",
            "H.J. Heinz Company",
            "Halliburton Co.",
            "Harley-Davidson Inc.",
            "Harman International Industries Inc.",
            "Harrah's Entertainment Inc.",
            "Harris Corp.",
            "Harsco Corp.",
            "Hartford Financial Services Group Inc.",
            "Hasbro Inc.",
            "Hawaiian Electric Industries Inc.",
            "HCA Inc.",
            "Health Management Associates Inc.",
            "Health Net Inc.",
            "Healthsouth Corp",
            "Henry Schein Inc.",
            "Hercules Inc.",
            "Herman Miller Inc.",
            "Hershey Foods Corp.",
            "Hewlett-Packard Company",
            "Hibernia Corp.",
            "Hillenbrand Industries Inc.",
            "Hilton Hotels Corp.",
            "Hollywood Entertainment Corp.",
            "Home Depot Inc.",
            "Hon Industries Inc.",
            "Honeywell International Inc.",
            "Hormel Foods Corp.",
            "Host Marriott Corp.",
            "Household International Corp.",
            "Hovnanian Enterprises Inc.",
            "Hub Group Inc.",
            "Hubbell Inc.",
            "Hughes Supply Inc.",
            "Humana Inc.",
            "Huntington Bancshares Inc.",
            "Idacorp Inc.",
            "IDT Corporation",
            "IKON Office Solutions Inc.",
            "Illinois Tool Works Inc.",
            "IMC Global Inc.",
            "Imperial Sugar Company",
            "IMS Health Inc.",
            "Ingles Market Inc",
            "Ingram Micro Inc.",
            "Insight Enterprises Inc.",
            "Integrated Electrical Services Inc.",
            "Intel Corporation",
            "International Paper Co.",
            "Interpublic Group of Companies Inc.",
            "Interstate Bakeries Corporation",
            "International Business Machines Corp.",
            "International Flavors & Fragrances Inc.",
            "International Multifoods Corporation",
            "Intuit Inc.",
            "IT Group Inc.",
            "ITT Industries Inc.",
            "Ivax Corp.",
            "J.B. Hunt Transport Services Inc.",
            "J.C. Penny Co.",
            "J.P. Morgan Chase & Co.",
            "Jabil Circuit Inc.",
            "Jack In The Box Inc.",
            "Jacobs Engineering Group Inc.",
            "JDS Uniphase Corp.",
            "Jefferson-Pilot Co.",
            "John Hancock Financial Services Inc.",
            "Johnson & Johnson",
            "Johnson Controls Inc.",
            "Jones Apparel Group Inc.",
            "KB Home",
            "Kellogg Company",
            "Kellwood Company",
            "Kelly Services Inc.",
            "Kemet Corp.",
            "Kennametal Inc.",
            "Kerr-McGee Corporation",
            "KeyCorp",
            "KeySpan Corp.",
            "Kimball International Inc.",
            "Kimberly-Clark Corporation",
            "Kindred Healthcare Inc.",
            "KLA-Tencor Corporation",
            "K-Mart Corp.",
            "Knight-Ridder Inc.",
            "Kohl's Corp.",
            "KPMG Consulting Inc.",
            "Kroger Co.",
            "L-3 Communications Holdings Inc.",
            "Laboratory Corporation of America Holdings",
            "Lam Research Corporation",
            "LandAmerica Financial Group Inc.",
            "Lands' End Inc.",
            "Landstar System Inc.",
            "La-Z-Boy Inc.",
            "Lear Corporation",
            "Legg Mason Inc.",
            "Leggett & Platt Inc.",
            "Lehman Brothers Holdings Inc.",
            "Lennar Corporation",
            "Lennox International Inc.",
            "Level 3 Communications Inc.",
            "Levi Strauss & Co.",
            "Lexmark International Inc.",
            "Limited Inc.",
            "Lincoln National Corporation",
            "Linens 'n Things Inc.",
            "Lithia Motors Inc.",
            "Liz Claiborne Inc.",
            "Lockheed Martin Corporation",
            "Loews Corporation",
            "Longs Drug Stores Corporation",
            "Louisiana-Pacific Corporation",
            "Lowe's Companies Inc.",
            "LSI Logic Corporation",
            "The LTV Corporation",
            "The Lubrizol Corporation",
            "Lucent Technologies Inc.",
            "Lyondell Chemical Company",
            "M & T Bank Corporation",
            "Magellan Health Services Inc.",
            "Mail-Well Inc.",
            "Mandalay Resort Group",
            "Manor Care Inc.",
            "Manpower Inc.",
            "Marathon Oil Corporation",
            "Mariner Health Care Inc.",
            "Markel Corporation",
            "Marriott International Inc.",
            "Marsh & McLennan Companies Inc.",
            "Marsh Supermarkets Inc.",
            "Marshall & Ilsley Corporation",
            "Martin Marietta Materials Inc.",
            "Masco Corporation",
            "Massey Energy Company",
            "MasTec Inc.",
            "Mattel Inc.",
            "Maxim Integrated Products Inc.",
            "Maxtor Corporation",
            "Maxxam Inc.",
            "The May Department Stores Company",
            "Maytag Corporation",
            "MBNA Corporation",
            "McCormick & Company Incorporated",
            "McDonald's Corporation",
            "The McGraw-Hill Companies Inc.",
            "McKesson Corporation",
            "McLeodUSA Incorporated",
            "M.D.C. Holdings Inc.",
            "MDU Resources Group Inc.",
            "MeadWestvaco Corporation",
            "Medtronic Inc.",
            "Mellon Financial Corporation",
            "The Men's Wearhouse Inc.",
            "Merck & Co., Inc.",
            "Mercury General Corporation",
            "Merrill Lynch & Co. Inc.",
            "Metaldyne Corporation",
            "Metals USA Inc.",
            "MetLife Inc.",
            "Metris Companies Inc",
            "MGIC Investment Corporation",
            "MGM Mirage",
            "Michaels Stores Inc.",
            "Micron Technology Inc.",
            "Microsoft Corporation",
            "Milacron Inc.",
            "Millennium Chemicals Inc.",
            "Mirant Corporation",
            "Mohawk Industries Inc.",
            "Molex Incorporated",
            "The MONY Group Inc.",
            "Morgan Stanley Dean Witter & Co.",
            "Motorola Inc.",
            "MPS Group Inc.",
            "Murphy Oil Corporation",
            "Nabors Industries Inc",
            "Nacco Industries Inc",
            "Nash Finch Company",
            "National City Corp.",
            "National Commerce Financial Corporation",
            "National Fuel Gas Company",
            "National Oilwell Inc",
            "National Rural Utilities Cooperative Finance Corporation",
            "National Semiconductor Corporation",
            "National Service Industries Inc",
            "Navistar International Corporation",
            "NCR Corporation",
            "The Neiman Marcus Group Inc.",
            "New Jersey Resources Corporation",
            "New York Times Company",
            "Newell Rubbermaid Inc",
            "Newmont Mining Corporation",
            "Nextel Communications Inc",
            "Nicor Inc",
            "Nike Inc",
            "NiSource Inc",
            "Noble Energy Inc",
            "Nordstrom Inc",
            "Norfolk Southern Corporation",
            "Nortek Inc",
            "North Fork Bancorporation Inc",
            "Northeast Utilities System",
            "Northern Trust Corporation",
            "Northrop Grumman Corporation",
            "NorthWestern Corporation",
            "Novellus Systems Inc",
            "NSTAR",
            "NTL Incorporated",
            "Nucor Corp",
            "Nvidia Corp",
            "NVR Inc",
            "Northwest Airlines Corp",
            "Occidental Petroleum Corp",
            "Ocean Energy Inc",
            "Office Depot Inc.",
            "OfficeMax Inc",
            "OGE Energy Corp",
            "Oglethorpe Power Corp.",
            "Ohio Casualty Corp.",
            "Old Republic International Corp.",
            "Olin Corp.",
            "OM Group Inc",
            "Omnicare Inc",
            "Omnicom Group",
            "On Semiconductor Corp",
            "ONEOK Inc",
            "Oracle Corp",
            "Oshkosh Truck Corp",
            "Outback Steakhouse Inc.",
            "Owens & Minor Inc.",
            "Owens Corning",
            "Owens-Illinois Inc",
            "Oxford Health Plans Inc",
            "Paccar Inc",
            "PacifiCare Health Systems Inc",
            "Packaging Corp. of America",
            "Pactiv Corp",
            "Pall Corp",
            "Pantry Inc",
            "Park Place Entertainment Corp",
            "Parker Hannifin Corp.",
            "Pathmark Stores Inc.",
            "Paychex Inc",
            "Payless Shoesource Inc",
            "Penn Traffic Co.",
            "Pennzoil-Quaker State Company",
            "Pentair Inc",
            "Peoples Energy Corp.",
            "PeopleSoft Inc",
            "Pep Boys Manny, Moe & Jack",
            "Potomac Electric Power Co.",
            "Pepsi Bottling Group Inc.",
            "PepsiAmericas Inc.",
            "PepsiCo Inc.",
            "Performance Food Group Co.",
            "Perini Corp",
            "PerkinElmer Inc",
            "Perot Systems Corp",
            "Petco Animal Supplies Inc.",
            "Peter Kiewit Sons', Inc.",
            "PETsMART Inc",
            "Pfizer Inc",
            "Pacific Gas & Electric Corp.",
            "Pharmacia Corp",
            "Phar Mor Inc.",
            "Phelps Dodge Corp.",
            "Philip Morris Companies Inc.",
            "Phillips Petroleum Co",
            "Phillips Van Heusen Corp.",
            "Phoenix Companies Inc",
            "Pier 1 Imports Inc.",
            "Pilgrim's Pride Corporation",
            "Pinnacle West Capital Corp",
            "Pioneer-Standard Electronics Inc.",
            "Pitney Bowes Inc.",
            "Pittston Brinks Group",
            "Plains All American Pipeline LP",
            "PNC Financial Services Group Inc.",
            "PNM Resources Inc",
            "Polaris Industries Inc.",
            "Polo Ralph Lauren Corp",
            "PolyOne Corp",
            "Popular Inc",
            "Potlatch Corp",
            "PPG Industries Inc",
            "PPL Corp",
            "Praxair Inc",
            "Precision Castparts Corp",
            "Premcor Inc.",
            "Pride International Inc",
            "Primedia Inc",
            "Principal Financial Group Inc.",
            "Procter & Gamble Co.",
            "Pro-Fac Cooperative Inc.",
            "Progress Energy Inc",
            "Progressive Corporation",
            "Protective Life Corp",
            "Provident Financial Group",
            "Providian Financial Corp.",
            "Prudential Financial Inc.",
            "PSS World Medical Inc",
            "Public Service Enterprise Group Inc.",
            "Publix Super Markets Inc.",
            "Puget Energy Inc.",
            "Pulte Homes Inc",
            "Qualcomm Inc",
            "Quanta Services Inc.",
            "Quantum Corp",
            "Quest Diagnostics Inc.",
            "Questar Corp",
            "Quintiles Transnational",
            "Qwest Communications Intl Inc",
            "R.J. Reynolds Tobacco Company",
            "R.R. Donnelley & Sons Company",
            "Radio Shack Corporation",
            "Raymond James Financial Inc.",
            "Raytheon Company",
            "Reader's Digest Association Inc.",
            "Reebok International Ltd.",
            "Regions Financial Corp.",
            "Regis Corporation",
            "Reliance Steel & Aluminum Co.",
            "Reliant Energy Inc.",
            "Rent A Center Inc",
            "Republic Services Inc",
            "Revlon Inc",
            "RGS Energy Group Inc",
            "Rite Aid Corp",
            "Riverwood Holding Inc.",
            "RoadwayCorp",
            "Robert Half International Inc.",
            "Rock-Tenn Co",
            "Rockwell Automation Inc",
            "Rockwell Collins Inc",
            "Rohm & Haas Co.",
            "Ross Stores Inc",
            "RPM Inc.",
            "Ruddick Corp",
            "Ryder System Inc",
            "Ryerson Tull Inc",
            "Ryland Group Inc.",
            "Sabre Holdings Corp",
            "Safeco Corp",
            "Safeguard Scientifics Inc.",
            "Safeway Inc",
            "Saks Inc",
            "Sanmina-SCI Inc",
            "Sara Lee Corp",
            "SBC Communications Inc",
            "Scana Corp.",
            "Schering-Plough Corp",
            "Scholastic Corp",
            "SCI Systems Onc.",
            "Science Applications Intl. Inc.",
            "Scientific-Atlanta Inc",
            "Scotts Company",
            "Seaboard Corp",
            "Sealed Air Corp",
            "Sears Roebuck & Co",
            "Sempra Energy",
            "Sequa Corp",
            "Service Corp. International",
            "ServiceMaster Co",
            "Shaw Group Inc",
            "Sherwin-Williams Company",
            "Shopko Stores Inc",
            "Siebel Systems Inc",
            "Sierra Health Services Inc",
            "Sierra Pacific Resources",
            "Silgan Holdings Inc.",
            "Silicon Graphics Inc",
            "Simon Property Group Inc",
            "SLM Corporation",
            "Smith International Inc",
            "Smithfield Foods Inc",
            "Smurfit-Stone Container Corp",
            "Snap-On Inc",
            "Solectron Corp",
            "Solutia Inc",
            "Sonic Automotive Inc.",
            "Sonoco Products Co.",
            "Southern Company",
            "Southern Union Company",
            "SouthTrust Corp.",
            "Southwest Airlines Co",
            "Southwest Gas Corp",
            "Sovereign Bancorp Inc.",
            "Spartan Stores Inc",
            "Spherion Corp",
            "Sports Authority Inc",
            "Sprint Corp.",
            "SPX Corp",
            "St. Jude Medical Inc",
            "St. Paul Cos.",
            "Staff Leasing Inc.",
            "StanCorp Financial Group Inc",
            "Standard Pacific Corp.",
            "Stanley Works",
            "Staples Inc",
            "Starbucks Corp",
            "Starwood Hotels & Resorts Worldwide Inc",
            "State Street Corp.",
            "Stater Bros. Holdings Inc.",
            "Steelcase Inc",
            "Stein Mart Inc",
            "Stewart & Stevenson Services Inc",
            "Stewart Information Services Corp",
            "Stilwell Financial Inc",
            "Storage Technology Corporation",
            "Stryker Corp",
            "Sun Healthcare Group Inc.",
            "Sun Microsystems Inc.",
            "SunGard Data Systems Inc.",
            "Sunoco Inc.",
            "SunTrust Banks Inc",
            "Supervalu Inc",
            "Swift Transportation, Co., Inc",
            "Symbol Technologies Inc",
            "Synovus Financial Corp.",
            "Sysco Corp",
            "Systemax Inc.",
            "Target Corp.",
            "Tech Data Corporation",
            "TECO Energy Inc",
            "Tecumseh Products Company",
            "Tektronix Inc",
            "Teleflex Incorporated",
            "Telephone & Data Systems Inc",
            "Tellabs Inc.",
            "Temple-Inland Inc",
            "Tenet Healthcare Corporation",
            "Tenneco Automotive Inc.",
            "Teradyne Inc",
            "Terex Corp",
            "Tesoro Petroleum Corp.",
            "Texas Industries Inc.",
            "Texas Instruments Incorporated",
            "Textron Inc",
            "Thermo Electron Corporation",
            "Thomas & Betts Corporation",
            "Tiffany & Co",
            "Timken Company",
            "TJX Companies Inc",
            "TMP Worldwide Inc",
            "Toll Brothers Inc",
            "Torchmark Corporation",
            "Toro Company",
            "Tower Automotive Inc.",
            "Toys 'R' Us Inc",
            "Trans World Entertainment Corp.",
            "TransMontaigne Inc",
            "Transocean Inc",
            "TravelCenters of America Inc.",
            "Triad Hospitals Inc",
            "Tribune Company",
            "Trigon Healthcare Inc.",
            "Trinity Industries Inc",
            "Trump Hotels & Casino Resorts Inc.",
            "TruServ Corporation",
            "TRW Inc",
            "TXU Corp",
            "Tyson Foods Inc",
            "U.S. Bancorp",
            "U.S. Industries Inc.",
            "UAL Corporation",
            "UGI Corporation",
            "Unified Western Grocers Inc",
            "Union Pacific Corporation",
            "Union Planters Corp",
            "Unisource Energy Corp",
            "Unisys Corporation",
            "United Auto Group Inc",
            "United Defense Industries Inc.",
            "United Parcel Service Inc",
            "United Rentals Inc",
            "United Stationers Inc",
            "United Technologies Corporation",
            "UnitedHealth Group Incorporated",
            "Unitrin Inc",
            "Universal Corporation",
            "Universal Forest Products Inc",
            "Universal Health Services Inc",
            "Unocal Corporation",
            "Unova Inc",
            "UnumProvident Corporation",
            "URS Corporation",
            "US Airways Group Inc",
            "US Oncology Inc",
            "USA Interactive",
            "USFreighways Corporation",
            "USG Corporation",
            "UST Inc",
            "Valero Energy Corporation",
            "Valspar Corporation",
            "Value City Department Stores Inc",
            "Varco International Inc",
            "Vectren Corporation",
            "Veritas Software Corporation",
            "Verizon Communications Inc",
            "VF Corporation",
            "Viacom Inc",
            "Viad Corp",
            "Viasystems Group Inc",
            "Vishay Intertechnology Inc",
            "Visteon Corporation",
            "Volt Information Sciences Inc",
            "Vulcan Materials Company",
            "W.R. Berkley Corporation",
            "W.R. Grace & Co",
            "W.W. Grainger Inc",
            "Wachovia Corporation",
            "Wakenhut Corporation",
            "Walgreen Co",
            "Wallace Computer Services Inc",
            "Wal-Mart Stores Inc",
            "Walt Disney Co",
            "Walter Industries Inc",
            "Washington Mutual Inc",
            "Washington Post Co.",
            "Waste Management Inc",
            "Watsco Inc",
            "Weatherford International Inc",
            "Weis Markets Inc.",
            "Wellpoint Health Networks Inc",
            "Wells Fargo & Company",
            "Wendy's International Inc",
            "Werner Enterprises Inc",
            "WESCO International Inc",
            "Western Digital Inc",
            "Western Gas Resources Inc",
            "WestPoint Stevens Inc",
            "Weyerhauser Company",
            "WGL Holdings Inc",
            "Whirlpool Corporation",
            "Whole Foods Market Inc",
            "Willamette Industries Inc.",
            "Williams Companies Inc",
            "Williams Sonoma Inc",
            "Winn Dixie Stores Inc",
            "Wisconsin Energy Corporation",
            "Wm Wrigley Jr Company",
            "World Fuel Services Corporation",
            "WorldCom Inc",
            "Worthington Industries Inc",
            "WPS Resources Corporation",
            "Wyeth",
            "Wyndham International Inc",
            "Xcel Energy Inc",
            "Xerox Corp",
            "Xilinx Inc",
            "XO Communications Inc",
            "Yellow Corporation",
            "York International Corp",
            "Yum Brands Inc.",
            "Zale Corporation",
            "Zions Bancorporation"
          ],

            fileExtension : {
                "raster"    : ["bmp", "gif", "gpl", "ico", "jpeg", "psd", "png", "psp", "raw", "tiff"],
                "vector"    : ["3dv", "amf", "awg", "ai", "cgm", "cdr", "cmx", "dxf", "e2d", "egt", "eps", "fs", "odg", "svg", "xar"],
                "3d"        : ["3dmf", "3dm", "3mf", "3ds", "an8", "aoi", "blend", "cal3d", "cob", "ctm", "iob", "jas", "max", "mb", "mdx", "obj", "x", "x3d"],
                "document"  : ["doc", "docx", "dot", "html", "xml", "odt", "odm", "ott", "csv", "rtf", "tex", "xhtml", "xps"]
            },

            // Data taken from https://github.com/dmfilipenko/timezones.json/blob/master/timezones.json
            timezones: [
                      {
                        "name": "Dateline Standard Time",
                        "abbr": "DST",
                        "offset": -12,
                        "isdst": false,
                        "text": "(UTC-12:00) International Date Line West",
                        "utc": [
                          "Etc/GMT+12"
                        ]
                      },
                      {
                        "name": "UTC-11",
                        "abbr": "U",
                        "offset": -11,
                        "isdst": false,
                        "text": "(UTC-11:00) Coordinated Universal Time-11",
                        "utc": [
                          "Etc/GMT+11",
                          "Pacific/Midway",
                          "Pacific/Niue",
                          "Pacific/Pago_Pago"
                        ]
                      },
                      {
                        "name": "Hawaiian Standard Time",
                        "abbr": "HST",
                        "offset": -10,
                        "isdst": false,
                        "text": "(UTC-10:00) Hawaii",
                        "utc": [
                          "Etc/GMT+10",
                          "Pacific/Honolulu",
                          "Pacific/Johnston",
                          "Pacific/Rarotonga",
                          "Pacific/Tahiti"
                        ]
                      },
                      {
                        "name": "Alaskan Standard Time",
                        "abbr": "AKDT",
                        "offset": -8,
                        "isdst": true,
                        "text": "(UTC-09:00) Alaska",
                        "utc": [
                          "America/Anchorage",
                          "America/Juneau",
                          "America/Nome",
                          "America/Sitka",
                          "America/Yakutat"
                        ]
                      },
                      {
                        "name": "Pacific Standard Time (Mexico)",
                        "abbr": "PDT",
                        "offset": -7,
                        "isdst": true,
                        "text": "(UTC-08:00) Baja California",
                        "utc": [
                          "America/Santa_Isabel"
                        ]
                      },
                      {
                        "name": "Pacific Standard Time",
                        "abbr": "PDT",
                        "offset": -7,
                        "isdst": true,
                        "text": "(UTC-08:00) Pacific Time (US & Canada)",
                        "utc": [
                          "America/Dawson",
                          "America/Los_Angeles",
                          "America/Tijuana",
                          "America/Vancouver",
                          "America/Whitehorse",
                          "PST8PDT"
                        ]
                      },
                      {
                        "name": "US Mountain Standard Time",
                        "abbr": "UMST",
                        "offset": -7,
                        "isdst": false,
                        "text": "(UTC-07:00) Arizona",
                        "utc": [
                          "America/Creston",
                          "America/Dawson_Creek",
                          "America/Hermosillo",
                          "America/Phoenix",
                          "Etc/GMT+7"
                        ]
                      },
                      {
                        "name": "Mountain Standard Time (Mexico)",
                        "abbr": "MDT",
                        "offset": -6,
                        "isdst": true,
                        "text": "(UTC-07:00) Chihuahua, La Paz, Mazatlan",
                        "utc": [
                          "America/Chihuahua",
                          "America/Mazatlan"
                        ]
                      },
                      {
                        "name": "Mountain Standard Time",
                        "abbr": "MDT",
                        "offset": -6,
                        "isdst": true,
                        "text": "(UTC-07:00) Mountain Time (US & Canada)",
                        "utc": [
                          "America/Boise",
                          "America/Cambridge_Bay",
                          "America/Denver",
                          "America/Edmonton",
                          "America/Inuvik",
                          "America/Ojinaga",
                          "America/Yellowknife",
                          "MST7MDT"
                        ]
                      },
                      {
                        "name": "Central America Standard Time",
                        "abbr": "CAST",
                        "offset": -6,
                        "isdst": false,
                        "text": "(UTC-06:00) Central America",
                        "utc": [
                          "America/Belize",
                          "America/Costa_Rica",
                          "America/El_Salvador",
                          "America/Guatemala",
                          "America/Managua",
                          "America/Tegucigalpa",
                          "Etc/GMT+6",
                          "Pacific/Galapagos"
                        ]
                      },
                      {
                        "name": "Central Standard Time",
                        "abbr": "CDT",
                        "offset": -5,
                        "isdst": true,
                        "text": "(UTC-06:00) Central Time (US & Canada)",
                        "utc": [
                          "America/Chicago",
                          "America/Indiana/Knox",
                          "America/Indiana/Tell_City",
                          "America/Matamoros",
                          "America/Menominee",
                          "America/North_Dakota/Beulah",
                          "America/North_Dakota/Center",
                          "America/North_Dakota/New_Salem",
                          "America/Rainy_River",
                          "America/Rankin_Inlet",
                          "America/Resolute",
                          "America/Winnipeg",
                          "CST6CDT"
                        ]
                      },
                      {
                        "name": "Central Standard Time (Mexico)",
                        "abbr": "CDT",
                        "offset": -5,
                        "isdst": true,
                        "text": "(UTC-06:00) Guadalajara, Mexico City, Monterrey",
                        "utc": [
                          "America/Bahia_Banderas",
                          "America/Cancun",
                          "America/Merida",
                          "America/Mexico_City",
                          "America/Monterrey"
                        ]
                      },
                      {
                        "name": "Canada Central Standard Time",
                        "abbr": "CCST",
                        "offset": -6,
                        "isdst": false,
                        "text": "(UTC-06:00) Saskatchewan",
                        "utc": [
                          "America/Regina",
                          "America/Swift_Current"
                        ]
                      },
                      {
                        "name": "SA Pacific Standard Time",
                        "abbr": "SPST",
                        "offset": -5,
                        "isdst": false,
                        "text": "(UTC-05:00) Bogota, Lima, Quito",
                        "utc": [
                          "America/Bogota",
                          "America/Cayman",
                          "America/Coral_Harbour",
                          "America/Eirunepe",
                          "America/Guayaquil",
                          "America/Jamaica",
                          "America/Lima",
                          "America/Panama",
                          "America/Rio_Branco",
                          "Etc/GMT+5"
                        ]
                      },
                      {
                        "name": "Eastern Standard Time",
                        "abbr": "EDT",
                        "offset": -4,
                        "isdst": true,
                        "text": "(UTC-05:00) Eastern Time (US & Canada)",
                        "utc": [
                          "America/Detroit",
                          "America/Havana",
                          "America/Indiana/Petersburg",
                          "America/Indiana/Vincennes",
                          "America/Indiana/Winamac",
                          "America/Iqaluit",
                          "America/Kentucky/Monticello",
                          "America/Louisville",
                          "America/Montreal",
                          "America/Nassau",
                          "America/New_York",
                          "America/Nipigon",
                          "America/Pangnirtung",
                          "America/Port-au-Prince",
                          "America/Thunder_Bay",
                          "America/Toronto",
                          "EST5EDT"
                        ]
                      },
                      {
                        "name": "US Eastern Standard Time",
                        "abbr": "UEDT",
                        "offset": -4,
                        "isdst": true,
                        "text": "(UTC-05:00) Indiana (East)",
                        "utc": [
                          "America/Indiana/Marengo",
                          "America/Indiana/Vevay",
                          "America/Indianapolis"
                        ]
                      },
                      {
                        "name": "Venezuela Standard Time",
                        "abbr": "VST",
                        "offset": -4.5,
                        "isdst": false,
                        "text": "(UTC-04:30) Caracas",
                        "utc": [
                          "America/Caracas"
                        ]
                      },
                      {
                        "name": "Paraguay Standard Time",
                        "abbr": "PST",
                        "offset": -4,
                        "isdst": false,
                        "text": "(UTC-04:00) Asuncion",
                        "utc": [
                          "America/Asuncion"
                        ]
                      },
                      {
                        "name": "Atlantic Standard Time",
                        "abbr": "ADT",
                        "offset": -3,
                        "isdst": true,
                        "text": "(UTC-04:00) Atlantic Time (Canada)",
                        "utc": [
                          "America/Glace_Bay",
                          "America/Goose_Bay",
                          "America/Halifax",
                          "America/Moncton",
                          "America/Thule",
                          "Atlantic/Bermuda"
                        ]
                      },
                      {
                        "name": "Central Brazilian Standard Time",
                        "abbr": "CBST",
                        "offset": -4,
                        "isdst": false,
                        "text": "(UTC-04:00) Cuiaba",
                        "utc": [
                          "America/Campo_Grande",
                          "America/Cuiaba"
                        ]
                      },
                      {
                        "name": "SA Western Standard Time",
                        "abbr": "SWST",
                        "offset": -4,
                        "isdst": false,
                        "text": "(UTC-04:00) Georgetown, La Paz, Manaus, San Juan",
                        "utc": [
                          "America/Anguilla",
                          "America/Antigua",
                          "America/Aruba",
                          "America/Barbados",
                          "America/Blanc-Sablon",
                          "America/Boa_Vista",
                          "America/Curacao",
                          "America/Dominica",
                          "America/Grand_Turk",
                          "America/Grenada",
                          "America/Guadeloupe",
                          "America/Guyana",
                          "America/Kralendijk",
                          "America/La_Paz",
                          "America/Lower_Princes",
                          "America/Manaus",
                          "America/Marigot",
                          "America/Martinique",
                          "America/Montserrat",
                          "America/Port_of_Spain",
                          "America/Porto_Velho",
                          "America/Puerto_Rico",
                          "America/Santo_Domingo",
                          "America/St_Barthelemy",
                          "America/St_Kitts",
                          "America/St_Lucia",
                          "America/St_Thomas",
                          "America/St_Vincent",
                          "America/Tortola",
                          "Etc/GMT+4"
                        ]
                      },
                      {
                        "name": "Pacific SA Standard Time",
                        "abbr": "PSST",
                        "offset": -4,
                        "isdst": false,
                        "text": "(UTC-04:00) Santiago",
                        "utc": [
                          "America/Santiago",
                          "Antarctica/Palmer"
                        ]
                      },
                      {
                        "name": "Newfoundland Standard Time",
                        "abbr": "NDT",
                        "offset": -2.5,
                        "isdst": true,
                        "text": "(UTC-03:30) Newfoundland",
                        "utc": [
                          "America/St_Johns"
                        ]
                      },
                      {
                        "name": "E. South America Standard Time",
                        "abbr": "ESAST",
                        "offset": -3,
                        "isdst": false,
                        "text": "(UTC-03:00) Brasilia",
                        "utc": [
                          "America/Sao_Paulo"
                        ]
                      },
                      {
                        "name": "Argentina Standard Time",
                        "abbr": "AST",
                        "offset": -3,
                        "isdst": false,
                        "text": "(UTC-03:00) Buenos Aires",
                        "utc": [
                          "America/Argentina/La_Rioja",
                          "America/Argentina/Rio_Gallegos",
                          "America/Argentina/Salta",
                          "America/Argentina/San_Juan",
                          "America/Argentina/San_Luis",
                          "America/Argentina/Tucuman",
                          "America/Argentina/Ushuaia",
                          "America/Buenos_Aires",
                          "America/Catamarca",
                          "America/Cordoba",
                          "America/Jujuy",
                          "America/Mendoza"
                        ]
                      },
                      {
                        "name": "SA Eastern Standard Time",
                        "abbr": "SEST",
                        "offset": -3,
                        "isdst": false,
                        "text": "(UTC-03:00) Cayenne, Fortaleza",
                        "utc": [
                          "America/Araguaina",
                          "America/Belem",
                          "America/Cayenne",
                          "America/Fortaleza",
                          "America/Maceio",
                          "America/Paramaribo",
                          "America/Recife",
                          "America/Santarem",
                          "Antarctica/Rothera",
                          "Atlantic/Stanley",
                          "Etc/GMT+3"
                        ]
                      },
                      {
                        "name": "Greenland Standard Time",
                        "abbr": "GDT",
                        "offset": -2,
                        "isdst": true,
                        "text": "(UTC-03:00) Greenland",
                        "utc": [
                          "America/Godthab"
                        ]
                      },
                      {
                        "name": "Montevideo Standard Time",
                        "abbr": "MST",
                        "offset": -3,
                        "isdst": false,
                        "text": "(UTC-03:00) Montevideo",
                        "utc": [
                          "America/Montevideo"
                        ]
                      },
                      {
                        "name": "Bahia Standard Time",
                        "abbr": "BST",
                        "offset": -3,
                        "isdst": false,
                        "text": "(UTC-03:00) Salvador",
                        "utc": [
                          "America/Bahia"
                        ]
                      },
                      {
                        "name": "UTC-02",
                        "abbr": "U",
                        "offset": -2,
                        "isdst": false,
                        "text": "(UTC-02:00) Coordinated Universal Time-02",
                        "utc": [
                          "America/Noronha",
                          "Atlantic/South_Georgia",
                          "Etc/GMT+2"
                        ]
                      },
                      {
                        "name": "Mid-Atlantic Standard Time",
                        "abbr": "MDT",
                        "offset": -1,
                        "isdst": true,
                        "text": "(UTC-02:00) Mid-Atlantic - Old"
                      },
                      {
                        "name": "Azores Standard Time",
                        "abbr": "ADT",
                        "offset": 0,
                        "isdst": true,
                        "text": "(UTC-01:00) Azores",
                        "utc": [
                          "America/Scoresbysund",
                          "Atlantic/Azores"
                        ]
                      },
                      {
                        "name": "Cape Verde Standard Time",
                        "abbr": "CVST",
                        "offset": -1,
                        "isdst": false,
                        "text": "(UTC-01:00) Cape Verde Is.",
                        "utc": [
                          "Atlantic/Cape_Verde",
                          "Etc/GMT+1"
                        ]
                      },
                      {
                        "name": "Morocco Standard Time",
                        "abbr": "MDT",
                        "offset": 1,
                        "isdst": true,
                        "text": "(UTC) Casablanca",
                        "utc": [
                          "Africa/Casablanca",
                          "Africa/El_Aaiun"
                        ]
                      },
                      {
                        "name": "UTC",
                        "abbr": "CUT",
                        "offset": 0,
                        "isdst": false,
                        "text": "(UTC) Coordinated Universal Time",
                        "utc": [
                          "America/Danmarkshavn",
                          "Etc/GMT"
                        ]
                      },
                      {
                        "name": "GMT Standard Time",
                        "abbr": "GDT",
                        "offset": 1,
                        "isdst": true,
                        "text": "(UTC) Dublin, Edinburgh, Lisbon, London",
                        "utc": [
                          "Atlantic/Canary",
                          "Atlantic/Faeroe",
                          "Atlantic/Madeira",
                          "Europe/Dublin",
                          "Europe/Guernsey",
                          "Europe/Isle_of_Man",
                          "Europe/Jersey",
                          "Europe/Lisbon",
                          "Europe/London"
                        ]
                      },
                      {
                        "name": "Greenwich Standard Time",
                        "abbr": "GST",
                        "offset": 0,
                        "isdst": false,
                        "text": "(UTC) Monrovia, Reykjavik",
                        "utc": [
                          "Africa/Abidjan",
                          "Africa/Accra",
                          "Africa/Bamako",
                          "Africa/Banjul",
                          "Africa/Bissau",
                          "Africa/Conakry",
                          "Africa/Dakar",
                          "Africa/Freetown",
                          "Africa/Lome",
                          "Africa/Monrovia",
                          "Africa/Nouakchott",
                          "Africa/Ouagadougou",
                          "Africa/Sao_Tome",
                          "Atlantic/Reykjavik",
                          "Atlantic/St_Helena"
                        ]
                      },
                      {
                        "name": "W. Europe Standard Time",
                        "abbr": "WEDT",
                        "offset": 2,
                        "isdst": true,
                        "text": "(UTC+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna",
                        "utc": [
                          "Arctic/Longyearbyen",
                          "Europe/Amsterdam",
                          "Europe/Andorra",
                          "Europe/Berlin",
                          "Europe/Busingen",
                          "Europe/Gibraltar",
                          "Europe/Luxembourg",
                          "Europe/Malta",
                          "Europe/Monaco",
                          "Europe/Oslo",
                          "Europe/Rome",
                          "Europe/San_Marino",
                          "Europe/Stockholm",
                          "Europe/Vaduz",
                          "Europe/Vatican",
                          "Europe/Vienna",
                          "Europe/Zurich"
                        ]
                      },
                      {
                        "name": "Central Europe Standard Time",
                        "abbr": "CEDT",
                        "offset": 2,
                        "isdst": true,
                        "text": "(UTC+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague",
                        "utc": [
                          "Europe/Belgrade",
                          "Europe/Bratislava",
                          "Europe/Budapest",
                          "Europe/Ljubljana",
                          "Europe/Podgorica",
                          "Europe/Prague",
                          "Europe/Tirane"
                        ]
                      },
                      {
                        "name": "Romance Standard Time",
                        "abbr": "RDT",
                        "offset": 2,
                        "isdst": true,
                        "text": "(UTC+01:00) Brussels, Copenhagen, Madrid, Paris",
                        "utc": [
                          "Africa/Ceuta",
                          "Europe/Brussels",
                          "Europe/Copenhagen",
                          "Europe/Madrid",
                          "Europe/Paris"
                        ]
                      },
                      {
                        "name": "Central European Standard Time",
                        "abbr": "CEDT",
                        "offset": 2,
                        "isdst": true,
                        "text": "(UTC+01:00) Sarajevo, Skopje, Warsaw, Zagreb",
                        "utc": [
                          "Europe/Sarajevo",
                          "Europe/Skopje",
                          "Europe/Warsaw",
                          "Europe/Zagreb"
                        ]
                      },
                      {
                        "name": "W. Central Africa Standard Time",
                        "abbr": "WCAST",
                        "offset": 1,
                        "isdst": false,
                        "text": "(UTC+01:00) West Central Africa",
                        "utc": [
                          "Africa/Algiers",
                          "Africa/Bangui",
                          "Africa/Brazzaville",
                          "Africa/Douala",
                          "Africa/Kinshasa",
                          "Africa/Lagos",
                          "Africa/Libreville",
                          "Africa/Luanda",
                          "Africa/Malabo",
                          "Africa/Ndjamena",
                          "Africa/Niamey",
                          "Africa/Porto-Novo",
                          "Africa/Tunis",
                          "Etc/GMT-1"
                        ]
                      },
                      {
                        "name": "Namibia Standard Time",
                        "abbr": "NST",
                        "offset": 1,
                        "isdst": false,
                        "text": "(UTC+01:00) Windhoek",
                        "utc": [
                          "Africa/Windhoek"
                        ]
                      },
                      {
                        "name": "GTB Standard Time",
                        "abbr": "GDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Athens, Bucharest",
                        "utc": [
                          "Asia/Nicosia",
                          "Europe/Athens",
                          "Europe/Bucharest",
                          "Europe/Chisinau"
                        ]
                      },
                      {
                        "name": "Middle East Standard Time",
                        "abbr": "MEDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Beirut",
                        "utc": [
                          "Asia/Beirut"
                        ]
                      },
                      {
                        "name": "Egypt Standard Time",
                        "abbr": "EST",
                        "offset": 2,
                        "isdst": false,
                        "text": "(UTC+02:00) Cairo",
                        "utc": [
                          "Africa/Cairo"
                        ]
                      },
                      {
                        "name": "Syria Standard Time",
                        "abbr": "SDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Damascus",
                        "utc": [
                          "Asia/Damascus"
                        ]
                      },
                      {
                        "name": "E. Europe Standard Time",
                        "abbr": "EEDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) E. Europe"
                      },
                      {
                        "name": "South Africa Standard Time",
                        "abbr": "SAST",
                        "offset": 2,
                        "isdst": false,
                        "text": "(UTC+02:00) Harare, Pretoria",
                        "utc": [
                          "Africa/Blantyre",
                          "Africa/Bujumbura",
                          "Africa/Gaborone",
                          "Africa/Harare",
                          "Africa/Johannesburg",
                          "Africa/Kigali",
                          "Africa/Lubumbashi",
                          "Africa/Lusaka",
                          "Africa/Maputo",
                          "Africa/Maseru",
                          "Africa/Mbabane",
                          "Etc/GMT-2"
                        ]
                      },
                      {
                        "name": "FLE Standard Time",
                        "abbr": "FDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius",
                        "utc": [
                          "Europe/Helsinki",
                          "Europe/Kiev",
                          "Europe/Mariehamn",
                          "Europe/Riga",
                          "Europe/Sofia",
                          "Europe/Tallinn",
                          "Europe/Uzhgorod",
                          "Europe/Vilnius",
                          "Europe/Zaporozhye"
                        ]
                      },
                      {
                        "name": "Turkey Standard Time",
                        "abbr": "TDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Istanbul",
                        "utc": [
                          "Europe/Istanbul"
                        ]
                      },
                      {
                        "name": "Israel Standard Time",
                        "abbr": "JDT",
                        "offset": 3,
                        "isdst": true,
                        "text": "(UTC+02:00) Jerusalem",
                        "utc": [
                          "Asia/Jerusalem"
                        ]
                      },
                      {
                        "name": "Libya Standard Time",
                        "abbr": "LST",
                        "offset": 2,
                        "isdst": false,
                        "text": "(UTC+02:00) Tripoli",
                        "utc": [
                          "Africa/Tripoli"
                        ]
                      },
                      {
                        "name": "Jordan Standard Time",
                        "abbr": "JST",
                        "offset": 3,
                        "isdst": false,
                        "text": "(UTC+03:00) Amman",
                        "utc": [
                          "Asia/Amman"
                        ]
                      },
                      {
                        "name": "Arabic Standard Time",
                        "abbr": "AST",
                        "offset": 3,
                        "isdst": false,
                        "text": "(UTC+03:00) Baghdad",
                        "utc": [
                          "Asia/Baghdad"
                        ]
                      },
                      {
                        "name": "Kaliningrad Standard Time",
                        "abbr": "KST",
                        "offset": 3,
                        "isdst": false,
                        "text": "(UTC+03:00) Kaliningrad, Minsk",
                        "utc": [
                          "Europe/Kaliningrad",
                          "Europe/Minsk"
                        ]
                      },
                      {
                        "name": "Arab Standard Time",
                        "abbr": "AST",
                        "offset": 3,
                        "isdst": false,
                        "text": "(UTC+03:00) Kuwait, Riyadh",
                        "utc": [
                          "Asia/Aden",
                          "Asia/Bahrain",
                          "Asia/Kuwait",
                          "Asia/Qatar",
                          "Asia/Riyadh"
                        ]
                      },
                      {
                        "name": "E. Africa Standard Time",
                        "abbr": "EAST",
                        "offset": 3,
                        "isdst": false,
                        "text": "(UTC+03:00) Nairobi",
                        "utc": [
                          "Africa/Addis_Ababa",
                          "Africa/Asmera",
                          "Africa/Dar_es_Salaam",
                          "Africa/Djibouti",
                          "Africa/Juba",
                          "Africa/Kampala",
                          "Africa/Khartoum",
                          "Africa/Mogadishu",
                          "Africa/Nairobi",
                          "Antarctica/Syowa",
                          "Etc/GMT-3",
                          "Indian/Antananarivo",
                          "Indian/Comoro",
                          "Indian/Mayotte"
                        ]
                      },
                      {
                        "name": "Iran Standard Time",
                        "abbr": "IDT",
                        "offset": 4.5,
                        "isdst": true,
                        "text": "(UTC+03:30) Tehran",
                        "utc": [
                          "Asia/Tehran"
                        ]
                      },
                      {
                        "name": "Arabian Standard Time",
                        "abbr": "AST",
                        "offset": 4,
                        "isdst": false,
                        "text": "(UTC+04:00) Abu Dhabi, Muscat",
                        "utc": [
                          "Asia/Dubai",
                          "Asia/Muscat",
                          "Etc/GMT-4"
                        ]
                      },
                      {
                        "name": "Azerbaijan Standard Time",
                        "abbr": "ADT",
                        "offset": 5,
                        "isdst": true,
                        "text": "(UTC+04:00) Baku",
                        "utc": [
                          "Asia/Baku"
                        ]
                      },
                      {
                        "name": "Russian Standard Time",
                        "abbr": "RST",
                        "offset": 4,
                        "isdst": false,
                        "text": "(UTC+04:00) Moscow, St. Petersburg, Volgograd",
                        "utc": [
                          "Europe/Moscow",
                          "Europe/Samara",
                          "Europe/Simferopol",
                          "Europe/Volgograd"
                        ]
                      },
                      {
                        "name": "Mauritius Standard Time",
                        "abbr": "MST",
                        "offset": 4,
                        "isdst": false,
                        "text": "(UTC+04:00) Port Louis",
                        "utc": [
                          "Indian/Mahe",
                          "Indian/Mauritius",
                          "Indian/Reunion"
                        ]
                      },
                      {
                        "name": "Georgian Standard Time",
                        "abbr": "GST",
                        "offset": 4,
                        "isdst": false,
                        "text": "(UTC+04:00) Tbilisi",
                        "utc": [
                          "Asia/Tbilisi"
                        ]
                      },
                      {
                        "name": "Caucasus Standard Time",
                        "abbr": "CST",
                        "offset": 4,
                        "isdst": false,
                        "text": "(UTC+04:00) Yerevan",
                        "utc": [
                          "Asia/Yerevan"
                        ]
                      },
                      {
                        "name": "Afghanistan Standard Time",
                        "abbr": "AST",
                        "offset": 4.5,
                        "isdst": false,
                        "text": "(UTC+04:30) Kabul",
                        "utc": [
                          "Asia/Kabul"
                        ]
                      },
                      {
                        "name": "West Asia Standard Time",
                        "abbr": "WAST",
                        "offset": 5,
                        "isdst": false,
                        "text": "(UTC+05:00) Ashgabat, Tashkent",
                        "utc": [
                          "Antarctica/Mawson",
                          "Asia/Aqtau",
                          "Asia/Aqtobe",
                          "Asia/Ashgabat",
                          "Asia/Dushanbe",
                          "Asia/Oral",
                          "Asia/Samarkand",
                          "Asia/Tashkent",
                          "Etc/GMT-5",
                          "Indian/Kerguelen",
                          "Indian/Maldives"
                        ]
                      },
                      {
                        "name": "Pakistan Standard Time",
                        "abbr": "PST",
                        "offset": 5,
                        "isdst": false,
                        "text": "(UTC+05:00) Islamabad, Karachi",
                        "utc": [
                          "Asia/Karachi"
                        ]
                      },
                      {
                        "name": "India Standard Time",
                        "abbr": "IST",
                        "offset": 5.5,
                        "isdst": false,
                        "text": "(UTC+05:30) Chennai, Kolkata, Mumbai, New Delhi",
                        "utc": [
                          "Asia/Calcutta"
                        ]
                      },
                      {
                        "name": "Sri Lanka Standard Time",
                        "abbr": "SLST",
                        "offset": 5.5,
                        "isdst": false,
                        "text": "(UTC+05:30) Sri Jayawardenepura",
                        "utc": [
                          "Asia/Colombo"
                        ]
                      },
                      {
                        "name": "Nepal Standard Time",
                        "abbr": "NST",
                        "offset": 5.75,
                        "isdst": false,
                        "text": "(UTC+05:45) Kathmandu",
                        "utc": [
                          "Asia/Katmandu"
                        ]
                      },
                      {
                        "name": "Central Asia Standard Time",
                        "abbr": "CAST",
                        "offset": 6,
                        "isdst": false,
                        "text": "(UTC+06:00) Astana",
                        "utc": [
                          "Antarctica/Vostok",
                          "Asia/Almaty",
                          "Asia/Bishkek",
                          "Asia/Qyzylorda",
                          "Asia/Urumqi",
                          "Etc/GMT-6",
                          "Indian/Chagos"
                        ]
                      },
                      {
                        "name": "Bangladesh Standard Time",
                        "abbr": "BST",
                        "offset": 6,
                        "isdst": false,
                        "text": "(UTC+06:00) Dhaka",
                        "utc": [
                          "Asia/Dhaka",
                          "Asia/Thimphu"
                        ]
                      },
                      {
                        "name": "Ekaterinburg Standard Time",
                        "abbr": "EST",
                        "offset": 6,
                        "isdst": false,
                        "text": "(UTC+06:00) Ekaterinburg",
                        "utc": [
                          "Asia/Yekaterinburg"
                        ]
                      },
                      {
                        "name": "Myanmar Standard Time",
                        "abbr": "MST",
                        "offset": 6.5,
                        "isdst": false,
                        "text": "(UTC+06:30) Yangon (Rangoon)",
                        "utc": [
                          "Asia/Rangoon",
                          "Indian/Cocos"
                        ]
                      },
                      {
                        "name": "SE Asia Standard Time",
                        "abbr": "SAST",
                        "offset": 7,
                        "isdst": false,
                        "text": "(UTC+07:00) Bangkok, Hanoi, Jakarta",
                        "utc": [
                          "Antarctica/Davis",
                          "Asia/Bangkok",
                          "Asia/Hovd",
                          "Asia/Jakarta",
                          "Asia/Phnom_Penh",
                          "Asia/Pontianak",
                          "Asia/Saigon",
                          "Asia/Vientiane",
                          "Etc/GMT-7",
                          "Indian/Christmas"
                        ]
                      },
                      {
                        "name": "N. Central Asia Standard Time",
                        "abbr": "NCAST",
                        "offset": 7,
                        "isdst": false,
                        "text": "(UTC+07:00) Novosibirsk",
                        "utc": [
                          "Asia/Novokuznetsk",
                          "Asia/Novosibirsk",
                          "Asia/Omsk"
                        ]
                      },
                      {
                        "name": "China Standard Time",
                        "abbr": "CST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Beijing, Chongqing, Hong Kong, Urumqi",
                        "utc": [
                          "Asia/Hong_Kong",
                          "Asia/Macau",
                          "Asia/Shanghai"
                        ]
                      },
                      {
                        "name": "North Asia Standard Time",
                        "abbr": "NAST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Krasnoyarsk",
                        "utc": [
                          "Asia/Krasnoyarsk"
                        ]
                      },
                      {
                        "name": "Singapore Standard Time",
                        "abbr": "MPST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Kuala Lumpur, Singapore",
                        "utc": [
                          "Asia/Brunei",
                          "Asia/Kuala_Lumpur",
                          "Asia/Kuching",
                          "Asia/Makassar",
                          "Asia/Manila",
                          "Asia/Singapore",
                          "Etc/GMT-8"
                        ]
                      },
                      {
                        "name": "W. Australia Standard Time",
                        "abbr": "WAST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Perth",
                        "utc": [
                          "Antarctica/Casey",
                          "Australia/Perth"
                        ]
                      },
                      {
                        "name": "Taipei Standard Time",
                        "abbr": "TST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Taipei",
                        "utc": [
                          "Asia/Taipei"
                        ]
                      },
                      {
                        "name": "Ulaanbaatar Standard Time",
                        "abbr": "UST",
                        "offset": 8,
                        "isdst": false,
                        "text": "(UTC+08:00) Ulaanbaatar",
                        "utc": [
                          "Asia/Choibalsan",
                          "Asia/Ulaanbaatar"
                        ]
                      },
                      {
                        "name": "North Asia East Standard Time",
                        "abbr": "NAEST",
                        "offset": 9,
                        "isdst": false,
                        "text": "(UTC+09:00) Irkutsk",
                        "utc": [
                          "Asia/Irkutsk"
                        ]
                      },
                      {
                        "name": "Tokyo Standard Time",
                        "abbr": "TST",
                        "offset": 9,
                        "isdst": false,
                        "text": "(UTC+09:00) Osaka, Sapporo, Tokyo",
                        "utc": [
                          "Asia/Dili",
                          "Asia/Jayapura",
                          "Asia/Tokyo",
                          "Etc/GMT-9",
                          "Pacific/Palau"
                        ]
                      },
                      {
                        "name": "Korea Standard Time",
                        "abbr": "KST",
                        "offset": 9,
                        "isdst": false,
                        "text": "(UTC+09:00) Seoul",
                        "utc": [
                          "Asia/Pyongyang",
                          "Asia/Seoul"
                        ]
                      },
                      {
                        "name": "Cen. Australia Standard Time",
                        "abbr": "CAST",
                        "offset": 9.5,
                        "isdst": false,
                        "text": "(UTC+09:30) Adelaide",
                        "utc": [
                          "Australia/Adelaide",
                          "Australia/Broken_Hill"
                        ]
                      },
                      {
                        "name": "AUS Central Standard Time",
                        "abbr": "ACST",
                        "offset": 9.5,
                        "isdst": false,
                        "text": "(UTC+09:30) Darwin",
                        "utc": [
                          "Australia/Darwin"
                        ]
                      },
                      {
                        "name": "E. Australia Standard Time",
                        "abbr": "EAST",
                        "offset": 10,
                        "isdst": false,
                        "text": "(UTC+10:00) Brisbane",
                        "utc": [
                          "Australia/Brisbane",
                          "Australia/Lindeman"
                        ]
                      },
                      {
                        "name": "AUS Eastern Standard Time",
                        "abbr": "AEST",
                        "offset": 10,
                        "isdst": false,
                        "text": "(UTC+10:00) Canberra, Melbourne, Sydney",
                        "utc": [
                          "Australia/Melbourne",
                          "Australia/Sydney"
                        ]
                      },
                      {
                        "name": "West Pacific Standard Time",
                        "abbr": "WPST",
                        "offset": 10,
                        "isdst": false,
                        "text": "(UTC+10:00) Guam, Port Moresby",
                        "utc": [
                          "Antarctica/DumontDUrville",
                          "Etc/GMT-10",
                          "Pacific/Guam",
                          "Pacific/Port_Moresby",
                          "Pacific/Saipan",
                          "Pacific/Truk"
                        ]
                      },
                      {
                        "name": "Tasmania Standard Time",
                        "abbr": "TST",
                        "offset": 10,
                        "isdst": false,
                        "text": "(UTC+10:00) Hobart",
                        "utc": [
                          "Australia/Currie",
                          "Australia/Hobart"
                        ]
                      },
                      {
                        "name": "Yakutsk Standard Time",
                        "abbr": "YST",
                        "offset": 10,
                        "isdst": false,
                        "text": "(UTC+10:00) Yakutsk",
                        "utc": [
                          "Asia/Chita",
                          "Asia/Khandyga",
                          "Asia/Yakutsk"
                        ]
                      },
                      {
                        "name": "Central Pacific Standard Time",
                        "abbr": "CPST",
                        "offset": 11,
                        "isdst": false,
                        "text": "(UTC+11:00) Solomon Is., New Caledonia",
                        "utc": [
                          "Antarctica/Macquarie",
                          "Etc/GMT-11",
                          "Pacific/Efate",
                          "Pacific/Guadalcanal",
                          "Pacific/Kosrae",
                          "Pacific/Noumea",
                          "Pacific/Ponape"
                        ]
                      },
                      {
                        "name": "Vladivostok Standard Time",
                        "abbr": "VST",
                        "offset": 11,
                        "isdst": false,
                        "text": "(UTC+11:00) Vladivostok",
                        "utc": [
                          "Asia/Sakhalin",
                          "Asia/Ust-Nera",
                          "Asia/Vladivostok"
                        ]
                      },
                      {
                        "name": "New Zealand Standard Time",
                        "abbr": "NZST",
                        "offset": 12,
                        "isdst": false,
                        "text": "(UTC+12:00) Auckland, Wellington",
                        "utc": [
                          "Antarctica/McMurdo",
                          "Pacific/Auckland"
                        ]
                      },
                      {
                        "name": "UTC+12",
                        "abbr": "U",
                        "offset": 12,
                        "isdst": false,
                        "text": "(UTC+12:00) Coordinated Universal Time+12",
                        "utc": [
                          "Etc/GMT-12",
                          "Pacific/Funafuti",
                          "Pacific/Kwajalein",
                          "Pacific/Majuro",
                          "Pacific/Nauru",
                          "Pacific/Tarawa",
                          "Pacific/Wake",
                          "Pacific/Wallis"
                        ]
                      },
                      {
                        "name": "Fiji Standard Time",
                        "abbr": "FST",
                        "offset": 12,
                        "isdst": false,
                        "text": "(UTC+12:00) Fiji",
                        "utc": [
                          "Pacific/Fiji"
                        ]
                      },
                      {
                        "name": "Magadan Standard Time",
                        "abbr": "MST",
                        "offset": 12,
                        "isdst": false,
                        "text": "(UTC+12:00) Magadan",
                        "utc": [
                          "Asia/Anadyr",
                          "Asia/Kamchatka",
                          "Asia/Magadan",
                          "Asia/Srednekolymsk"
                        ]
                      },
                      {
                        "name": "Kamchatka Standard Time",
                        "abbr": "KDT",
                        "offset": 13,
                        "isdst": true,
                        "text": "(UTC+12:00) Petropavlovsk-Kamchatsky - Old"
                      },
                      {
                        "name": "Tonga Standard Time",
                        "abbr": "TST",
                        "offset": 13,
                        "isdst": false,
                        "text": "(UTC+13:00) Nuku'alofa",
                        "utc": [
                          "Etc/GMT-13",
                          "Pacific/Enderbury",
                          "Pacific/Fakaofo",
                          "Pacific/Tongatapu"
                        ]
                      },
                      {
                        "name": "Samoa Standard Time",
                        "abbr": "SST",
                        "offset": 13,
                        "isdst": false,
                        "text": "(UTC+13:00) Samoa",
                        "utc": [
                          "Pacific/Apia"
                        ]
                      }
                    ],
            //List source: http://answers.google.com/answers/threadview/id/589312.html
            profession: [
                "Airline Pilot",
                "Academic Team",
                "Accountant",
                "Account Executive",
                "Actor",
                "Actuary",
                "Acquisition Analyst",
                "Administrative Asst.",
                "Administrative Analyst",
                "Administrator",
                "Advertising Director",
                "Aerospace Engineer",
                "Agent",
                "Agricultural Inspector",
                "Agricultural Scientist",
                "Air Traffic Controller",
                "Animal Trainer",
                "Anthropologist",
                "Appraiser",
                "Architect",
                "Art Director",
                "Artist",
                "Astronomer",
                "Athletic Coach",
                "Auditor",
                "Author",
                "Baker",
                "Banker",
                "Bankruptcy Attorney",
                "Benefits Manager",
                "Biologist",
                "Bio-feedback Specialist",
                "Biomedical Engineer",
                "Biotechnical Researcher",
                "Broadcaster",
                "Broker",
                "Building Manager",
                "Building Contractor",
                "Building Inspector",
                "Business Analyst",
                "Business Planner",
                "Business Manager",
                "Buyer",
                "Call Center Manager",
                "Career Counselor",
                "Cash Manager",
                "Ceramic Engineer",
                "Chief Executive Officer",
                "Chief Operation Officer",
                "Chef",
                "Chemical Engineer",
                "Chemist",
                "Child Care Manager",
                "Chief Medical Officer",
                "Chiropractor",
                "Cinematographer",
                "City Housing Manager",
                "City Manager",
                "Civil Engineer",
                "Claims Manager",
                "Clinical Research Assistant",
                "Collections Manager",
                "Compliance Manager",
                "Comptroller",
                "Computer Manager",
                "Commercial Artist",
                "Communications Affairs Director",
                "Communications Director",
                "Communications Engineer",
                "Compensation Analyst",
                "Computer Programmer",
                "Computer Ops. Manager",
                "Computer Engineer",
                "Computer Operator",
                "Computer Graphics Specialist",
                "Construction Engineer",
                "Construction Manager",
                "Consultant",
                "Consumer Relations Manager",
                "Contract Administrator",
                "Copyright Attorney",
                "Copywriter",
                "Corporate Planner",
                "Corrections Officer",
                "Cosmetologist",
                "Credit Analyst",
                "Cruise Director",
                "Chief Information Officer",
                "Chief Technology Officer",
                "Customer Service Manager",
                "Cryptologist",
                "Dancer",
                "Data Security Manager",
                "Database Manager",
                "Day Care Instructor",
                "Dentist",
                "Designer",
                "Design Engineer",
                "Desktop Publisher",
                "Developer",
                "Development Officer",
                "Diamond Merchant",
                "Dietitian",
                "Direct Marketer",
                "Director",
                "Distribution Manager",
                "Diversity Manager",
                "Economist",
                "EEO Compliance Manager",
                "Editor",
                "Education Adminator",
                "Electrical Engineer",
                "Electro Optical Engineer",
                "Electronics Engineer",
                "Embassy Management",
                "Employment Agent",
                "Engineer Technician",
                "Entrepreneur",
                "Environmental Analyst",
                "Environmental Attorney",
                "Environmental Engineer",
                "Environmental Specialist",
                "Escrow Officer",
                "Estimator",
                "Executive Assistant",
                "Executive Director",
                "Executive Recruiter",
                "Facilities Manager",
                "Family Counselor",
                "Fashion Events Manager",
                "Fashion Merchandiser",
                "Fast Food Manager",
                "Film Producer",
                "Film Production Assistant",
                "Financial Analyst",
                "Financial Planner",
                "Financier",
                "Fine Artist",
                "Wildlife Specialist",
                "Fitness Consultant",
                "Flight Attendant",
                "Flight Engineer",
                "Floral Designer",
                "Food & Beverage Director",
                "Food Service Manager",
                "Forestry Technician",
                "Franchise Management",
                "Franchise Sales",
                "Fraud Investigator",
                "Freelance Writer",
                "Fund Raiser",
                "General Manager",
                "Geologist",
                "General Counsel",
                "Geriatric Specialist",
                "Gerontologist",
                "Glamour Photographer",
                "Golf Club Manager",
                "Gourmet Chef",
                "Graphic Designer",
                "Grounds Keeper",
                "Hazardous Waste Manager",
                "Health Care Manager",
                "Health Therapist",
                "Health Service Administrator",
                "Hearing Officer",
                "Home Economist",
                "Horticulturist",
                "Hospital Administrator",
                "Hotel Manager",
                "Human Resources Manager",
                "Importer",
                "Industrial Designer",
                "Industrial Engineer",
                "Information Director",
                "Inside Sales",
                "Insurance Adjuster",
                "Interior Decorator",
                "Internal Controls Director",
                "International Acct.",
                "International Courier",
                "International Lawyer",
                "Interpreter",
                "Investigator",
                "Investment Banker",
                "Investment Manager",
                "IT Architect",
                "IT Project Manager",
                "IT Systems Analyst",
                "Jeweler",
                "Joint Venture Manager",
                "Journalist",
                "Labor Negotiator",
                "Labor Organizer",
                "Labor Relations Manager",
                "Lab Services Director",
                "Lab Technician",
                "Land Developer",
                "Landscape Architect",
                "Law Enforcement Officer",
                "Lawyer",
                "Lead Software Engineer",
                "Lead Software Test Engineer",
                "Leasing Manager",
                "Legal Secretary",
                "Library Manager",
                "Litigation Attorney",
                "Loan Officer",
                "Lobbyist",
                "Logistics Manager",
                "Maintenance Manager",
                "Management Consultant",
                "Managed Care Director",
                "Managing Partner",
                "Manufacturing Director",
                "Manpower Planner",
                "Marine Biologist",
                "Market Res. Analyst",
                "Marketing Director",
                "Materials Manager",
                "Mathematician",
                "Membership Chairman",
                "Mechanic",
                "Mechanical Engineer",
                "Media Buyer",
                "Medical Investor",
                "Medical Secretary",
                "Medical Technician",
                "Mental Health Counselor",
                "Merchandiser",
                "Metallurgical Engineering",
                "Meteorologist",
                "Microbiologist",
                "MIS Manager",
                "Motion Picture Director",
                "Multimedia Director",
                "Musician",
                "Network Administrator",
                "Network Specialist",
                "Network Operator",
                "New Product Manager",
                "Novelist",
                "Nuclear Engineer",
                "Nuclear Specialist",
                "Nutritionist",
                "Nursing Administrator",
                "Occupational Therapist",
                "Oceanographer",
                "Office Manager",
                "Operations Manager",
                "Operations Research Director",
                "Optical Technician",
                "Optometrist",
                "Organizational Development Manager",
                "Outplacement Specialist",
                "Paralegal",
                "Park Ranger",
                "Patent Attorney",
                "Payroll Specialist",
                "Personnel Specialist",
                "Petroleum Engineer",
                "Pharmacist",
                "Photographer",
                "Physical Therapist",
                "Physician",
                "Physician Assistant",
                "Physicist",
                "Planning Director",
                "Podiatrist",
                "Political Analyst",
                "Political Scientist",
                "Politician",
                "Portfolio Manager",
                "Preschool Management",
                "Preschool Teacher",
                "Principal",
                "Private Banker",
                "Private Investigator",
                "Probation Officer",
                "Process Engineer",
                "Producer",
                "Product Manager",
                "Product Engineer",
                "Production Engineer",
                "Production Planner",
                "Professional Athlete",
                "Professional Coach",
                "Professor",
                "Project Engineer",
                "Project Manager",
                "Program Manager",
                "Property Manager",
                "Public Administrator",
                "Public Safety Director",
                "PR Specialist",
                "Publisher",
                "Purchasing Agent",
                "Publishing Director",
                "Quality Assurance Specialist",
                "Quality Control Engineer",
                "Quality Control Inspector",
                "Radiology Manager",
                "Railroad Engineer",
                "Real Estate Broker",
                "Recreational Director",
                "Recruiter",
                "Redevelopment Specialist",
                "Regulatory Affairs Manager",
                "Registered Nurse",
                "Rehabilitation Counselor",
                "Relocation Manager",
                "Reporter",
                "Research Specialist",
                "Restaurant Manager",
                "Retail Store Manager",
                "Risk Analyst",
                "Safety Engineer",
                "Sales Engineer",
                "Sales Trainer",
                "Sales Promotion Manager",
                "Sales Representative",
                "Sales Manager",
                "Service Manager",
                "Sanitation Engineer",
                "Scientific Programmer",
                "Scientific Writer",
                "Securities Analyst",
                "Security Consultant",
                "Security Director",
                "Seminar Presenter",
                "Ship's Officer",
                "Singer",
                "Social Director",
                "Social Program Planner",
                "Social Research",
                "Social Scientist",
                "Social Worker",
                "Sociologist",
                "Software Developer",
                "Software Engineer",
                "Software Test Engineer",
                "Soil Scientist",
                "Special Events Manager",
                "Special Education Teacher",
                "Special Projects Director",
                "Speech Pathologist",
                "Speech Writer",
                "Sports Event Manager",
                "Statistician",
                "Store Manager",
                "Strategic Alliance Director",
                "Strategic Planning Director",
                "Stress Reduction Specialist",
                "Stockbroker",
                "Surveyor",
                "Structural Engineer",
                "Superintendent",
                "Supply Chain Director",
                "System Engineer",
                "Systems Analyst",
                "Systems Programmer",
                "System Administrator",
                "Tax Specialist",
                "Teacher",
                "Technical Support Specialist",
                "Technical Illustrator",
                "Technical Writer",
                "Technology Director",
                "Telecom Analyst",
                "Telemarketer",
                "Theatrical Director",
                "Title Examiner",
                "Tour Escort",
                "Tour Guide Director",
                "Traffic Manager",
                "Trainer Translator",
                "Transportation Manager",
                "Travel Agent",
                "Treasurer",
                "TV Programmer",
                "Underwriter",
                "Union Representative",
                "University Administrator",
                "University Dean",
                "Urban Planner",
                "Veterinarian",
                "Vendor Relations Director",
                "Viticulturist",
                "Warehouse Manager"
            ],
            animals : {
              //list of ocean animals comes from https://owlcation.com/stem/list-of-ocean-animals
              "ocean" : ["Acantharea","Anemone","Angelfish King","Ahi Tuna","Albacore","American Oyster","Anchovy","Armored Snail","Arctic Char","Atlantic Bluefin Tuna","Atlantic Cod","Atlantic Goliath Grouper","Atlantic Trumpetfish","Atlantic Wolffish","Baleen Whale","Banded Butterflyfish","Banded Coral Shrimp","Banded Sea Krait","Barnacle","Barndoor Skate","Barracuda","Basking Shark","Bass","Beluga Whale","Bluebanded Goby","Bluehead Wrasse","Bluefish","Bluestreak Cleaner-Wrasse","Blue Marlin","Blue Shark","Blue Spiny Lobster","Blue Tang","Blue Whale","Broadclub Cuttlefish","Bull Shark","Chambered Nautilus","Chilean Basket Star","Chilean Jack Mackerel","Chinook Salmon","Christmas Tree Worm","Clam","Clown Anemonefish","Clown Triggerfish","Cod","Coelacanth","Cockscomb Cup Coral","Common Fangtooth","Conch","Cookiecutter Shark","Copepod","Coral","Corydoras","Cownose Ray","Crab","Crown-of-Thorns Starfish","Cushion Star","Cuttlefish","California Sea Otters","Dolphin","Dolphinfish","Dory","Devil Fish","Dugong","Dumbo Octopus","Dungeness Crab","Eccentric Sand Dollar","Edible Sea Cucumber","Eel","Elephant Seal","Elkhorn Coral","Emperor Shrimp","Estuarine Crocodile","Fathead Sculpin","Fiddler Crab","Fin Whale","Flameback","Flamingo Tongue Snail","Flashlight Fish","Flatback Turtle","Flatfish","Flying Fish","Flounder","Fluke","French Angelfish","Frilled Shark","Fugu (also called Pufferfish)","Gar","Geoduck","Giant Barrel Sponge","Giant Caribbean Sea Anemone","Giant Clam","Giant Isopod","Giant Kingfish","Giant Oarfish","Giant Pacific Octopus","Giant Pyrosome","Giant Sea Star","Giant Squid","Glowing Sucker Octopus","Giant Tube Worm","Goblin Shark","Goosefish","Great White Shark","Greenland Shark","Grey Atlantic Seal","Grouper","Grunion","Guineafowl Puffer","Haddock","Hake","Halibut","Hammerhead Shark","Hapuka","Harbor Porpoise","Harbor Seal","Hatchetfish","Hawaiian Monk Seal","Hawksbill Turtle","Hector's Dolphin","Hermit Crab","Herring","Hoki","Horn Shark","Horseshoe Crab","Humpback Anglerfish","Humpback Whale","Icefish","Imperator Angelfish","Irukandji Jellyfish","Isopod","Ivory Bush Coral","Japanese Spider Crab","Jellyfish","John Dory","Juan Fernandez Fur Seal","Killer Whale","Kiwa Hirsuta","Krill","Lagoon Triggerfish","Lamprey","Leafy Seadragon","Leopard Seal","Limpet","Ling","Lionfish","Lions Mane Jellyfish","Lobe Coral","Lobster","Loggerhead Turtle","Longnose Sawshark","Longsnout Seahorse","Lophelia Coral","Marrus Orthocanna","Manatee","Manta Ray","Marlin","Megamouth Shark","Mexican Lookdown","Mimic Octopus","Moon Jelly","Mollusk","Monkfish","Moray Eel","Mullet","Mussel","Megaladon","Napoleon Wrasse","Nassau Grouper","Narwhal","Nautilus","Needlefish","Northern Seahorse","North Atlantic Right Whale","Northern Red Snapper","Norway Lobster","Nudibranch","Nurse Shark","Oarfish","Ocean Sunfish","Oceanic Whitetip Shark","Octopus","Olive Sea Snake","Orange Roughy","Ostracod","Otter","Oyster","Pacific Angelshark","Pacific Blackdragon","Pacific Halibut","Pacific Sardine","Pacific Sea Nettle Jellyfish","Pacific White Sided Dolphin","Pantropical Spotted Dolphin","Patagonian Toothfish","Peacock Mantis Shrimp","Pelagic Thresher Shark","Penguin","Peruvian Anchoveta","Pilchard","Pink Salmon","Pinniped","Plankton","Porpoise","Polar Bear","Portuguese Man o' War","Pycnogonid Sea Spider","Quahog","Queen Angelfish","Queen Conch","Queen Parrotfish","Queensland Grouper","Ragfish","Ratfish","Rattail Fish","Ray","Red Drum","Red King Crab","Ringed Seal","Risso's Dolphin","Ross Seals","Sablefish","Salmon","Sand Dollar","Sandbar Shark","Sawfish","Sarcastic Fringehead","Scalloped Hammerhead Shark","Seahorse","Sea Cucumber","Sea Lion","Sea Urchin","Seal","Shark","Shortfin Mako Shark","Shovelnose Guitarfish","Shrimp","Silverside Fish","Skipjack Tuna","Slender Snipe Eel","Smalltooth Sawfish","Smelts","Sockeye Salmon","Southern Stingray","Sponge","Spotted Porcupinefish","Spotted Dolphin","Spotted Eagle Ray","Spotted Moray","Squid","Squidworm","Starfish","Stickleback","Stonefish","Stoplight Loosejaw","Sturgeon","Swordfish","Tan Bristlemouth","Tasseled Wobbegong","Terrible Claw Lobster","Threespot Damselfish","Tiger Prawn","Tiger Shark","Tilefish","Toadfish","Tropical Two-Wing Flyfish","Tuna","Umbrella Squid","Velvet Crab","Venus Flytrap Sea Anemone","Vigtorniella Worm","Viperfish","Vampire Squid","Vaquita","Wahoo","Walrus","West Indian Manatee","Whale","Whale Shark","Whiptail Gulper","White-Beaked Dolphin","White-Ring Garden Eel","White Shrimp","Wobbegong","Wrasse","Wreckfish","Xiphosura","Yellowtail Damselfish","Yelloweye Rockfish","Yellow Cup Black Coral","Yellow Tube Sponge","Yellowfin Tuna","Zebrashark","Zooplankton"],
              //list of desert, grassland, and forest animals comes from http://www.skyenimals.com/
              "desert" : ["Aardwolf","Addax","African Wild Ass","Ant","Antelope","Armadillo","Baboon","Badger","Bat","Bearded Dragon","Beetle","Bird","Black-footed Cat","Boa","Brown Bear","Bustard","Butterfly","Camel","Caracal","Caracara","Caterpillar","Centipede","Cheetah","Chipmunk","Chuckwalla","Climbing Mouse","Coati","Cobra","Cotton Rat","Cougar","Courser","Crane Fly","Crow","Dassie Rat","Dove","Dunnart","Eagle","Echidna","Elephant","Emu","Falcon","Fly","Fox","Frogmouth","Gecko","Geoffroy's Cat","Gerbil","Grasshopper","Guanaco","Gundi","Hamster","Hawk","Hedgehog","Hyena","Hyrax","Jackal","Kangaroo","Kangaroo Rat","Kestrel","Kowari","Kultarr","Leopard","Lion","Macaw","Meerkat","Mouse","Oryx","Ostrich","Owl","Pronghorn","Python","Rabbit","Raccoon","Rattlesnake","Rhinoceros","Sand Cat","Spectacled Bear","Spiny Mouse","Starling","Stick Bug","Tarantula","Tit","Toad","Tortoise","Tyrant Flycatcher","Viper","Vulture","Waxwing","Xerus","Zebra"],
              "grassland" : ["Aardvark","Aardwolf","Accentor","African Buffalo","African Wild Dog","Alpaca","Anaconda","Ant","Anteater","Antelope","Armadillo","Baboon","Badger","Bandicoot","Barbet","Bat","Bee","Bee-eater","Beetle","Bird","Bison","Black-footed Cat","Black-footed Ferret","Bluebird","Boa","Bowerbird","Brown Bear","Bush Dog","Bushshrike","Bustard","Butterfly","Buzzard","Caracal","Caracara","Cardinal","Caterpillar","Cheetah","Chipmunk","Civet","Climbing Mouse","Clouded Leopard","Coati","Cobra","Cockatoo","Cockroach","Common Genet","Cotton Rat","Cougar","Courser","Coyote","Crane","Crane Fly","Cricket","Crow","Culpeo","Death Adder","Deer","Deer Mouse","Dingo","Dinosaur","Dove","Drongo","Duck","Duiker","Dunnart","Eagle","Echidna","Elephant","Elk","Emu","Falcon","Finch","Flea","Fly","Flying Frog","Fox","Frog","Frogmouth","Garter Snake","Gazelle","Gecko","Geoffroy's Cat","Gerbil","Giant Tortoise","Giraffe","Grasshopper","Grison","Groundhog","Grouse","Guanaco","Guinea Pig","Hamster","Harrier","Hartebeest","Hawk","Hedgehog","Helmetshrike","Hippopotamus","Hornbill","Hyena","Hyrax","Impala","Jackal","Jaguar","Jaguarundi","Kangaroo","Kangaroo Rat","Kestrel","Kultarr","Ladybug","Leopard","Lion","Macaw","Meerkat","Mouse","Newt","Oryx","Ostrich","Owl","Pangolin","Pheasant","Prairie Dog","Pronghorn","Przewalski's Horse","Python","Quoll","Rabbit","Raven","Rhinoceros","Shelduck","Sloth Bear","Spectacled Bear","Squirrel","Starling","Stick Bug","Tamandua","Tasmanian Devil","Thornbill","Thrush","Toad","Tortoise"],
              "forest" : ["Agouti","Anaconda","Anoa","Ant","Anteater","Antelope","Armadillo","Asian Black Bear","Aye-aye","Babirusa","Baboon","Badger","Bandicoot","Banteng","Barbet","Basilisk","Bat","Bearded Dragon","Bee","Bee-eater","Beetle","Bettong","Binturong","Bird-of-paradise","Bongo","Bowerbird","Bulbul","Bush Dog","Bushbaby","Bushshrike","Butterfly","Buzzard","Caecilian","Cardinal","Cassowary","Caterpillar","Centipede","Chameleon","Chimpanzee","Cicada","Civet","Clouded Leopard","Coati","Cobra","Cockatoo","Cockroach","Colugo","Cotinga","Cotton Rat","Cougar","Crane Fly","Cricket","Crocodile","Crow","Cuckoo","Cuscus","Death Adder","Deer","Dhole","Dingo","Dinosaur","Drongo","Duck","Duiker","Eagle","Echidna","Elephant","Finch","Flat-headed Cat","Flea","Flowerpecker","Fly","Flying Frog","Fossa","Frog","Frogmouth","Gaur","Gecko","Gorilla","Grison","Hawaiian Honeycreeper","Hawk","Hedgehog","Helmetshrike","Hornbill","Hyrax","Iguana","Jackal","Jaguar","Jaguarundi","Kestrel","Ladybug","Lemur","Leopard","Lion","Macaw","Mandrill","Margay","Monkey","Mouse","Mouse Deer","Newt","Okapi","Old World Flycatcher","Orangutan","Owl","Pangolin","Peafowl","Pheasant","Possum","Python","Quokka","Rabbit","Raccoon","Red Panda","Red River Hog","Rhinoceros","Sloth Bear","Spectacled Bear","Squirrel","Starling","Stick Bug","Sun Bear","Tamandua","Tamarin","Tapir","Tarantula","Thrush","Tiger","Tit","Toad","Tortoise","Toucan","Trogon","Trumpeter","Turaco","Turtle","Tyrant Flycatcher","Viper","Vulture","Wallaby","Warbler","Wasp","Waxwing","Weaver","Weaver-finch","Whistler","White-eye","Whydah","Woodswallow","Worm","Wren","Xenops","Yellowjacket","Accentor","African Buffalo","American Black Bear","Anole","Bird","Bison","Boa","Brown Bear","Chipmunk","Common Genet","Copperhead","Coyote","Deer Mouse","Dormouse","Elk","Emu","Fisher","Fox","Garter Snake","Giant Panda","Giant Tortoise","Groundhog","Grouse","Guanaco","Himalayan Tahr","Kangaroo","Koala","Numbat","Quoll","Raccoon dog","Tasmanian Devil","Thornbill","Turkey","Vole","Weasel","Wildcat","Wolf","Wombat","Woodchuck","Woodpecker"],
              //list of farm animals comes from https://www.buzzle.com/articles/farm-animals-list.html
              "farm" : ["Alpaca","Buffalo","Banteng","Cow","Cat","Chicken","Carp","Camel","Donkey","Dog","Duck","Emu","Goat","Gayal","Guinea","Goose","Horse","Honey","Llama","Pig","Pigeon","Rhea","Rabbit","Sheep","Silkworm","Turkey","Yak","Zebu"],
              //list of pet animals comes from https://www.dogbreedinfo.com/pets/pet.htm
              "pet" : ["Bearded Dragon","Birds","Burro","Cats","Chameleons","Chickens","Chinchillas","Chinese Water Dragon","Cows","Dogs","Donkey","Ducks","Ferrets","Fish","Geckos","Geese","Gerbils","Goats","Guinea Fowl","Guinea Pigs","Hamsters","Hedgehogs","Horses","Iguanas","Llamas","Lizards","Mice","Mule","Peafowl","Pigs and Hogs","Pigeons","Ponies","Pot Bellied Pig","Rabbits","Rats","Sheep","Skinks","Snakes","Stick Insects","Sugar Gliders","Tarantula","Turkeys","Turtles"],
              //list of zoo animals comes from https://bronxzoo.com/animals
              "zoo" : ["Aardvark","African Wild Dog","Aldabra Tortoise","American Alligator","American Bison","Amur Tiger","Anaconda","Andean Condor","Asian Elephant","Baby Doll Sheep","Bald Eagle","Barred Owl","Blue Iguana","Boer Goat","California Sea Lion","Caribbean Flamingo","Chinchilla","Collared Lemur","Coquerel's Sifaka","Cuban Amazon Parrot","Ebony Langur","Fennec Fox","Fossa","Gelada","Giant Anteater","Giraffe","Gorilla","Grizzly Bear","Henkel's Leaf-tailed Gecko","Indian Gharial","Indian Rhinoceros","King Cobra","King Vulture","Komodo Dragon","Linne's Two-toed Sloth","Lion","Little Penguin","Madagascar Tree Boa","Magellanic Penguin","Malayan Tapir","Malayan Tiger","Matschies Tree Kangaroo","Mini Donkey","Monarch Butterfly","Nile crocodile","North American Porcupine","Nubian Ibex","Okapi","Poison Dart Frog","Polar Bear","Pygmy Marmoset","Radiated Tortoise","Red Panda","Red Ruffed Lemur","Ring-tailed Lemur","Ring-tailed Mongoose","Rock Hyrax","Small Clawed Asian Otter","Snow Leopard","Snowy Owl","Southern White-faced Owl","Southern White Rhinocerous","Squirrel Monkey","Tufted Puffin","White Cheeked Gibbon","White-throated Bee Eater","Zebra"]
            },
            primes: [
                // 1230 first primes, i.e. all primes up to the first one greater than 10000, inclusive.
                2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007
            ],
            emotions: [
                "love",
                "joy",
                "surprise",
                "anger",
                "sadness",
                "fear"
            ],
        };

        var o_hasOwnProperty = Object.prototype.hasOwnProperty;
        var o_keys = (Object.keys || function(obj) {
          var result = [];
          for (var key in obj) {
            if (o_hasOwnProperty.call(obj, key)) {
              result.push(key);
            }
          }

          return result;
        });


        function _copyObject(source, target) {
          var keys = o_keys(source);
          var key;

          for (var i = 0, l = keys.length; i < l; i++) {
            key = keys[i];
            target[key] = source[key] || target[key];
          }
        }

        function _copyArray(source, target) {
          for (var i = 0, l = source.length; i < l; i++) {
            target[i] = source[i];
          }
        }

        function copyObject(source, _target) {
            var isArray = Array.isArray(source);
            var target = _target || (isArray ? new Array(source.length) : {});

            if (isArray) {
              _copyArray(source, target);
            } else {
              _copyObject(source, target);
            }

            return target;
        }

        /** Get the data based on key**/
        Chance.prototype.get = function (name) {
            return copyObject(data[name]);
        };

        // Mac Address
        Chance.prototype.mac_address = function(options){
            // typically mac addresses are separated by ":"
            // however they can also be separated by "-"
            // the network variant uses a dot every fourth byte

            options = initOptions(options);
            if(!options.separator) {
                options.separator =  options.networkVersion ? "." : ":";
            }

            var mac_pool="ABCDEF1234567890",
                mac = "";
            if(!options.networkVersion) {
                mac = this.n(this.string, 6, { pool: mac_pool, length:2 }).join(options.separator);
            } else {
                mac = this.n(this.string, 3, { pool: mac_pool, length:4 }).join(options.separator);
            }

            return mac;
        };

        Chance.prototype.normal = function (options) {
            options = initOptions(options, {mean : 0, dev : 1, pool : []});

            testRange(
                options.pool.constructor !== Array,
                "Chance: The pool option must be a valid array."
            );
            testRange(
                typeof options.mean !== 'number',
                "Chance: Mean (mean) must be a number"
            );
            testRange(
                typeof options.dev !== 'number',
                "Chance: Standard deviation (dev) must be a number"
            );

            // If a pool has been passed, then we are returning an item from that pool,
            // using the normal distribution settings that were passed in
            if (options.pool.length > 0) {
                return this.normal_pool(options);
            }

            // The Marsaglia Polar method
            var s, u, v, norm,
                mean = options.mean,
                dev = options.dev;

            do {
                // U and V are from the uniform distribution on (-1, 1)
                u = this.random() * 2 - 1;
                v = this.random() * 2 - 1;

                s = u * u + v * v;
            } while (s >= 1);

            // Compute the standard normal variate
            norm = u * Math.sqrt(-2 * Math.log(s) / s);

            // Shape and scale
            return dev * norm + mean;
        };

        Chance.prototype.normal_pool = function(options) {
            var performanceCounter = 0;
            do {
                var idx = Math.round(this.normal({ mean: options.mean, dev: options.dev }));
                if (idx < options.pool.length && idx >= 0) {
                    return options.pool[idx];
                } else {
                    performanceCounter++;
                }
            } while(performanceCounter < 100);

            throw new RangeError("Chance: Your pool is too small for the given mean and standard deviation. Please adjust.");
        };

        Chance.prototype.radio = function (options) {
            // Initial Letter (Typically Designated by Side of Mississippi River)
            options = initOptions(options, {side : "?"});
            var fl = "";
            switch (options.side.toLowerCase()) {
            case "east":
            case "e":
                fl = "W";
                break;
            case "west":
            case "w":
                fl = "K";
                break;
            default:
                fl = this.character({pool: "KW"});
                break;
            }

            return fl + this.character({alpha: true, casing: "upper"}) +
                    this.character({alpha: true, casing: "upper"}) +
                    this.character({alpha: true, casing: "upper"});
        };

        // Set the data as key and data or the data map
        Chance.prototype.set = function (name, values) {
            if (typeof name === "string") {
                data[name] = values;
            } else {
                data = copyObject(name, data);
            }
        };

        Chance.prototype.tv = function (options) {
            return this.radio(options);
        };

        // ID number for Brazil companies
        Chance.prototype.cnpj = function () {
            var n = this.n(this.natural, 8, { max: 9 });
            var d1 = 2+n[7]*6+n[6]*7+n[5]*8+n[4]*9+n[3]*2+n[2]*3+n[1]*4+n[0]*5;
            d1 = 11 - (d1 % 11);
            if (d1>=10){
                d1 = 0;
            }
            var d2 = d1*2+3+n[7]*7+n[6]*8+n[5]*9+n[4]*2+n[3]*3+n[2]*4+n[1]*5+n[0]*6;
            d2 = 11 - (d2 % 11);
            if (d2>=10){
                d2 = 0;
            }
            return ''+n[0]+n[1]+'.'+n[2]+n[3]+n[4]+'.'+n[5]+n[6]+n[7]+'/0001-'+d1+d2;
        };

        Chance.prototype.emotion = function () {
            return this.pick(this.get("emotions"));
        };

        // -- End Miscellaneous --

        Chance.prototype.mersenne_twister = function (seed) {
            return new MersenneTwister(seed);
        };

        Chance.prototype.blueimp_md5 = function () {
            return new BlueImpMD5();
        };

        // Mersenne Twister from https://gist.github.com/banksean/300494
        /*
           A C-program for MT19937, with initialization improved 2002/1/26.
           Coded by Takuji Nishimura and Makoto Matsumoto.

           Before using, initialize the state by using init_genrand(seed)
           or init_by_array(init_key, key_length).

           Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
           All rights reserved.

           Redistribution and use in source and binary forms, with or without
           modification, are permitted provided that the following conditions
           are met:

           1. Redistributions of source code must retain the above copyright
           notice, this list of conditions and the following disclaimer.

           2. Redistributions in binary form must reproduce the above copyright
           notice, this list of conditions and the following disclaimer in the
           documentation and/or other materials provided with the distribution.

           3. The names of its contributors may not be used to endorse or promote
           products derived from this software without specific prior written
           permission.

           THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
           "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
           LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
           A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
           CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
           EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
           PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
           PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
           LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
           NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
           SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


           Any feedback is very welcome.
           http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
           email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
         */
        var MersenneTwister = function (seed) {
            if (seed === undefined) {
                // kept random number same size as time used previously to ensure no unexpected results downstream
                seed = Math.floor(Math.random()*Math.pow(10,13));
            }
            /* Period parameters */
            this.N = 624;
            this.M = 397;
            this.MATRIX_A = 0x9908b0df;   /* constant vector a */
            this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
            this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

            this.mt = new Array(this.N); /* the array for the state vector */
            this.mti = this.N + 1; /* mti==N + 1 means mt[N] is not initialized */

            this.init_genrand(seed);
        };

        /* initializes mt[N] with a seed */
        MersenneTwister.prototype.init_genrand = function (s) {
            this.mt[0] = s >>> 0;
            for (this.mti = 1; this.mti < this.N; this.mti++) {
                s = this.mt[this.mti - 1] ^ (this.mt[this.mti - 1] >>> 30);
                this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + this.mti;
                /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
                /* In the previous versions, MSBs of the seed affect   */
                /* only MSBs of the array mt[].                        */
                /* 2002/01/09 modified by Makoto Matsumoto             */
                this.mt[this.mti] >>>= 0;
                /* for >32 bit machines */
            }
        };

        /* initialize by an array with array-length */
        /* init_key is the array for initializing keys */
        /* key_length is its length */
        /* slight change for C++, 2004/2/26 */
        MersenneTwister.prototype.init_by_array = function (init_key, key_length) {
            var i = 1, j = 0, k, s;
            this.init_genrand(19650218);
            k = (this.N > key_length ? this.N : key_length);
            for (; k; k--) {
                s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
                this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525))) + init_key[j] + j; /* non linear */
                this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
                i++;
                j++;
                if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
                if (j >= key_length) { j = 0; }
            }
            for (k = this.N - 1; k; k--) {
                s = this.mt[i - 1] ^ (this.mt[i - 1] >>> 30);
                this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941)) - i; /* non linear */
                this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
                i++;
                if (i >= this.N) { this.mt[0] = this.mt[this.N - 1]; i = 1; }
            }

            this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
        };

        /* generates a random number on [0,0xffffffff]-interval */
        MersenneTwister.prototype.genrand_int32 = function () {
            var y;
            var mag01 = new Array(0x0, this.MATRIX_A);
            /* mag01[x] = x * MATRIX_A  for x=0,1 */

            if (this.mti >= this.N) { /* generate N words at one time */
                var kk;

                if (this.mti === this.N + 1) {   /* if init_genrand() has not been called, */
                    this.init_genrand(5489); /* a default initial seed is used */
                }
                for (kk = 0; kk < this.N - this.M; kk++) {
                    y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                    this.mt[kk] = this.mt[kk + this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
                }
                for (;kk < this.N - 1; kk++) {
                    y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk + 1]&this.LOWER_MASK);
                    this.mt[kk] = this.mt[kk + (this.M - this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
                }
                y = (this.mt[this.N - 1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
                this.mt[this.N - 1] = this.mt[this.M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];

                this.mti = 0;
            }

            y = this.mt[this.mti++];

            /* Tempering */
            y ^= (y >>> 11);
            y ^= (y << 7) & 0x9d2c5680;
            y ^= (y << 15) & 0xefc60000;
            y ^= (y >>> 18);

            return y >>> 0;
        };

        /* generates a random number on [0,0x7fffffff]-interval */
        MersenneTwister.prototype.genrand_int31 = function () {
            return (this.genrand_int32() >>> 1);
        };

        /* generates a random number on [0,1]-real-interval */
        MersenneTwister.prototype.genrand_real1 = function () {
            return this.genrand_int32() * (1.0 / 4294967295.0);
            /* divided by 2^32-1 */
        };

        /* generates a random number on [0,1)-real-interval */
        MersenneTwister.prototype.random = function () {
            return this.genrand_int32() * (1.0 / 4294967296.0);
            /* divided by 2^32 */
        };

        /* generates a random number on (0,1)-real-interval */
        MersenneTwister.prototype.genrand_real3 = function () {
            return (this.genrand_int32() + 0.5) * (1.0 / 4294967296.0);
            /* divided by 2^32 */
        };

        /* generates a random number on [0,1) with 53-bit resolution*/
        MersenneTwister.prototype.genrand_res53 = function () {
            var a = this.genrand_int32()>>>5, b = this.genrand_int32()>>>6;
            return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0);
        };

        // BlueImp MD5 hashing algorithm from https://github.com/blueimp/JavaScript-MD5
        var BlueImpMD5 = function () {};

        BlueImpMD5.prototype.VERSION = '1.0.1';

        /*
        * Add integers, wrapping at 2^32. This uses 16-bit operations internally
        * to work around bugs in some JS interpreters.
        */
        BlueImpMD5.prototype.safe_add = function safe_add(x, y) {
            var lsw = (x & 0xFFFF) + (y & 0xFFFF),
                msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return (msw << 16) | (lsw & 0xFFFF);
        };

        /*
        * Bitwise rotate a 32-bit number to the left.
        */
        BlueImpMD5.prototype.bit_roll = function (num, cnt) {
            return (num << cnt) | (num >>> (32 - cnt));
        };

        /*
        * These functions implement the five basic operations the algorithm uses.
        */
        BlueImpMD5.prototype.md5_cmn = function (q, a, b, x, s, t) {
            return this.safe_add(this.bit_roll(this.safe_add(this.safe_add(a, q), this.safe_add(x, t)), s), b);
        };
        BlueImpMD5.prototype.md5_ff = function (a, b, c, d, x, s, t) {
            return this.md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
        };
        BlueImpMD5.prototype.md5_gg = function (a, b, c, d, x, s, t) {
            return this.md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
        };
        BlueImpMD5.prototype.md5_hh = function (a, b, c, d, x, s, t) {
            return this.md5_cmn(b ^ c ^ d, a, b, x, s, t);
        };
        BlueImpMD5.prototype.md5_ii = function (a, b, c, d, x, s, t) {
            return this.md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
        };

        /*
        * Calculate the MD5 of an array of little-endian words, and a bit length.
        */
        BlueImpMD5.prototype.binl_md5 = function (x, len) {
            /* append padding */
            x[len >> 5] |= 0x80 << (len % 32);
            x[(((len + 64) >>> 9) << 4) + 14] = len;

            var i, olda, oldb, oldc, oldd,
                a =  1732584193,
                b = -271733879,
                c = -1732584194,
                d =  271733878;

            for (i = 0; i < x.length; i += 16) {
                olda = a;
                oldb = b;
                oldc = c;
                oldd = d;

                a = this.md5_ff(a, b, c, d, x[i],       7, -680876936);
                d = this.md5_ff(d, a, b, c, x[i +  1], 12, -389564586);
                c = this.md5_ff(c, d, a, b, x[i +  2], 17,  606105819);
                b = this.md5_ff(b, c, d, a, x[i +  3], 22, -1044525330);
                a = this.md5_ff(a, b, c, d, x[i +  4],  7, -176418897);
                d = this.md5_ff(d, a, b, c, x[i +  5], 12,  1200080426);
                c = this.md5_ff(c, d, a, b, x[i +  6], 17, -1473231341);
                b = this.md5_ff(b, c, d, a, x[i +  7], 22, -45705983);
                a = this.md5_ff(a, b, c, d, x[i +  8],  7,  1770035416);
                d = this.md5_ff(d, a, b, c, x[i +  9], 12, -1958414417);
                c = this.md5_ff(c, d, a, b, x[i + 10], 17, -42063);
                b = this.md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
                a = this.md5_ff(a, b, c, d, x[i + 12],  7,  1804603682);
                d = this.md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
                c = this.md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
                b = this.md5_ff(b, c, d, a, x[i + 15], 22,  1236535329);

                a = this.md5_gg(a, b, c, d, x[i +  1],  5, -165796510);
                d = this.md5_gg(d, a, b, c, x[i +  6],  9, -1069501632);
                c = this.md5_gg(c, d, a, b, x[i + 11], 14,  643717713);
                b = this.md5_gg(b, c, d, a, x[i],      20, -373897302);
                a = this.md5_gg(a, b, c, d, x[i +  5],  5, -701558691);
                d = this.md5_gg(d, a, b, c, x[i + 10],  9,  38016083);
                c = this.md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
                b = this.md5_gg(b, c, d, a, x[i +  4], 20, -405537848);
                a = this.md5_gg(a, b, c, d, x[i +  9],  5,  568446438);
                d = this.md5_gg(d, a, b, c, x[i + 14],  9, -1019803690);
                c = this.md5_gg(c, d, a, b, x[i +  3], 14, -187363961);
                b = this.md5_gg(b, c, d, a, x[i +  8], 20,  1163531501);
                a = this.md5_gg(a, b, c, d, x[i + 13],  5, -1444681467);
                d = this.md5_gg(d, a, b, c, x[i +  2],  9, -51403784);
                c = this.md5_gg(c, d, a, b, x[i +  7], 14,  1735328473);
                b = this.md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

                a = this.md5_hh(a, b, c, d, x[i +  5],  4, -378558);
                d = this.md5_hh(d, a, b, c, x[i +  8], 11, -2022574463);
                c = this.md5_hh(c, d, a, b, x[i + 11], 16,  1839030562);
                b = this.md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
                a = this.md5_hh(a, b, c, d, x[i +  1],  4, -1530992060);
                d = this.md5_hh(d, a, b, c, x[i +  4], 11,  1272893353);
                c = this.md5_hh(c, d, a, b, x[i +  7], 16, -155497632);
                b = this.md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
                a = this.md5_hh(a, b, c, d, x[i + 13],  4,  681279174);
                d = this.md5_hh(d, a, b, c, x[i],      11, -358537222);
                c = this.md5_hh(c, d, a, b, x[i +  3], 16, -722521979);
                b = this.md5_hh(b, c, d, a, x[i +  6], 23,  76029189);
                a = this.md5_hh(a, b, c, d, x[i +  9],  4, -640364487);
                d = this.md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
                c = this.md5_hh(c, d, a, b, x[i + 15], 16,  530742520);
                b = this.md5_hh(b, c, d, a, x[i +  2], 23, -995338651);

                a = this.md5_ii(a, b, c, d, x[i],       6, -198630844);
                d = this.md5_ii(d, a, b, c, x[i +  7], 10,  1126891415);
                c = this.md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
                b = this.md5_ii(b, c, d, a, x[i +  5], 21, -57434055);
                a = this.md5_ii(a, b, c, d, x[i + 12],  6,  1700485571);
                d = this.md5_ii(d, a, b, c, x[i +  3], 10, -1894986606);
                c = this.md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
                b = this.md5_ii(b, c, d, a, x[i +  1], 21, -2054922799);
                a = this.md5_ii(a, b, c, d, x[i +  8],  6,  1873313359);
                d = this.md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
                c = this.md5_ii(c, d, a, b, x[i +  6], 15, -1560198380);
                b = this.md5_ii(b, c, d, a, x[i + 13], 21,  1309151649);
                a = this.md5_ii(a, b, c, d, x[i +  4],  6, -145523070);
                d = this.md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
                c = this.md5_ii(c, d, a, b, x[i +  2], 15,  718787259);
                b = this.md5_ii(b, c, d, a, x[i +  9], 21, -343485551);

                a = this.safe_add(a, olda);
                b = this.safe_add(b, oldb);
                c = this.safe_add(c, oldc);
                d = this.safe_add(d, oldd);
            }
            return [a, b, c, d];
        };

        /*
        * Convert an array of little-endian words to a string
        */
        BlueImpMD5.prototype.binl2rstr = function (input) {
            var i,
                output = '';
            for (i = 0; i < input.length * 32; i += 8) {
                output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
            }
            return output;
        };

        /*
        * Convert a raw string to an array of little-endian words
        * Characters >255 have their high-byte silently ignored.
        */
        BlueImpMD5.prototype.rstr2binl = function (input) {
            var i,
                output = [];
            output[(input.length >> 2) - 1] = undefined;
            for (i = 0; i < output.length; i += 1) {
                output[i] = 0;
            }
            for (i = 0; i < input.length * 8; i += 8) {
                output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
            }
            return output;
        };

        /*
        * Calculate the MD5 of a raw string
        */
        BlueImpMD5.prototype.rstr_md5 = function (s) {
            return this.binl2rstr(this.binl_md5(this.rstr2binl(s), s.length * 8));
        };

        /*
        * Calculate the HMAC-MD5, of a key and some data (raw strings)
        */
        BlueImpMD5.prototype.rstr_hmac_md5 = function (key, data) {
            var i,
                bkey = this.rstr2binl(key),
                ipad = [],
                opad = [],
                hash;
            ipad[15] = opad[15] = undefined;
            if (bkey.length > 16) {
                bkey = this.binl_md5(bkey, key.length * 8);
            }
            for (i = 0; i < 16; i += 1) {
                ipad[i] = bkey[i] ^ 0x36363636;
                opad[i] = bkey[i] ^ 0x5C5C5C5C;
            }
            hash = this.binl_md5(ipad.concat(this.rstr2binl(data)), 512 + data.length * 8);
            return this.binl2rstr(this.binl_md5(opad.concat(hash), 512 + 128));
        };

        /*
        * Convert a raw string to a hex string
        */
        BlueImpMD5.prototype.rstr2hex = function (input) {
            var hex_tab = '0123456789abcdef',
                output = '',
                x,
                i;
            for (i = 0; i < input.length; i += 1) {
                x = input.charCodeAt(i);
                output += hex_tab.charAt((x >>> 4) & 0x0F) +
                    hex_tab.charAt(x & 0x0F);
            }
            return output;
        };

        /*
        * Encode a string as utf-8
        */
        BlueImpMD5.prototype.str2rstr_utf8 = function (input) {
            return unescape(encodeURIComponent(input));
        };

        /*
        * Take string arguments and return either raw or hex encoded strings
        */
        BlueImpMD5.prototype.raw_md5 = function (s) {
            return this.rstr_md5(this.str2rstr_utf8(s));
        };
        BlueImpMD5.prototype.hex_md5 = function (s) {
            return this.rstr2hex(this.raw_md5(s));
        };
        BlueImpMD5.prototype.raw_hmac_md5 = function (k, d) {
            return this.rstr_hmac_md5(this.str2rstr_utf8(k), this.str2rstr_utf8(d));
        };
        BlueImpMD5.prototype.hex_hmac_md5 = function (k, d) {
            return this.rstr2hex(this.raw_hmac_md5(k, d));
        };

        BlueImpMD5.prototype.md5 = function (string, key, raw) {
            if (!key) {
                if (!raw) {
                    return this.hex_md5(string);
                }

                return this.raw_md5(string);
            }

            if (!raw) {
                return this.hex_hmac_md5(key, string);
            }

            return this.raw_hmac_md5(key, string);
        };

        // CommonJS module
        {
            if ( module.exports) {
                exports = module.exports = Chance;
            }
            exports.Chance = Chance;
        }

        // if there is a importsScrips object define chance for worker
        // allows worker to use full Chance functionality with seed
        if (typeof importScripts !== 'undefined') {
            chance = new Chance();
            self.Chance = Chance;
        }

        // If there is a window object, that at least has a document property,
        // instantiate and define chance on the window
        if (typeof window === "object" && typeof window.document === "object") {
            window.Chance = Chance;
            window.chance = new Chance();
        }
    })();
    });

    /* src/Dashboard.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1, console: console_1 } = globals;
    const file$A = "src/Dashboard.svelte";

    // (25:0) <Tile>
    function create_default_slot_16(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "The Shape of a Practice";
    			add_location(h1, file$A, 25, 2, 555);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(25:0) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (31:2) <Tag type="green">
    function create_default_slot_15(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Users: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(31:2) <Tag type=\\\"green\\\">",
    		ctx
    	});

    	return block;
    }

    // (32:2) <Tag type="grey">
    function create_default_slot_14(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Accredited:\n    ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(32:2) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:2) <Tag type="grey">
    function create_default_slot_13(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func_1).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Guests:\n    ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func_1).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(36:2) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (40:2) <Tag type="grey">
    function create_default_slot_12(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func_2).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("NPCs: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func_2).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(40:2) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (30:0) <ClickableTile href="/users">
    function create_default_slot_11(ctx) {
    	let tag0;
    	let t0;
    	let tag1;
    	let t1;
    	let tag2;
    	let t2;
    	let tag3;
    	let current;

    	tag0 = new Tag({
    			props: {
    				type: "green",
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag1 = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag2 = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag3 = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag0.$$.fragment);
    			t0 = space();
    			create_component(tag1.$$.fragment);
    			t1 = space();
    			create_component(tag2.$$.fragment);
    			t2 = space();
    			create_component(tag3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tag1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tag2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tag3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag0_changes = {};

    			if (dirty & /*$$scope, users*/ 17) {
    				tag0_changes.$$scope = { dirty, ctx };
    			}

    			tag0.$set(tag0_changes);
    			const tag1_changes = {};

    			if (dirty & /*$$scope, users*/ 17) {
    				tag1_changes.$$scope = { dirty, ctx };
    			}

    			tag1.$set(tag1_changes);
    			const tag2_changes = {};

    			if (dirty & /*$$scope, users*/ 17) {
    				tag2_changes.$$scope = { dirty, ctx };
    			}

    			tag2.$set(tag2_changes);
    			const tag3_changes = {};

    			if (dirty & /*$$scope, users*/ 17) {
    				tag3_changes.$$scope = { dirty, ctx };
    			}

    			tag3.$set(tag3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag0.$$.fragment, local);
    			transition_in(tag1.$$.fragment, local);
    			transition_in(tag2.$$.fragment, local);
    			transition_in(tag3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag0.$$.fragment, local);
    			transition_out(tag1.$$.fragment, local);
    			transition_out(tag2.$$.fragment, local);
    			transition_out(tag3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tag1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tag2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tag3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(30:0) <ClickableTile href=\\\"/users\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:2) <Tag type="red">
    function create_default_slot_10(ctx) {
    	let t0;
    	let t1_value = /*blackList*/ ctx[1].length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Banned IPs: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*blackList*/ 2 && t1_value !== (t1_value = /*blackList*/ ctx[1].length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(45:2) <Tag type=\\\"red\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:0) <ClickableTile href="/banned">
    function create_default_slot_9(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "red",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag_changes = {};

    			if (dirty & /*$$scope, blackList*/ 18) {
    				tag_changes.$$scope = { dirty, ctx };
    			}

    			tag.$set(tag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(44:0) <ClickableTile href=\\\"/banned\\\">",
    		ctx
    	});

    	return block;
    }

    // (50:2) <Tag type="magenta">
    function create_default_slot_8(ctx) {
    	let t0;
    	let t1_value = (/*currentStream*/ ctx[3] ? "Yes" : "No") + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Livestream: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentStream*/ 8 && t1_value !== (t1_value = (/*currentStream*/ ctx[3] ? "Yes" : "No") + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(50:2) <Tag type=\\\"magenta\\\">",
    		ctx
    	});

    	return block;
    }

    // (51:2) {#if currentStream}
    function create_if_block$o(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag_changes = {};

    			if (dirty & /*$$scope, currentStream*/ 24) {
    				tag_changes.$$scope = { dirty, ctx };
    			}

    			tag.$set(tag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(51:2) {#if currentStream}",
    		ctx
    	});

    	return block;
    }

    // (52:4) <Tag type="gray">
    function create_default_slot_7(ctx) {
    	let t0;
    	let t1_value = /*currentStream*/ ctx[3].title + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Active event: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*currentStream*/ 8 && t1_value !== (t1_value = /*currentStream*/ ctx[3].title + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(52:4) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:0) <ClickableTile href="/livestreams">
    function create_default_slot_6(ctx) {
    	let tag;
    	let t;
    	let if_block_anchor;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "magenta",
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*currentStream*/ ctx[3] && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag_changes = {};

    			if (dirty & /*$$scope, currentStream*/ 24) {
    				tag_changes.$$scope = { dirty, ctx };
    			}

    			tag.$set(tag_changes);

    			if (/*currentStream*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*currentStream*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(49:0) <ClickableTile href=\\\"/livestreams\\\">",
    		ctx
    	});

    	return block;
    }

    // (58:2) <Tag type="blue">
    function create_default_slot_5(ctx) {
    	let t0;
    	let t1_value = /*chatMessages*/ ctx[2].length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Chat messages: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 4 && t1_value !== (t1_value = /*chatMessages*/ ctx[2].length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(58:2) <Tag type=\\\"blue\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:2) <Tag type="gray">
    function create_default_slot_4(ctx) {
    	let t0;
    	let t1_value = /*chatMessages*/ ctx[2].filter(func_3).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Room 1: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 4 && t1_value !== (t1_value = /*chatMessages*/ ctx[2].filter(func_3).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(59:2) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (60:2) <Tag type="gray">
    function create_default_slot_3(ctx) {
    	let t0;
    	let t1_value = /*chatMessages*/ ctx[2].filter(func_4).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Room 2: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 4 && t1_value !== (t1_value = /*chatMessages*/ ctx[2].filter(func_4).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(60:2) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (61:2) <Tag type="gray">
    function create_default_slot_2(ctx) {
    	let t0;
    	let t1_value = /*chatMessages*/ ctx[2].filter(func_5).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Room 3: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 4 && t1_value !== (t1_value = /*chatMessages*/ ctx[2].filter(func_5).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(61:2) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (62:2) <Tag type="gray">
    function create_default_slot_1(ctx) {
    	let t0;
    	let t1_value = /*chatMessages*/ ctx[2].filter(func_6).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Room 4: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 4 && t1_value !== (t1_value = /*chatMessages*/ ctx[2].filter(func_6).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(62:2) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (57:0) <ClickableTile href="/textchat">
    function create_default_slot$1(ctx) {
    	let tag0;
    	let t0;
    	let tag1;
    	let t1;
    	let tag2;
    	let t2;
    	let tag3;
    	let t3;
    	let tag4;
    	let current;

    	tag0 = new Tag({
    			props: {
    				type: "blue",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag1 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag2 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag3 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag4 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag0.$$.fragment);
    			t0 = space();
    			create_component(tag1.$$.fragment);
    			t1 = space();
    			create_component(tag2.$$.fragment);
    			t2 = space();
    			create_component(tag3.$$.fragment);
    			t3 = space();
    			create_component(tag4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tag1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tag2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tag3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(tag4, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag0_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				tag0_changes.$$scope = { dirty, ctx };
    			}

    			tag0.$set(tag0_changes);
    			const tag1_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				tag1_changes.$$scope = { dirty, ctx };
    			}

    			tag1.$set(tag1_changes);
    			const tag2_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				tag2_changes.$$scope = { dirty, ctx };
    			}

    			tag2.$set(tag2_changes);
    			const tag3_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				tag3_changes.$$scope = { dirty, ctx };
    			}

    			tag3.$set(tag3_changes);
    			const tag4_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				tag4_changes.$$scope = { dirty, ctx };
    			}

    			tag4.$set(tag4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag0.$$.fragment, local);
    			transition_in(tag1.$$.fragment, local);
    			transition_in(tag2.$$.fragment, local);
    			transition_in(tag3.$$.fragment, local);
    			transition_in(tag4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag0.$$.fragment, local);
    			transition_out(tag1.$$.fragment, local);
    			transition_out(tag2.$$.fragment, local);
    			transition_out(tag3.$$.fragment, local);
    			transition_out(tag4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tag1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tag2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tag3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(tag4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(57:0) <ClickableTile href=\\\"/textchat\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let tile;
    	let t0;
    	let clickabletile0;
    	let t1;
    	let clickabletile1;
    	let t2;
    	let clickabletile2;
    	let t3;
    	let clickabletile3;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	clickabletile0 = new ClickableTile({
    			props: {
    				href: "/users",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	clickabletile1 = new ClickableTile({
    			props: {
    				href: "/banned",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	clickabletile2 = new ClickableTile({
    			props: {
    				href: "/livestreams",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	clickabletile3 = new ClickableTile({
    			props: {
    				href: "/textchat",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    			t0 = space();
    			create_component(clickabletile0.$$.fragment);
    			t1 = space();
    			create_component(clickabletile1.$$.fragment);
    			t2 = space();
    			create_component(clickabletile2.$$.fragment);
    			t3 = space();
    			create_component(clickabletile3.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(clickabletile0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(clickabletile1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(clickabletile2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(clickabletile3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    			const clickabletile0_changes = {};

    			if (dirty & /*$$scope, users*/ 17) {
    				clickabletile0_changes.$$scope = { dirty, ctx };
    			}

    			clickabletile0.$set(clickabletile0_changes);
    			const clickabletile1_changes = {};

    			if (dirty & /*$$scope, blackList*/ 18) {
    				clickabletile1_changes.$$scope = { dirty, ctx };
    			}

    			clickabletile1.$set(clickabletile1_changes);
    			const clickabletile2_changes = {};

    			if (dirty & /*$$scope, currentStream*/ 24) {
    				clickabletile2_changes.$$scope = { dirty, ctx };
    			}

    			clickabletile2.$set(clickabletile2_changes);
    			const clickabletile3_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 20) {
    				clickabletile3_changes.$$scope = { dirty, ctx };
    			}

    			clickabletile3.$set(clickabletile3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			transition_in(clickabletile0.$$.fragment, local);
    			transition_in(clickabletile1.$$.fragment, local);
    			transition_in(clickabletile2.$$.fragment, local);
    			transition_in(clickabletile3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			transition_out(clickabletile0.$$.fragment, local);
    			transition_out(clickabletile1.$$.fragment, local);
    			transition_out(clickabletile2.$$.fragment, local);
    			transition_out(clickabletile3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(clickabletile0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(clickabletile1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(clickabletile2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(clickabletile3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = u => u.authenticated;
    const func_1 = u => !u.npc && !u.authenticated;
    const func_2 = u => u.npc;
    const func_3 = m => m.room === 1;
    const func_4 = m => m.room === 2;
    const func_5 = m => m.room === 3;
    const func_6 = m => m.room === 4;

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dashboard", slots, []);
    	let { users = {} } = $$props;
    	let { blackList = [] } = $$props;
    	let { chatMessages = [] } = $$props;
    	let { currentStream = false } = $$props;
    	console.dir(currentStream);
    	const writable_props = ["users", "blackList", "chatMessages", "currentStream"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Dashboard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("users" in $$props) $$invalidate(0, users = $$props.users);
    		if ("blackList" in $$props) $$invalidate(1, blackList = $$props.blackList);
    		if ("chatMessages" in $$props) $$invalidate(2, chatMessages = $$props.chatMessages);
    		if ("currentStream" in $$props) $$invalidate(3, currentStream = $$props.currentStream);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Colyseus,
    		get: get_1,
    		fade,
    		fly,
    		Tile,
    		Tag,
    		ClickableTile,
    		users,
    		blackList,
    		chatMessages,
    		currentStream
    	});

    	$$self.$inject_state = $$props => {
    		if ("users" in $$props) $$invalidate(0, users = $$props.users);
    		if ("blackList" in $$props) $$invalidate(1, blackList = $$props.blackList);
    		if ("chatMessages" in $$props) $$invalidate(2, chatMessages = $$props.chatMessages);
    		if ("currentStream" in $$props) $$invalidate(3, currentStream = $$props.currentStream);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [users, blackList, chatMessages, currentStream];
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {
    			users: 0,
    			blackList: 1,
    			chatMessages: 2,
    			currentStream: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get users() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set users(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get blackList() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blackList(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chatMessages() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chatMessages(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentStream() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentStream(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/Bot20/Bot20.svelte generated by Svelte v3.29.0 */

    const file$B = "node_modules/carbon-icons-svelte/lib/Bot20/Bot20.svelte";

    // (39:4) {#if title}
    function create_if_block$p(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$B, 39, 6, 1300);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$g(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$g.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$g(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "Bot20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M18 10H20V12H18zM12 10H14V12H12z");
    			add_location(path0, file$B, 36, 2, 943);
    			attr_dev(path1, "d", "M26,20H21V18h1a2.0023,2.0023,0,0,0,2-2V12h2V10H24V8a2.0023,2.0023,0,0,0-2-2H20V2H18V6H14V2H12V6H10A2.0023,2.0023,0,0,0,8,8v2H6v2H8v4a2.0023,2.0023,0,0,0,2,2h1v2H6a2.0023,2.0023,0,0,0-2,2v8H6V22H26v8h2V22A2.0023,2.0023,0,0,0,26,20ZM10,8H22v8H10Zm3,10h6v2H13Z");
    			add_location(path1, file$B, 36, 52, 993);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$B, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "Bot20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Bot20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class Bot20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Bot20",
    			options,
    			id: create_fragment$F.name
    		});
    	}

    	get class() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Bot20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Bot20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/User20/User20.svelte generated by Svelte v3.29.0 */

    const file$C = "node_modules/carbon-icons-svelte/lib/User20/User20.svelte";

    // (39:4) {#if title}
    function create_if_block$q(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$C, 39, 6, 1129);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$h(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$h.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$h(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "User20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M16 4a5 5 0 11-5 5 5 5 0 015-5m0-2a7 7 0 107 7A7 7 0 0016 2zM26 30H24V25a5 5 0 00-5-5H13a5 5 0 00-5 5v5H6V25a7 7 0 017-7h6a7 7 0 017 7z");
    			add_location(path, file$C, 36, 2, 944);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$C, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "User20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("User20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class User20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "User20",
    			options,
    			id: create_fragment$G.name
    		});
    	}

    	get class() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<User20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<User20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/UserAdmin20/UserAdmin20.svelte generated by Svelte v3.29.0 */

    const file$D = "node_modules/carbon-icons-svelte/lib/UserAdmin20/UserAdmin20.svelte";

    // (39:4) {#if title}
    function create_if_block$r(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$D, 39, 6, 1193);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$i.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$i(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "UserAdmin20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M12 4A5 5 0 117 9a5 5 0 015-5m0-2a7 7 0 107 7A7 7 0 0012 2zM22 30H20V25a5 5 0 00-5-5H9a5 5 0 00-5 5v5H2V25a7 7 0 017-7h6a7 7 0 017 7zM25 16.18L22.41 13.59 21 15 25 19 32 12 30.59 10.59 25 16.18z");
    			add_location(path, file$D, 36, 2, 949);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$D, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "UserAdmin20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserAdmin20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class UserAdmin20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserAdmin20",
    			options,
    			id: create_fragment$H.name
    		});
    	}

    	get class() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<UserAdmin20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<UserAdmin20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/Checkmark20/Checkmark20.svelte generated by Svelte v3.29.0 */

    const file$E = "node_modules/carbon-icons-svelte/lib/Checkmark20/Checkmark20.svelte";

    // (39:4) {#if title}
    function create_if_block$s(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$E, 39, 6, 1138);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$j(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$j.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let svg;
    	let path0;
    	let path1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$j(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "Checkmark20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 20 20" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path0, "d", "M8 13.2L3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z");
    			add_location(path0, file$E, 36, 2, 949);
    			attr_dev(path1, "d", "M15.6 5.6L8 13.2 3.6 8.8 2.7 9.7 7.1 14.1 8 15 16.5 6.5 15.6 5.6z");
    			add_location(path1, file$E, 36, 76, 1023);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$E, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path0);
    			append_dev(svg, path1);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "Checkmark20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 20 20" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Checkmark20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class Checkmark20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkmark20",
    			options,
    			id: create_fragment$I.name
    		});
    	}

    	get class() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Checkmark20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Checkmark20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/carbon-icons-svelte/lib/ShoppingBag20/ShoppingBag20.svelte generated by Svelte v3.29.0 */

    const file$F = "node_modules/carbon-icons-svelte/lib/ShoppingBag20/ShoppingBag20.svelte";

    // (39:4) {#if title}
    function create_if_block$t(ctx) {
    	let title_1;
    	let t;

    	const block = {
    		c: function create() {
    			title_1 = svg_element("title");
    			t = text(/*title*/ ctx[2]);
    			add_location(title_1, file$F, 39, 6, 1236);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, title_1, anchor);
    			append_dev(title_1, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 4) set_data_dev(t, /*title*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(title_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(39:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (38:8)      
    function fallback_block$k(ctx) {
    	let if_block_anchor;
    	let if_block = /*title*/ ctx[2] && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*title*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block$k.name,
    		type: "fallback",
    		source: "(38:8)      ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let svg;
    	let path;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
    	const default_slot_or_fallback = default_slot || fallback_block$k(ctx);

    	let svg_levels = [
    		{ "data-carbon-icon": "ShoppingBag20" },
    		{ xmlns: "http://www.w3.org/2000/svg" },
    		{ viewBox: "0 0 32 32" },
    		{ fill: "currentColor" },
    		{ width: "20" },
    		{ height: "20" },
    		{ class: /*className*/ ctx[0] },
    		{ preserveAspectRatio: "xMidYMid meet" },
    		{ style: /*style*/ ctx[3] },
    		{ id: /*id*/ ctx[1] },
    		/*attributes*/ ctx[4]
    	];

    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			attr_dev(path, "d", "M28.76,11.35A1,1,0,0,0,28,11H22V7a3,3,0,0,0-3-3H13a3,3,0,0,0-3,3v4H4a1,1,0,0,0-1,1.15L4.88,24.3a2,2,0,0,0,2,1.7H25.14a2,2,0,0,0,2-1.7L29,12.15A1,1,0,0,0,28.76,11.35ZM12,7a1,1,0,0,1,1-1h6a1,1,0,0,1,1,1v4H12ZM25.14,24H6.86L5.17,13H26.83Z");
    			add_location(path, file$F, 36, 2, 951);
    			set_svg_attributes(svg, svg_data);
    			add_location(svg, file$F, 22, 0, 633);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svg, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(svg, "click", /*click_handler*/ ctx[9], false, false, false),
    					listen_dev(svg, "mouseover", /*mouseover_handler*/ ctx[10], false, false, false),
    					listen_dev(svg, "mouseenter", /*mouseenter_handler*/ ctx[11], false, false, false),
    					listen_dev(svg, "mouseleave", /*mouseleave_handler*/ ctx[12], false, false, false),
    					listen_dev(svg, "keyup", /*keyup_handler*/ ctx[13], false, false, false),
    					listen_dev(svg, "keydown", /*keydown_handler*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			} else {
    				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty & /*title*/ 4) {
    					default_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [
    				{ "data-carbon-icon": "ShoppingBag20" },
    				{ xmlns: "http://www.w3.org/2000/svg" },
    				{ viewBox: "0 0 32 32" },
    				{ fill: "currentColor" },
    				{ width: "20" },
    				{ height: "20" },
    				(!current || dirty & /*className*/ 1) && { class: /*className*/ ctx[0] },
    				{ preserveAspectRatio: "xMidYMid meet" },
    				(!current || dirty & /*style*/ 8) && { style: /*style*/ ctx[3] },
    				(!current || dirty & /*id*/ 2) && { id: /*id*/ ctx[1] },
    				dirty & /*attributes*/ 16 && /*attributes*/ ctx[4]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ShoppingBag20", slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { id = undefined } = $$props;
    	let { tabindex = undefined } = $$props;
    	let { focusable = false } = $$props;
    	let { title = undefined } = $$props;
    	let { style = undefined } = $$props;

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseover_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseenter_handler(event) {
    		bubble($$self, event);
    	}

    	function mouseleave_handler(event) {
    		bubble($$self, event);
    	}

    	function keyup_handler(event) {
    		bubble($$self, event);
    	}

    	function keydown_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("id" in $$new_props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$new_props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$new_props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$new_props) $$invalidate(3, style = $$new_props.style);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		className,
    		id,
    		tabindex,
    		focusable,
    		title,
    		style,
    		ariaLabel,
    		ariaLabelledBy,
    		labelled,
    		attributes
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(18, $$props = assign(assign({}, $$props), $$new_props));
    		if ("className" in $$props) $$invalidate(0, className = $$new_props.className);
    		if ("id" in $$props) $$invalidate(1, id = $$new_props.id);
    		if ("tabindex" in $$props) $$invalidate(5, tabindex = $$new_props.tabindex);
    		if ("focusable" in $$props) $$invalidate(6, focusable = $$new_props.focusable);
    		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
    		if ("style" in $$props) $$invalidate(3, style = $$new_props.style);
    		if ("ariaLabel" in $$props) $$invalidate(15, ariaLabel = $$new_props.ariaLabel);
    		if ("ariaLabelledBy" in $$props) $$invalidate(16, ariaLabelledBy = $$new_props.ariaLabelledBy);
    		if ("labelled" in $$props) $$invalidate(17, labelled = $$new_props.labelled);
    		if ("attributes" in $$props) $$invalidate(4, attributes = $$new_props.attributes);
    	};

    	let ariaLabel;
    	let ariaLabelledBy;
    	let labelled;
    	let attributes;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		 $$invalidate(15, ariaLabel = $$props["aria-label"]);
    		 $$invalidate(16, ariaLabelledBy = $$props["aria-labelledby"]);

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, title*/ 98308) {
    			 $$invalidate(17, labelled = ariaLabel || ariaLabelledBy || title);
    		}

    		if ($$self.$$.dirty & /*ariaLabel, ariaLabelledBy, labelled, tabindex, focusable*/ 229472) {
    			 $$invalidate(4, attributes = {
    				"aria-label": ariaLabel,
    				"aria-labelledby": ariaLabelledBy,
    				"aria-hidden": labelled ? undefined : true,
    				role: labelled ? "img" : undefined,
    				focusable: tabindex === "0" ? true : focusable,
    				tabindex
    			});
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		className,
    		id,
    		title,
    		style,
    		attributes,
    		tabindex,
    		focusable,
    		$$scope,
    		slots,
    		click_handler,
    		mouseover_handler,
    		mouseenter_handler,
    		mouseleave_handler,
    		keyup_handler,
    		keydown_handler
    	];
    }

    class ShoppingBag20 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
    			class: 0,
    			id: 1,
    			tabindex: 5,
    			focusable: 6,
    			title: 2,
    			style: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ShoppingBag20",
    			options,
    			id: create_fragment$J.name
    		});
    	}

    	get class() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tabindex() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tabindex(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get focusable() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set focusable(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<ShoppingBag20>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<ShoppingBag20>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // WRITABLE
    const gameRoom = writable({});
    const chatRoom = writable({});

    /* src/UserItem.svelte generated by Svelte v3.29.0 */

    const file$G = "src/UserItem.svelte";

    // (80:4) {:else}
    function create_else_block$5(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(80:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:33) 
    function create_if_block_2$3(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(76:33) ",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if user.npc}
    function create_if_block_1$8(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "grey",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(72:4) {#if user.npc}",
    		ctx
    	});

    	return block;
    }

    // (81:6) <Tag type="grey">
    function create_default_slot_3$1(ctx) {
    	let user20;
    	let current;

    	user20 = new User20({
    			props: { style: "fill: grey" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(user20.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(user20, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(user20.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(user20.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(user20, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(81:6) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (77:6) <Tag type="grey">
    function create_default_slot_2$1(ctx) {
    	let useradmin20;
    	let current;

    	useradmin20 = new UserAdmin20({
    			props: { style: "fill: grey" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useradmin20.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useradmin20, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useradmin20.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useradmin20.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useradmin20, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(77:6) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:6) <Tag type="grey">
    function create_default_slot_1$1(ctx) {
    	let bot20;
    	let current;

    	bot20 = new Bot20({
    			props: { style: "fill: grey" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(bot20.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bot20, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bot20.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bot20.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bot20, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(73:6) <Tag type=\\\"grey\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:4) {#if !user.npc}
    function create_if_block$u(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				size: "small",
    				kind: "danger",
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*addToBlackList*/ ctx[2]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(98:4) {#if !user.npc}",
    		ctx
    	});

    	return block;
    }

    // (99:6) <Button size="small" kind="danger" on:click={addToBlackList}>
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Ban IP address");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(99:6) <Button size=\\\"small\\\" kind=\\\"danger\\\" on:click={addToBlackList}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div6;
    	let div0;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let div1;
    	let t1_value = /*user*/ ctx[0].name + "";
    	let t1;
    	let t2;
    	let div2;
    	let t3_value = /*user*/ ctx[0].x + "";
    	let t3;
    	let t4;
    	let t5_value = /*user*/ ctx[0].y + "";
    	let t5;
    	let t6;
    	let div3;
    	let t7;
    	let t8;
    	let div4;
    	let t9_value = /*user*/ ctx[0].ip.replace("::ffff:", "") + "";
    	let t9;
    	let t10;
    	let div5;
    	let div6_transition;
    	let current;
    	const if_block_creators = [create_if_block_1$8, create_if_block_2$3, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*user*/ ctx[0].npc) return 0;
    		if (/*user*/ ctx[0].authenticated) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = !/*user*/ ctx[0].npc && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(t3_value);
    			t4 = text(", ");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");
    			t7 = text(/*userArea*/ ctx[1]);
    			t8 = space();
    			div4 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			div5 = element("div");
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "small svelte-e55lg2");
    			add_location(div0, file$G, 70, 2, 1608);
    			attr_dev(div1, "class", "marked large svelte-e55lg2");
    			add_location(div1, file$G, 85, 2, 1943);
    			attr_dev(div2, "class", "svelte-e55lg2");
    			add_location(div2, file$G, 86, 2, 1989);
    			attr_dev(div3, "class", "svelte-e55lg2");
    			add_location(div3, file$G, 87, 2, 2021);
    			attr_dev(div4, "class", "svelte-e55lg2");
    			add_location(div4, file$G, 95, 2, 2182);
    			attr_dev(div5, "class", "large svelte-e55lg2");
    			add_location(div5, file$G, 96, 2, 2228);
    			attr_dev(div6, "class", "user-item svelte-e55lg2");
    			add_location(div6, file$G, 69, 0, 1560);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div6, t0);
    			append_dev(div6, div1);
    			append_dev(div1, t1);
    			append_dev(div6, t2);
    			append_dev(div6, div2);
    			append_dev(div2, t3);
    			append_dev(div2, t4);
    			append_dev(div2, t5);
    			append_dev(div6, t6);
    			append_dev(div6, div3);
    			append_dev(div3, t7);
    			append_dev(div6, t8);
    			append_dev(div6, div4);
    			append_dev(div4, t9);
    			append_dev(div6, t10);
    			append_dev(div6, div5);
    			if (if_block1) if_block1.m(div5, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div0, null);
    			}

    			if ((!current || dirty & /*user*/ 1) && t1_value !== (t1_value = /*user*/ ctx[0].name + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*user*/ 1) && t3_value !== (t3_value = /*user*/ ctx[0].x + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*user*/ 1) && t5_value !== (t5_value = /*user*/ ctx[0].y + "")) set_data_dev(t5, t5_value);
    			if (!current || dirty & /*userArea*/ 2) set_data_dev(t7, /*userArea*/ ctx[1]);
    			if ((!current || dirty & /*user*/ 1) && t9_value !== (t9_value = /*user*/ ctx[0].ip.replace("::ffff:", "") + "")) set_data_dev(t9, t9_value);

    			if (!/*user*/ ctx[0].npc) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*user*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$u(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div5, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);

    			if (local) {
    				add_render_callback(() => {
    					if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fade, {}, true);
    					div6_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);

    			if (local) {
    				if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fade, {}, false);
    				div6_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			if (detaching && div6_transition) div6_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $gameRoom;
    	validate_store(gameRoom, "gameRoom");
    	component_subscribe($$self, gameRoom, $$value => $$invalidate(4, $gameRoom = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserItem", slots, []);
    	let { user = {} } = $$props;
    	let { areas = [] } = $$props;

    	const addToBlackList = () => {
    		$gameRoom.send("blacklist", { address: user.ip });
    	};

    	// console.dir(user)
    	// console.dir(areas)
    	let userArea = "";

    	const writable_props = ["user", "areas"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UserItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("user" in $$props) $$invalidate(0, user = $$props.user);
    		if ("areas" in $$props) $$invalidate(3, areas = $$props.areas);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Bot20,
    		User20,
    		UserAdmin20,
    		Checkmark20,
    		ShoppingBag20,
    		Button,
    		Tag,
    		user,
    		areas,
    		gameRoom,
    		addToBlackList,
    		userArea,
    		$gameRoom
    	});

    	$$self.$inject_state = $$props => {
    		if ("user" in $$props) $$invalidate(0, user = $$props.user);
    		if ("areas" in $$props) $$invalidate(3, areas = $$props.areas);
    		if ("userArea" in $$props) $$invalidate(1, userArea = $$props.userArea);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*areas, user*/ 9) {
    			 {
    				let tempArea = areas.find(a => a.areaIndex === user.area);

    				// console.log(tempArea)
    				$$invalidate(1, userArea = tempArea && tempArea.title ? tempArea.title : "");
    			}
    		}
    	};

    	return [user, userArea, addToBlackList, areas];
    }

    class UserItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { user: 0, areas: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserItem",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get user() {
    		throw new Error("<UserItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set user(value) {
    		throw new Error("<UserItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get areas() {
    		throw new Error("<UserItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set areas(value) {
    		throw new Error("<UserItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Users.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$1 } = globals;
    const file$H = "src/Users.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (36:2) <Tile>
    function create_default_slot_5$1(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Users";
    			add_location(h1, file$H, 36, 4, 681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(36:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (40:4) <Tag type="green">
    function create_default_slot_4$1(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Users: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(40:4) <Tag type=\\\"green\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:4) <Tag type="gray">
    function create_default_slot_3$2(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func$1).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Accredited:\n      ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func$1).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(41:4) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:4) <Tag type="gray">
    function create_default_slot_2$2(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func_1$1).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Guests:\n      ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func_1$1).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(45:4) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:4) <Tag type="gray">
    function create_default_slot_1$2(ctx) {
    	let t0;
    	let t1_value = Object.values(/*users*/ ctx[0]).filter(func_2$1).length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("NPCs:\n      ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 1 && t1_value !== (t1_value = Object.values(/*users*/ ctx[0]).filter(func_2$1).length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(49:4) <Tag type=\\\"gray\\\">",
    		ctx
    	});

    	return block;
    }

    // (39:2) <Tile>
    function create_default_slot$3(ctx) {
    	let tag0;
    	let t0;
    	let tag1;
    	let t1;
    	let tag2;
    	let t2;
    	let tag3;
    	let current;

    	tag0 = new Tag({
    			props: {
    				type: "green",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag1 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag2 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tag3 = new Tag({
    			props: {
    				type: "gray",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag0.$$.fragment);
    			t0 = space();
    			create_component(tag1.$$.fragment);
    			t1 = space();
    			create_component(tag2.$$.fragment);
    			t2 = space();
    			create_component(tag3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tag1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tag2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tag3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag0_changes = {};

    			if (dirty & /*$$scope, users*/ 33) {
    				tag0_changes.$$scope = { dirty, ctx };
    			}

    			tag0.$set(tag0_changes);
    			const tag1_changes = {};

    			if (dirty & /*$$scope, users*/ 33) {
    				tag1_changes.$$scope = { dirty, ctx };
    			}

    			tag1.$set(tag1_changes);
    			const tag2_changes = {};

    			if (dirty & /*$$scope, users*/ 33) {
    				tag2_changes.$$scope = { dirty, ctx };
    			}

    			tag2.$set(tag2_changes);
    			const tag3_changes = {};

    			if (dirty & /*$$scope, users*/ 33) {
    				tag3_changes.$$scope = { dirty, ctx };
    			}

    			tag3.$set(tag3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag0.$$.fragment, local);
    			transition_in(tag1.$$.fragment, local);
    			transition_in(tag2.$$.fragment, local);
    			transition_in(tag3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag0.$$.fragment, local);
    			transition_out(tag1.$$.fragment, local);
    			transition_out(tag2.$$.fragment, local);
    			transition_out(tag3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tag1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tag2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tag3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(39:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (54:2) {#each Object.values(users).reverse() as user}
    function create_each_block(ctx) {
    	let useritem;
    	let current;

    	useritem = new UserItem({
    			props: {
    				user: /*user*/ ctx[2],
    				areas: /*areas*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(useritem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(useritem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const useritem_changes = {};
    			if (dirty & /*users*/ 1) useritem_changes.user = /*user*/ ctx[2];
    			if (dirty & /*areas*/ 2) useritem_changes.areas = /*areas*/ ctx[1];
    			useritem.$set(useritem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(useritem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(useritem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(useritem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(54:2) {#each Object.values(users).reverse() as user}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div;
    	let tile0;
    	let t0;
    	let tile1;
    	let t1;
    	let current;

    	tile0 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tile1 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = Object.values(/*users*/ ctx[0]).reverse();
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tile0.$$.fragment);
    			t0 = space();
    			create_component(tile1.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "users");
    			add_location(div, file$H, 34, 0, 648);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tile0, div, null);
    			append_dev(div, t0);
    			mount_component(tile1, div, null);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile0_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				tile0_changes.$$scope = { dirty, ctx };
    			}

    			tile0.$set(tile0_changes);
    			const tile1_changes = {};

    			if (dirty & /*$$scope, users*/ 33) {
    				tile1_changes.$$scope = { dirty, ctx };
    			}

    			tile1.$set(tile1_changes);

    			if (dirty & /*Object, users, areas*/ 3) {
    				each_value = Object.values(/*users*/ ctx[0]).reverse();
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile0.$$.fragment, local);
    			transition_in(tile1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile0.$$.fragment, local);
    			transition_out(tile1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tile0);
    			destroy_component(tile1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = u => u.authenticated;
    const func_1$1 = u => !u.npc && !u.authenticated;
    const func_2$1 = u => u.npc;

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Users", slots, []);
    	let { users = [] } = $$props;
    	let { areas = [] } = $$props;
    	const writable_props = ["users", "areas"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Users> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("users" in $$props) $$invalidate(0, users = $$props.users);
    		if ("areas" in $$props) $$invalidate(1, areas = $$props.areas);
    	};

    	$$self.$capture_state = () => ({ UserItem, Tile, Tag, users, areas });

    	$$self.$inject_state = $$props => {
    		if ("users" in $$props) $$invalidate(0, users = $$props.users);
    		if ("areas" in $$props) $$invalidate(1, areas = $$props.areas);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [users, areas];
    }

    class Users extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { users: 0, areas: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Users",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get users() {
    		throw new Error("<Users>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set users(value) {
    		throw new Error("<Users>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get areas() {
    		throw new Error("<Users>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set areas(value) {
    		throw new Error("<Users>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/ChatMessage.svelte generated by Svelte v3.29.0 */

    const file$I = "src/ChatMessage.svelte";

    // (80:8) <Button size="small" kind="danger" on:click={removeMessage}>
    function create_default_slot_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Remove");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(80:8) <Button size=\\\"small\\\" kind=\\\"danger\\\" on:click={removeMessage}>",
    		ctx
    	});

    	return block;
    }

    // (70:2) <Tile>
    function create_default_slot$4(ctx) {
    	let div5;
    	let div3;
    	let div0;
    	let code;
    	let t0_value = formattedDate(/*message*/ ctx[0].timestamp) + "";
    	let t0;
    	let t1;

    	let t2_value = (/*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo !== "all"
    	? /*message*/ ctx[0].directedTo
    	: /*message*/ ctx[0].room) + "";

    	let t2;
    	let t3;
    	let div1;
    	let strong;
    	let t4_value = /*message*/ ctx[0].name + "";
    	let t4;
    	let t5;
    	let div2;
    	let t6_value = /*message*/ ctx[0].text + "";
    	let t6;
    	let t7;
    	let div4;
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				size: "small",
    				kind: "danger",
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*removeMessage*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			code = element("code");
    			t0 = text(t0_value);
    			t1 = text(" => Room ");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			strong = element("strong");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(code, "class", "svelte-zflhuu");
    			add_location(code, file$I, 73, 10, 1568);
    			attr_dev(div0, "class", "date svelte-zflhuu");
    			add_location(div0, file$I, 72, 8, 1539);
    			add_location(strong, file$I, 75, 26, 1754);
    			attr_dev(div1, "class", "name svelte-zflhuu");
    			add_location(div1, file$I, 75, 8, 1736);
    			attr_dev(div2, "class", "body svelte-zflhuu");
    			add_location(div2, file$I, 76, 8, 1800);
    			attr_dev(div3, "class", "meta svelte-zflhuu");
    			add_location(div3, file$I, 71, 6, 1512);
    			add_location(div4, file$I, 78, 6, 1858);
    			attr_dev(div5, "class", "container svelte-zflhuu");
    			toggle_class(div5, "broadcast", /*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo === "all");
    			toggle_class(div5, "narrowcast", /*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo !== "all");
    			add_location(div5, file$I, 70, 4, 1346);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div3);
    			append_dev(div3, div0);
    			append_dev(div0, code);
    			append_dev(code, t0);
    			append_dev(code, t1);
    			append_dev(code, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, strong);
    			append_dev(strong, t4);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, t6);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			mount_component(button, div4, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*message*/ 1) && t0_value !== (t0_value = formattedDate(/*message*/ ctx[0].timestamp) + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*message*/ 1) && t2_value !== (t2_value = (/*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo !== "all"
    			? /*message*/ ctx[0].directedTo
    			: /*message*/ ctx[0].room) + "")) set_data_dev(t2, t2_value);

    			if ((!current || dirty & /*message*/ 1) && t4_value !== (t4_value = /*message*/ ctx[0].name + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty & /*message*/ 1) && t6_value !== (t6_value = /*message*/ ctx[0].text + "")) set_data_dev(t6, t6_value);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (dirty & /*message*/ 1) {
    				toggle_class(div5, "broadcast", /*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo === "all");
    			}

    			if (dirty & /*message*/ 1) {
    				toggle_class(div5, "narrowcast", /*message*/ ctx[0].directed && /*message*/ ctx[0].directedTo !== "all");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(70:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div;
    	let tile;
    	let div_transition;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tile.$$.fragment);
    			add_location(div, file$I, 68, 0, 1305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tile, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile_changes = {};

    			if (dirty & /*$$scope, message*/ 17) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {}, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tile);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $gameRoom;
    	validate_store(gameRoom, "gameRoom");
    	component_subscribe($$self, gameRoom, $$value => $$invalidate(3, $gameRoom = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ChatMessage", slots, []);
    	let { message = {} } = $$props;

    	// console.dir(message)
    	// VARIABLES
    	let removed = false;

    	const removeMessage = () => {
    		// console.log("__ CLICKED TO REMOVE REMOVE =>", message.msgId, message)
    		$gameRoom.send("removeChatMessage", { msgId: message.msgId });

    		removed = true;
    	};

    	const writable_props = ["message"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChatMessage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		get: get_1,
    		Button,
    		Tile,
    		formattedDate,
    		message,
    		gameRoom,
    		removed,
    		removeMessage,
    		$gameRoom
    	});

    	$$self.$inject_state = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("removed" in $$props) removed = $$props.removed;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [message, removeMessage];
    }

    class ChatMessage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { message: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChatMessage",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get message() {
    		throw new Error("<ChatMessage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<ChatMessage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Textchat.svelte generated by Svelte v3.29.0 */

    const { console: console_1$1 } = globals;
    const file$J = "src/Textchat.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (60:8) {#each users as user (user._id)}
    function create_each_block_5(key_1, ctx) {
    	let first;
    	let selectitem;
    	let current;

    	selectitem = new SelectItem({
    			props: {
    				value: /*user*/ ctx[19].username,
    				text: /*user*/ ctx[19].name
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(selectitem.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(selectitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const selectitem_changes = {};
    			if (dirty & /*users*/ 2) selectitem_changes.value = /*user*/ ctx[19].username;
    			if (dirty & /*users*/ 2) selectitem_changes.text = /*user*/ ctx[19].name;
    			selectitem.$set(selectitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(selectitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(60:8) {#each users as user (user._id)}",
    		ctx
    	});

    	return block;
    }

    // (58:6) <Select id="select-1" labelText="Recipient" bind:selected={recipient}>
    function create_default_slot_17(ctx) {
    	let selectitem;
    	let t;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;

    	selectitem = new SelectItem({
    			props: {
    				value: "all",
    				text: "All accredited users"
    			},
    			$$inline: true
    		});

    	let each_value_5 = /*users*/ ctx[1];
    	validate_each_argument(each_value_5);
    	const get_key = ctx => /*user*/ ctx[19]._id;
    	validate_each_keys(ctx, each_value_5, get_each_context_5, get_key);

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		let child_ctx = get_each_context_5(ctx, each_value_5, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_5(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			create_component(selectitem.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectitem, target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*users*/ 2) {
    				const each_value_5 = /*users*/ ctx[1];
    				validate_each_argument(each_value_5);
    				group_outros();
    				validate_each_keys(ctx, each_value_5, get_each_context_5, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_5, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_5, each_1_anchor, get_each_context_5);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectitem.$$.fragment, local);

    			for (let i = 0; i < each_value_5.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectitem.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectitem, detaching);
    			if (detaching) detach_dev(t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(58:6) <Select id=\\\"select-1\\\" labelText=\\\"Recipient\\\" bind:selected={recipient}>",
    		ctx
    	});

    	return block;
    }

    // (57:4) <FormGroup>
    function create_default_slot_16$1(ctx) {
    	let select;
    	let updating_selected;
    	let current;

    	function select_selected_binding(value) {
    		/*select_selected_binding*/ ctx[6].call(null, value);
    	}

    	let select_props = {
    		id: "select-1",
    		labelText: "Recipient",
    		$$slots: { default: [create_default_slot_17] },
    		$$scope: { ctx }
    	};

    	if (/*recipient*/ ctx[3] !== void 0) {
    		select_props.selected = /*recipient*/ ctx[3];
    	}

    	select = new Select({ props: select_props, $$inline: true });
    	binding_callbacks.push(() => bind(select, "selected", select_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(select.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(select, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const select_changes = {};

    			if (dirty & /*$$scope, users*/ 4194306) {
    				select_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_selected && dirty & /*recipient*/ 8) {
    				updating_selected = true;
    				select_changes.selected = /*recipient*/ ctx[3];
    				add_flush_callback(() => updating_selected = false);
    			}

    			select.$set(select_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(select, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16$1.name,
    		type: "slot",
    		source: "(57:4) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (65:4) <FormGroup>
    function create_default_slot_15$1(ctx) {
    	let textarea;
    	let updating_value;
    	let current;

    	function textarea_value_binding(value) {
    		/*textarea_value_binding*/ ctx[7].call(null, value);
    	}

    	let textarea_props = {
    		labelText: "Message",
    		placeholder: "Enter a message..."
    	};

    	if (/*message*/ ctx[4] !== void 0) {
    		textarea_props.value = /*message*/ ctx[4];
    	}

    	textarea = new TextArea({ props: textarea_props, $$inline: true });
    	binding_callbacks.push(() => bind(textarea, "value", textarea_value_binding));

    	const block = {
    		c: function create() {
    			create_component(textarea.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textarea, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textarea_changes = {};

    			if (!updating_value && dirty & /*message*/ 16) {
    				updating_value = true;
    				textarea_changes.value = /*message*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			textarea.$set(textarea_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textarea.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textarea.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textarea, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$1.name,
    		type: "slot",
    		source: "(65:4) <FormGroup>",
    		ctx
    	});

    	return block;
    }

    // (68:4) <Button type="submit">
    function create_default_slot_14$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Send");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$1.name,
    		type: "slot",
    		source: "(68:4) <Button type=\\\"submit\\\">",
    		ctx
    	});

    	return block;
    }

    // (69:4) {#if messageSent}
    function create_if_block_5$2(ctx) {
    	let inlinenotification;
    	let current;

    	inlinenotification = new InlineNotification({
    			props: { kind: "success", title: "Message sent" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(inlinenotification.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(inlinenotification, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inlinenotification.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inlinenotification.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inlinenotification, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(69:4) {#if messageSent}",
    		ctx
    	});

    	return block;
    }

    // (56:2) <Form on:submit={sendMessage}>
    function create_default_slot_13$1(ctx) {
    	let formgroup0;
    	let t0;
    	let formgroup1;
    	let t1;
    	let button;
    	let t2;
    	let if_block_anchor;
    	let current;

    	formgroup0 = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_16$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	formgroup1 = new FormGroup({
    			props: {
    				$$slots: { default: [create_default_slot_15$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button = new Button({
    			props: {
    				type: "submit",
    				$$slots: { default: [create_default_slot_14$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*messageSent*/ ctx[2] && create_if_block_5$2(ctx);

    	const block = {
    		c: function create() {
    			create_component(formgroup0.$$.fragment);
    			t0 = space();
    			create_component(formgroup1.$$.fragment);
    			t1 = space();
    			create_component(button.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(formgroup0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(formgroup1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(button, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formgroup0_changes = {};

    			if (dirty & /*$$scope, recipient, users*/ 4194314) {
    				formgroup0_changes.$$scope = { dirty, ctx };
    			}

    			formgroup0.$set(formgroup0_changes);
    			const formgroup1_changes = {};

    			if (dirty & /*$$scope, message*/ 4194320) {
    				formgroup1_changes.$$scope = { dirty, ctx };
    			}

    			formgroup1.$set(formgroup1_changes);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*messageSent*/ ctx[2]) {
    				if (if_block) {
    					if (dirty & /*messageSent*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formgroup0.$$.fragment, local);
    			transition_in(formgroup1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formgroup0.$$.fragment, local);
    			transition_out(formgroup1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formgroup0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(formgroup1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$1.name,
    		type: "slot",
    		source: "(56:2) <Form on:submit={sendMessage}>",
    		ctx
    	});

    	return block;
    }

    // (54:0) <Tile>
    function create_default_slot_12$1(ctx) {
    	let h1;
    	let t1;
    	let form;
    	let current;

    	form = new Form({
    			props: {
    				$$slots: { default: [create_default_slot_13$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	form.$on("submit", /*sendMessage*/ ctx[5]);

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Send message";
    			t1 = space();
    			create_component(form.$$.fragment);
    			add_location(h1, file$J, 54, 2, 941);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(form, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const form_changes = {};

    			if (dirty & /*$$scope, messageSent, message, recipient, users*/ 4194334) {
    				form_changes.$$scope = { dirty, ctx };
    			}

    			form.$set(form_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(form.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(form.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			destroy_component(form, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$1.name,
    		type: "slot",
    		source: "(54:0) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (77:0) <Tile>
    function create_default_slot_11$1(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Chatrooms (text)";
    			add_location(h1, file$J, 77, 2, 1626);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$1.name,
    		type: "slot",
    		source: "(77:0) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (92:6) {:else}
    function create_else_block_4(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_10$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(92:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (88:6) {#if chatMessages.length > 0}
    function create_if_block_4$2(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_4 = /*chatMessages*/ ctx[0];
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 1) {
    				each_value_4 = /*chatMessages*/ ctx[0];
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_4.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(88:6) {#if chatMessages.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (93:8) <Tile>
    function create_default_slot_10$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No messages");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$1.name,
    		type: "slot",
    		source: "(93:8) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (89:8) {#each chatMessages as message}
    function create_each_block_4(ctx) {
    	let chatmessage;
    	let current;

    	chatmessage = new ChatMessage({
    			props: { message: /*message*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatmessage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chatmessage_changes = {};
    			if (dirty & /*chatMessages*/ 1) chatmessage_changes.message = /*message*/ ctx[4];
    			chatmessage.$set(chatmessage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(89:8) {#each chatMessages as message}",
    		ctx
    	});

    	return block;
    }

    // (87:4) <TabContent>
    function create_default_slot_9$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4$2, create_else_block_4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*chatMessages*/ ctx[0].length > 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$1.name,
    		type: "slot",
    		source: "(87:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (101:6) {:else}
    function create_else_block_3(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(101:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (97:6) {#if chatMessages.filter(m => m.room === 1).length > 0}
    function create_if_block_3$3(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_3 = /*chatMessages*/ ctx[0].filter(func_4$1);
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 1) {
    				each_value_3 = /*chatMessages*/ ctx[0].filter(func_4$1);
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(97:6) {#if chatMessages.filter(m => m.room === 1).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (102:8) <Tile>
    function create_default_slot_8$1(ctx) {
    	let t0;
    	let strong;

    	const block = {
    		c: function create() {
    			t0 = text("No messages in ");
    			strong = element("strong");
    			strong.textContent = "Room 1";
    			add_location(strong, file$J, 101, 29, 2271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, strong, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(strong);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(102:8) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (98:8) {#each chatMessages.filter(m => m.room === 1) as message}
    function create_each_block_3(ctx) {
    	let chatmessage;
    	let current;

    	chatmessage = new ChatMessage({
    			props: { message: /*message*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatmessage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chatmessage_changes = {};
    			if (dirty & /*chatMessages*/ 1) chatmessage_changes.message = /*message*/ ctx[4];
    			chatmessage.$set(chatmessage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(98:8) {#each chatMessages.filter(m => m.room === 1) as message}",
    		ctx
    	});

    	return block;
    }

    // (96:4) <TabContent>
    function create_default_slot_7$1(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_3$3, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*chatMessages*/ 1) show_if = !!(/*chatMessages*/ ctx[0].filter(func_3$1).length > 0);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(96:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (110:6) {:else}
    function create_else_block_2(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_6$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(110:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (106:6) {#if chatMessages.filter(m => m.room === 2).length > 0}
    function create_if_block_2$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*chatMessages*/ ctx[0].filter(func_5$1);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 1) {
    				each_value_2 = /*chatMessages*/ ctx[0].filter(func_5$1);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(106:6) {#if chatMessages.filter(m => m.room === 2).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (111:8) <Tile>
    function create_default_slot_6$1(ctx) {
    	let t0;
    	let strong;

    	const block = {
    		c: function create() {
    			t0 = text("No messages in ");
    			strong = element("strong");
    			strong.textContent = "Room 2";
    			add_location(strong, file$J, 110, 29, 2572);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, strong, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(strong);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(111:8) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (107:8) {#each chatMessages.filter(m => m.room === 2) as message}
    function create_each_block_2(ctx) {
    	let chatmessage;
    	let current;

    	chatmessage = new ChatMessage({
    			props: { message: /*message*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatmessage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chatmessage_changes = {};
    			if (dirty & /*chatMessages*/ 1) chatmessage_changes.message = /*message*/ ctx[4];
    			chatmessage.$set(chatmessage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(107:8) {#each chatMessages.filter(m => m.room === 2) as message}",
    		ctx
    	});

    	return block;
    }

    // (105:4) <TabContent>
    function create_default_slot_5$2(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$4, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (dirty & /*chatMessages*/ 1) show_if = !!(/*chatMessages*/ ctx[0].filter(func_2$2).length > 0);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(105:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (119:6) {:else}
    function create_else_block_1(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(119:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (115:6) {#if chatMessages.filter(m => m.room === 3).length > 0}
    function create_if_block_1$9(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*chatMessages*/ ctx[0].filter(func_6$1);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 1) {
    				each_value_1 = /*chatMessages*/ ctx[0].filter(func_6$1);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(115:6) {#if chatMessages.filter(m => m.room === 3).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (120:8) <Tile>
    function create_default_slot_4$2(ctx) {
    	let t0;
    	let strong;

    	const block = {
    		c: function create() {
    			t0 = text("No messages in ");
    			strong = element("strong");
    			strong.textContent = "Room 3";
    			add_location(strong, file$J, 119, 29, 2873);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, strong, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(strong);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(120:8) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (116:8) {#each chatMessages.filter(m => m.room === 3) as message}
    function create_each_block_1(ctx) {
    	let chatmessage;
    	let current;

    	chatmessage = new ChatMessage({
    			props: { message: /*message*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatmessage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chatmessage_changes = {};
    			if (dirty & /*chatMessages*/ 1) chatmessage_changes.message = /*message*/ ctx[4];
    			chatmessage.$set(chatmessage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(116:8) {#each chatMessages.filter(m => m.room === 3) as message}",
    		ctx
    	});

    	return block;
    }

    // (114:4) <TabContent>
    function create_default_slot_3$3(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$9, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (dirty & /*chatMessages*/ 1) show_if = !!(/*chatMessages*/ ctx[0].filter(func_1$2).length > 0);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(114:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (128:6) {:else}
    function create_else_block$6(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(128:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (124:6) {#if chatMessages.filter(m => m.room === 4).length > 0}
    function create_if_block$v(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*chatMessages*/ ctx[0].filter(func_7);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*chatMessages*/ 1) {
    				each_value = /*chatMessages*/ ctx[0].filter(func_7);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(124:6) {#if chatMessages.filter(m => m.room === 4).length > 0}",
    		ctx
    	});

    	return block;
    }

    // (129:8) <Tile>
    function create_default_slot_2$3(ctx) {
    	let t0;
    	let strong;

    	const block = {
    		c: function create() {
    			t0 = text("No messages in ");
    			strong = element("strong");
    			strong.textContent = "Room 4";
    			add_location(strong, file$J, 128, 29, 3174);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, strong, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(strong);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(129:8) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (125:8) {#each chatMessages.filter(m => m.room === 4) as message}
    function create_each_block$1(ctx) {
    	let chatmessage;
    	let current;

    	chatmessage = new ChatMessage({
    			props: { message: /*message*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(chatmessage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(chatmessage, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const chatmessage_changes = {};
    			if (dirty & /*chatMessages*/ 1) chatmessage_changes.message = /*message*/ ctx[4];
    			chatmessage.$set(chatmessage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(chatmessage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(chatmessage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(chatmessage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(125:8) {#each chatMessages.filter(m => m.room === 4) as message}",
    		ctx
    	});

    	return block;
    }

    // (123:4) <TabContent>
    function create_default_slot_1$4(ctx) {
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$v, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (dirty & /*chatMessages*/ 1) show_if = !!(/*chatMessages*/ ctx[0].filter(func$2).length > 0);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx, -1);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(123:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (86:2) <div slot="content">
    function create_content_slot(ctx) {
    	let div;
    	let tabcontent0;
    	let t0;
    	let tabcontent1;
    	let t1;
    	let tabcontent2;
    	let t2;
    	let tabcontent3;
    	let t3;
    	let tabcontent4;
    	let current;

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_9$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_7$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent3 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent4 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabcontent0.$$.fragment);
    			t0 = space();
    			create_component(tabcontent1.$$.fragment);
    			t1 = space();
    			create_component(tabcontent2.$$.fragment);
    			t2 = space();
    			create_component(tabcontent3.$$.fragment);
    			t3 = space();
    			create_component(tabcontent4.$$.fragment);
    			attr_dev(div, "slot", "content");
    			add_location(div, file$J, 85, 2, 1788);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabcontent0, div, null);
    			append_dev(div, t0);
    			mount_component(tabcontent1, div, null);
    			append_dev(div, t1);
    			mount_component(tabcontent2, div, null);
    			append_dev(div, t2);
    			mount_component(tabcontent3, div, null);
    			append_dev(div, t3);
    			mount_component(tabcontent4, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    			const tabcontent3_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabcontent3_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent3.$set(tabcontent3_changes);
    			const tabcontent4_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabcontent4_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent4.$set(tabcontent4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			transition_in(tabcontent3.$$.fragment, local);
    			transition_in(tabcontent4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			transition_out(tabcontent3.$$.fragment, local);
    			transition_out(tabcontent4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabcontent0);
    			destroy_component(tabcontent1);
    			destroy_component(tabcontent2);
    			destroy_component(tabcontent3);
    			destroy_component(tabcontent4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(86:2) <div slot=\\\"content\\\">",
    		ctx
    	});

    	return block;
    }

    // (80:0) <Tabs type="container">
    function create_default_slot$5(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let t2;
    	let tab3;
    	let t3;
    	let tab4;
    	let t4;
    	let current;
    	tab0 = new Tab({ props: { label: "All" }, $$inline: true });
    	tab1 = new Tab({ props: { label: "1" }, $$inline: true });
    	tab2 = new Tab({ props: { label: "2" }, $$inline: true });
    	tab3 = new Tab({ props: { label: "3" }, $$inline: true });
    	tab4 = new Tab({ props: { label: "4" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    			t2 = space();
    			create_component(tab3.$$.fragment);
    			t3 = space();
    			create_component(tab4.$$.fragment);
    			t4 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tab3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(tab4, target, anchor);
    			insert_dev(target, t4, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			transition_in(tab3.$$.fragment, local);
    			transition_in(tab4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			transition_out(tab3.$$.fragment, local);
    			transition_out(tab4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tab3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(tab4, detaching);
    			if (detaching) detach_dev(t4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(80:0) <Tabs type=\\\"container\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let tile0;
    	let t0;
    	let tile1;
    	let t1;
    	let tabs;
    	let current;

    	tile0 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_12$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tile1 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_11$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs = new Tabs({
    			props: {
    				type: "container",
    				$$slots: {
    					default: [create_default_slot$5],
    					content: [create_content_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile0.$$.fragment);
    			t0 = space();
    			create_component(tile1.$$.fragment);
    			t1 = space();
    			create_component(tabs.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tile1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile0_changes = {};

    			if (dirty & /*$$scope, messageSent, message, recipient, users*/ 4194334) {
    				tile0_changes.$$scope = { dirty, ctx };
    			}

    			tile0.$set(tile0_changes);
    			const tile1_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				tile1_changes.$$scope = { dirty, ctx };
    			}

    			tile1.$set(tile1_changes);
    			const tabs_changes = {};

    			if (dirty & /*$$scope, chatMessages*/ 4194305) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile0.$$.fragment, local);
    			transition_in(tile1.$$.fragment, local);
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile0.$$.fragment, local);
    			transition_out(tile1.$$.fragment, local);
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tile1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$2 = m => m.room === 4;
    const func_1$2 = m => m.room === 3;
    const func_2$2 = m => m.room === 2;
    const func_3$1 = m => m.room === 1;
    const func_4$1 = m => m.room === 1;
    const func_5$1 = m => m.room === 2;
    const func_6$1 = m => m.room === 3;
    const func_7 = m => m.room === 4;

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Textchat", slots, []);
    	const dispatch = createEventDispatcher();
    	let { chatMessages = [] } = $$props;
    	let { users = [] } = $$props;

    	// *** VARIBALES
    	let message = "";

    	let messageSent = false;
    	let recipient = "all";
    	console.dir(users);

    	const sendMessage = () => {
    		console.log(recipient + ": " + message);
    		dispatch("message", { message, recipient });
    		$$invalidate(2, messageSent = true);

    		setTimeout(
    			() => {
    				$$invalidate(2, messageSent = false);
    			},
    			5000
    		);
    	};

    	const writable_props = ["chatMessages", "users"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Textchat> was created with unknown prop '${key}'`);
    	});

    	function select_selected_binding(value) {
    		recipient = value;
    		$$invalidate(3, recipient);
    	}

    	function textarea_value_binding(value) {
    		message = value;
    		$$invalidate(4, message);
    	}

    	$$self.$$set = $$props => {
    		if ("chatMessages" in $$props) $$invalidate(0, chatMessages = $$props.chatMessages);
    		if ("users" in $$props) $$invalidate(1, users = $$props.users);
    	};

    	$$self.$capture_state = () => ({
    		Tabs,
    		Tab,
    		TabContent,
    		Tile,
    		Form,
    		FormGroup,
    		Select,
    		SelectItem,
    		Button,
    		TextArea,
    		InlineNotification,
    		createEventDispatcher,
    		dispatch,
    		ChatMessage,
    		chatMessages,
    		users,
    		message,
    		messageSent,
    		recipient,
    		sendMessage
    	});

    	$$self.$inject_state = $$props => {
    		if ("chatMessages" in $$props) $$invalidate(0, chatMessages = $$props.chatMessages);
    		if ("users" in $$props) $$invalidate(1, users = $$props.users);
    		if ("message" in $$props) $$invalidate(4, message = $$props.message);
    		if ("messageSent" in $$props) $$invalidate(2, messageSent = $$props.messageSent);
    		if ("recipient" in $$props) $$invalidate(3, recipient = $$props.recipient);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		chatMessages,
    		users,
    		messageSent,
    		recipient,
    		message,
    		sendMessage,
    		select_selected_binding,
    		textarea_value_binding
    	];
    }

    class Textchat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, { chatMessages: 0, users: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textchat",
    			options,
    			id: create_fragment$N.name
    		});
    	}

    	get chatMessages() {
    		throw new Error("<Textchat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chatMessages(value) {
    		throw new Error("<Textchat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get users() {
    		throw new Error("<Textchat>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set users(value) {
    		throw new Error("<Textchat>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Audiochat.svelte generated by Svelte v3.29.0 */
    const file$K = "src/Audiochat.svelte";

    // (13:0) <Tile>
    function create_default_slot_15$2(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Chatrooms (audio)";
    			add_location(h1, file$K, 13, 2, 235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15$2.name,
    		type: "slot",
    		source: "(13:0) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (27:6) <Tile>
    function create_default_slot_14$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 1");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14$2.name,
    		type: "slot",
    		source: "(27:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (26:4) <TabContent>
    function create_default_slot_13$2(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_14$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13$2.name,
    		type: "slot",
    		source: "(26:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (30:6) <Tile>
    function create_default_slot_12$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 2");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12$2.name,
    		type: "slot",
    		source: "(30:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (29:4) <TabContent>
    function create_default_slot_11$2(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_12$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11$2.name,
    		type: "slot",
    		source: "(29:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (33:6) <Tile>
    function create_default_slot_10$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 3");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10$2.name,
    		type: "slot",
    		source: "(33:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (32:4) <TabContent>
    function create_default_slot_9$2(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_10$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$2.name,
    		type: "slot",
    		source: "(32:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (36:6) <Tile>
    function create_default_slot_8$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 4");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$2.name,
    		type: "slot",
    		source: "(36:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (35:4) <TabContent>
    function create_default_slot_7$2(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_8$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(35:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (39:6) <Tile>
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 5");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(39:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (38:4) <TabContent>
    function create_default_slot_5$3(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_6$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(38:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (42:6) <Tile>
    function create_default_slot_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 6");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(42:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (41:4) <TabContent>
    function create_default_slot_3$4(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(41:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (45:6) <Tile>
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Audioroom 7");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(45:6) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (44:4) <TabContent>
    function create_default_slot_1$5(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(44:4) <TabContent>",
    		ctx
    	});

    	return block;
    }

    // (25:2) <div slot="content">
    function create_content_slot$1(ctx) {
    	let div;
    	let tabcontent0;
    	let t0;
    	let tabcontent1;
    	let t1;
    	let tabcontent2;
    	let t2;
    	let tabcontent3;
    	let t3;
    	let tabcontent4;
    	let t4;
    	let tabcontent5;
    	let t5;
    	let tabcontent6;
    	let current;

    	tabcontent0 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_13$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent1 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_11$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent2 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_9$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent3 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent4 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent5 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabcontent6 = new TabContent({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tabcontent0.$$.fragment);
    			t0 = space();
    			create_component(tabcontent1.$$.fragment);
    			t1 = space();
    			create_component(tabcontent2.$$.fragment);
    			t2 = space();
    			create_component(tabcontent3.$$.fragment);
    			t3 = space();
    			create_component(tabcontent4.$$.fragment);
    			t4 = space();
    			create_component(tabcontent5.$$.fragment);
    			t5 = space();
    			create_component(tabcontent6.$$.fragment);
    			attr_dev(div, "slot", "content");
    			add_location(div, file$K, 24, 2, 437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tabcontent0, div, null);
    			append_dev(div, t0);
    			mount_component(tabcontent1, div, null);
    			append_dev(div, t1);
    			mount_component(tabcontent2, div, null);
    			append_dev(div, t2);
    			mount_component(tabcontent3, div, null);
    			append_dev(div, t3);
    			mount_component(tabcontent4, div, null);
    			append_dev(div, t4);
    			mount_component(tabcontent5, div, null);
    			append_dev(div, t5);
    			mount_component(tabcontent6, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tabcontent0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent0_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent0.$set(tabcontent0_changes);
    			const tabcontent1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent1_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent1.$set(tabcontent1_changes);
    			const tabcontent2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent2_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent2.$set(tabcontent2_changes);
    			const tabcontent3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent3_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent3.$set(tabcontent3_changes);
    			const tabcontent4_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent4_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent4.$set(tabcontent4_changes);
    			const tabcontent5_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent5_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent5.$set(tabcontent5_changes);
    			const tabcontent6_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabcontent6_changes.$$scope = { dirty, ctx };
    			}

    			tabcontent6.$set(tabcontent6_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabcontent0.$$.fragment, local);
    			transition_in(tabcontent1.$$.fragment, local);
    			transition_in(tabcontent2.$$.fragment, local);
    			transition_in(tabcontent3.$$.fragment, local);
    			transition_in(tabcontent4.$$.fragment, local);
    			transition_in(tabcontent5.$$.fragment, local);
    			transition_in(tabcontent6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabcontent0.$$.fragment, local);
    			transition_out(tabcontent1.$$.fragment, local);
    			transition_out(tabcontent2.$$.fragment, local);
    			transition_out(tabcontent3.$$.fragment, local);
    			transition_out(tabcontent4.$$.fragment, local);
    			transition_out(tabcontent5.$$.fragment, local);
    			transition_out(tabcontent6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tabcontent0);
    			destroy_component(tabcontent1);
    			destroy_component(tabcontent2);
    			destroy_component(tabcontent3);
    			destroy_component(tabcontent4);
    			destroy_component(tabcontent5);
    			destroy_component(tabcontent6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot$1.name,
    		type: "slot",
    		source: "(25:2) <div slot=\\\"content\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:0) <Tabs type="container">
    function create_default_slot$6(ctx) {
    	let tab0;
    	let t0;
    	let tab1;
    	let t1;
    	let tab2;
    	let t2;
    	let tab3;
    	let t3;
    	let tab4;
    	let t4;
    	let tab5;
    	let t5;
    	let tab6;
    	let t6;
    	let current;
    	tab0 = new Tab({ props: { label: "1" }, $$inline: true });
    	tab1 = new Tab({ props: { label: "2" }, $$inline: true });
    	tab2 = new Tab({ props: { label: "3" }, $$inline: true });
    	tab3 = new Tab({ props: { label: "4" }, $$inline: true });
    	tab4 = new Tab({ props: { label: "5" }, $$inline: true });
    	tab5 = new Tab({ props: { label: "6" }, $$inline: true });
    	tab6 = new Tab({ props: { label: "7" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(tab0.$$.fragment);
    			t0 = space();
    			create_component(tab1.$$.fragment);
    			t1 = space();
    			create_component(tab2.$$.fragment);
    			t2 = space();
    			create_component(tab3.$$.fragment);
    			t3 = space();
    			create_component(tab4.$$.fragment);
    			t4 = space();
    			create_component(tab5.$$.fragment);
    			t5 = space();
    			create_component(tab6.$$.fragment);
    			t6 = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tab1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tab2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(tab3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(tab4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(tab5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(tab6, target, anchor);
    			insert_dev(target, t6, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab0.$$.fragment, local);
    			transition_in(tab1.$$.fragment, local);
    			transition_in(tab2.$$.fragment, local);
    			transition_in(tab3.$$.fragment, local);
    			transition_in(tab4.$$.fragment, local);
    			transition_in(tab5.$$.fragment, local);
    			transition_in(tab6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab0.$$.fragment, local);
    			transition_out(tab1.$$.fragment, local);
    			transition_out(tab2.$$.fragment, local);
    			transition_out(tab3.$$.fragment, local);
    			transition_out(tab4.$$.fragment, local);
    			transition_out(tab5.$$.fragment, local);
    			transition_out(tab6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tab1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tab2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(tab3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(tab4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(tab5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(tab6, detaching);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(17:0) <Tabs type=\\\"container\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let tile;
    	let t;
    	let tabs;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_15$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tabs = new Tabs({
    			props: {
    				type: "container",
    				$$slots: {
    					default: [create_default_slot$6],
    					content: [create_content_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    			t = space();
    			create_component(tabs.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(tabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    			const tabs_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				tabs_changes.$$scope = { dirty, ctx };
    			}

    			tabs.$set(tabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(tabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Audiochat", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Audiochat> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Tabs, Tab, TabContent, Tile });
    	return [];
    }

    class Audiochat extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Audiochat",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/VideoPlayer.svelte generated by Svelte v3.29.0 */
    const file$L = "src/VideoPlayer.svelte";

    // (39:2) {#if streamUrl.includes('vimeo')}
    function create_if_block$w(ctx) {
    	let div;
    	let iframe;
    	let iframe_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			iframe = element("iframe");
    			attr_dev(iframe, "width", "720");
    			attr_dev(iframe, "height", "480");
    			if (iframe.src !== (iframe_src_value = "https://player.vimeo.com/video/" + getVideoId(/*streamUrl*/ ctx[0]).id + "?autoplay=1")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "frameborder", "no");
    			attr_dev(iframe, "scrolling", "no");
    			attr_dev(iframe, "byline", "false");
    			attr_dev(iframe, "color", "#ffffff");
    			attr_dev(iframe, "allow", "autoplay; fullscreen");
    			iframe.allowFullscreen = true;
    			attr_dev(iframe, "class", "svelte-2si1ec");
    			add_location(iframe, file$L, 40, 6, 798);
    			attr_dev(div, "class", "vimeo-container svelte-2si1ec");
    			add_location(div, file$L, 39, 4, 762);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, iframe);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*streamUrl*/ 1 && iframe.src !== (iframe_src_value = "https://player.vimeo.com/video/" + getVideoId(/*streamUrl*/ ctx[0]).id + "?autoplay=1")) {
    				attr_dev(iframe, "src", iframe_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(39:2) {#if streamUrl.includes('vimeo')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let div;
    	let show_if = /*streamUrl*/ ctx[0].includes("vimeo");
    	let if_block = show_if && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "embed svelte-2si1ec");
    			add_location(div, file$L, 37, 0, 702);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*streamUrl*/ 1) show_if = /*streamUrl*/ ctx[0].includes("vimeo");

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VideoPlayer", slots, []);
    	let { streamUrl = "" } = $$props;
    	const writable_props = ["streamUrl"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VideoPlayer> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("streamUrl" in $$props) $$invalidate(0, streamUrl = $$props.streamUrl);
    	};

    	$$self.$capture_state = () => ({ getVideoId, streamUrl });

    	$$self.$inject_state = $$props => {
    		if ("streamUrl" in $$props) $$invalidate(0, streamUrl = $$props.streamUrl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [streamUrl];
    }

    class VideoPlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { streamUrl: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VideoPlayer",
    			options,
    			id: create_fragment$P.name
    		});
    	}

    	get streamUrl() {
    		throw new Error("<VideoPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set streamUrl(value) {
    		throw new Error("<VideoPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Livestreams.svelte generated by Svelte v3.29.0 */

    const file$M = "src/Livestreams.svelte";

    // (22:0) <Tile>
    function create_default_slot_2$5(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Active livestreams";
    			add_location(h1, file$M, 22, 2, 407);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(22:0) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (33:0) {:else}
    function create_else_block$7(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(33:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:0) {#if currentStream}
    function create_if_block$x(ctx) {
    	let tile;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tile_changes = {};

    			if (dirty & /*$$scope, currentStream*/ 3) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(26:0) {#if currentStream}",
    		ctx
    	});

    	return block;
    }

    // (34:2) <Tile>
    function create_default_slot_1$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No active live stream");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(34:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (27:2) <Tile>
    function create_default_slot$7(ctx) {
    	let div;
    	let videoplayer;
    	let t0;
    	let p;
    	let t1;
    	let t2_value = /*currentStream*/ ctx[0].title + "";
    	let t2;
    	let current;

    	videoplayer = new VideoPlayer({
    			props: {
    				streamUrl: /*currentStream*/ ctx[0].streamURL
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(videoplayer.$$.fragment);
    			t0 = space();
    			p = element("p");
    			t1 = text("Event: ");
    			t2 = text(t2_value);
    			attr_dev(div, "class", "video-container svelte-orrdh5");
    			add_location(div, file$M, 27, 4, 477);
    			add_location(p, file$M, 30, 4, 580);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(videoplayer, div, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const videoplayer_changes = {};
    			if (dirty & /*currentStream*/ 1) videoplayer_changes.streamUrl = /*currentStream*/ ctx[0].streamURL;
    			videoplayer.$set(videoplayer_changes);
    			if ((!current || dirty & /*currentStream*/ 1) && t2_value !== (t2_value = /*currentStream*/ ctx[0].title + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(videoplayer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(videoplayer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(videoplayer);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(27:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let tile;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	tile = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$x, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*currentStream*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(tile.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tile, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				tile_changes.$$scope = { dirty, ctx };
    			}

    			tile.$set(tile_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tile, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Livestreams", slots, []);
    	let { currentStream = false } = $$props;
    	const writable_props = ["currentStream"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Livestreams> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("currentStream" in $$props) $$invalidate(0, currentStream = $$props.currentStream);
    	};

    	$$self.$capture_state = () => ({ Tile, VideoPlayer, currentStream });

    	$$self.$inject_state = $$props => {
    		if ("currentStream" in $$props) $$invalidate(0, currentStream = $$props.currentStream);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [currentStream];
    }

    class Livestreams extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { currentStream: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Livestreams",
    			options,
    			id: create_fragment$Q.name
    		});
    	}

    	get currentStream() {
    		throw new Error("<Livestreams>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentStream(value) {
    		throw new Error("<Livestreams>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/AddressItem.svelte generated by Svelte v3.29.0 */

    const { console: console_1$2 } = globals;

    const file$N = "src/AddressItem.svelte";

    // (61:4) <Button size="small" kind="primary" on:click={removeFromBlackList}>
    function create_default_slot$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Unban IP address");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(61:4) <Button size=\\\"small\\\" kind=\\\"primary\\\" on:click={removeFromBlackList}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*address*/ ctx[0].address + "";
    	let t0;
    	let t1;
    	let div1;
    	let button;
    	let div2_transition;
    	let current;

    	button = new Button({
    			props: {
    				size: "small",
    				kind: "primary",
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*removeFromBlackList*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "marked svelte-ywbiu");
    			add_location(div0, file$N, 58, 2, 1175);
    			attr_dev(div1, "class", "svelte-ywbiu");
    			add_location(div1, file$N, 59, 2, 1221);
    			attr_dev(div2, "class", "address-item svelte-ywbiu");
    			add_location(div2, file$N, 57, 0, 1125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(button, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*address*/ 1) && t0_value !== (t0_value = /*address*/ ctx[0].address + "")) set_data_dev(t0, t0_value);
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(button);
    			if (detaching && div2_transition) div2_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $gameRoom;
    	validate_store(gameRoom, "gameRoom");
    	component_subscribe($$self, gameRoom, $$value => $$invalidate(3, $gameRoom = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("AddressItem", slots, []);
    	let { address = {} } = $$props;
    	let unbanned = false;

    	const removeFromBlackList = () => {
    		console.log(address.address);
    		$gameRoom.send("whitelist", { address: address.address });
    		unbanned = true;
    	};

    	const writable_props = ["address"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<AddressItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("address" in $$props) $$invalidate(0, address = $$props.address);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		Button,
    		Tag,
    		address,
    		unbanned,
    		gameRoom,
    		chatRoom,
    		removeFromBlackList,
    		$gameRoom
    	});

    	$$self.$inject_state = $$props => {
    		if ("address" in $$props) $$invalidate(0, address = $$props.address);
    		if ("unbanned" in $$props) unbanned = $$props.unbanned;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [address, removeFromBlackList];
    }

    class AddressItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, { address: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AddressItem",
    			options,
    			id: create_fragment$R.name
    		});
    	}

    	get address() {
    		throw new Error("<AddressItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set address(value) {
    		throw new Error("<AddressItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/Banned.svelte generated by Svelte v3.29.0 */
    const file$O = "src/Banned.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (20:2) <Tile>
    function create_default_slot_2$6(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "Banned IP addresses";
    			add_location(h1, file$O, 20, 4, 363);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(20:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (24:4) <Tag type="red">
    function create_default_slot_1$7(ctx) {
    	let t0;
    	let t1_value = /*blackList*/ ctx[0].length + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text("Banned IPs: ");
    			t1 = text(t1_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*blackList*/ 1 && t1_value !== (t1_value = /*blackList*/ ctx[0].length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(24:4) <Tag type=\\\"red\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:2) <Tile>
    function create_default_slot$9(ctx) {
    	let tag;
    	let current;

    	tag = new Tag({
    			props: {
    				type: "red",
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tag.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tag, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tag_changes = {};

    			if (dirty & /*$$scope, blackList*/ 17) {
    				tag_changes.$$scope = { dirty, ctx };
    			}

    			tag.$set(tag_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tag.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tag.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tag, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(23:2) <Tile>",
    		ctx
    	});

    	return block;
    }

    // (26:2) {#each blackList as address}
    function create_each_block$2(ctx) {
    	let addressitem;
    	let current;

    	addressitem = new AddressItem({
    			props: { address: /*address*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(addressitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(addressitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const addressitem_changes = {};
    			if (dirty & /*blackList*/ 1) addressitem_changes.address = /*address*/ ctx[1];
    			addressitem.$set(addressitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(addressitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(addressitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(addressitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(26:2) {#each blackList as address}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let div;
    	let tile0;
    	let t0;
    	let tile1;
    	let t1;
    	let current;

    	tile0 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tile1 = new Tile({
    			props: {
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*blackList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tile0.$$.fragment);
    			t0 = space();
    			create_component(tile1.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "users");
    			add_location(div, file$O, 18, 0, 330);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tile0, div, null);
    			append_dev(div, t0);
    			mount_component(tile1, div, null);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tile0_changes = {};

    			if (dirty & /*$$scope*/ 16) {
    				tile0_changes.$$scope = { dirty, ctx };
    			}

    			tile0.$set(tile0_changes);
    			const tile1_changes = {};

    			if (dirty & /*$$scope, blackList*/ 17) {
    				tile1_changes.$$scope = { dirty, ctx };
    			}

    			tile1.$set(tile1_changes);

    			if (dirty & /*blackList*/ 1) {
    				each_value = /*blackList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tile0.$$.fragment, local);
    			transition_in(tile1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tile0.$$.fragment, local);
    			transition_out(tile1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tile0);
    			destroy_component(tile1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Banned", slots, []);
    	let { blackList = [] } = $$props;
    	const writable_props = ["blackList"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Banned> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("blackList" in $$props) $$invalidate(0, blackList = $$props.blackList);
    	};

    	$$self.$capture_state = () => ({ Tile, Tag, AddressItem, blackList });

    	$$self.$inject_state = $$props => {
    		if ("blackList" in $$props) $$invalidate(0, blackList = $$props.blackList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [blackList];
    }

    class Banned extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { blackList: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Banned",
    			options,
    			id: create_fragment$S.name
    		});
    	}

    	get blackList() {
    		throw new Error("<Banned>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set blackList(value) {
    		throw new Error("<Banned>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/App.svelte generated by Svelte v3.29.0 */

    const { console: console_1$3 } = globals;

    const file$P = "src/App.svelte";

    // (180:4) <div slot="skip-to-content">
    function create_skip_to_content_slot(ctx) {
    	let div;
    	let skiptocontent;
    	let current;
    	skiptocontent = new SkipToContent({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(skiptocontent.$$.fragment);
    			attr_dev(div, "slot", "skip-to-content");
    			attr_dev(div, "class", "svelte-1kacku4");
    			add_location(div, file$P, 179, 4, 4589);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(skiptocontent, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(skiptocontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(skiptocontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(skiptocontent);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_skip_to_content_slot.name,
    		type: "slot",
    		source: "(180:4) <div slot=\\\"skip-to-content\\\">",
    		ctx
    	});

    	return block;
    }

    // (183:4) <HeaderNav>
    function create_default_slot_9$3(ctx) {
    	let headernavitem0;
    	let t0;
    	let headernavitem1;
    	let t1;
    	let headernavitem2;
    	let t2;
    	let headernavitem3;
    	let t3;
    	let headernavitem4;
    	let current;

    	headernavitem0 = new HeaderNavItem({
    			props: { href: "/", text: "Dashboard" },
    			$$inline: true
    		});

    	headernavitem1 = new HeaderNavItem({
    			props: { href: "/users", text: "Users" },
    			$$inline: true
    		});

    	headernavitem2 = new HeaderNavItem({
    			props: { href: "/banned", text: "Banned" },
    			$$inline: true
    		});

    	headernavitem3 = new HeaderNavItem({
    			props: {
    				href: "/livestreams",
    				text: "Livestreams"
    			},
    			$$inline: true
    		});

    	headernavitem4 = new HeaderNavItem({
    			props: { href: "/textchat", text: "Textchat" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(headernavitem0.$$.fragment);
    			t0 = space();
    			create_component(headernavitem1.$$.fragment);
    			t1 = space();
    			create_component(headernavitem2.$$.fragment);
    			t2 = space();
    			create_component(headernavitem3.$$.fragment);
    			t3 = space();
    			create_component(headernavitem4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(headernavitem0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(headernavitem1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(headernavitem2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(headernavitem3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(headernavitem4, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headernavitem0.$$.fragment, local);
    			transition_in(headernavitem1.$$.fragment, local);
    			transition_in(headernavitem2.$$.fragment, local);
    			transition_in(headernavitem3.$$.fragment, local);
    			transition_in(headernavitem4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headernavitem0.$$.fragment, local);
    			transition_out(headernavitem1.$$.fragment, local);
    			transition_out(headernavitem2.$$.fragment, local);
    			transition_out(headernavitem3.$$.fragment, local);
    			transition_out(headernavitem4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(headernavitem0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(headernavitem1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(headernavitem2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(headernavitem3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(headernavitem4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9$3.name,
    		type: "slot",
    		source: "(183:4) <HeaderNav>",
    		ctx
    	});

    	return block;
    }

    // (179:2) <Header company="HkW" platformName="The Shape of a Practice">
    function create_default_slot_8$3(ctx) {
    	let t;
    	let headernav;
    	let current;

    	headernav = new HeaderNav({
    			props: {
    				$$slots: { default: [create_default_slot_9$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			create_component(headernav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			mount_component(headernav, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const headernav_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				headernav_changes.$$scope = { dirty, ctx };
    			}

    			headernav.$set(headernav_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headernav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headernav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			destroy_component(headernav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$3.name,
    		type: "slot",
    		source: "(179:2) <Header company=\\\"HkW\\\" platformName=\\\"The Shape of a Practice\\\">",
    		ctx
    	});

    	return block;
    }

    // (195:6) <Route path="/">
    function create_default_slot_7$3(ctx) {
    	let dashboard;
    	let current;

    	dashboard = new Dashboard({
    			props: {
    				users: /*users*/ ctx[0],
    				blackList: /*blackList*/ ctx[1],
    				chatMessages: /*chatMessages*/ ctx[2],
    				currentStream: /*currentStream*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dashboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dashboard_changes = {};
    			if (dirty & /*users*/ 1) dashboard_changes.users = /*users*/ ctx[0];
    			if (dirty & /*blackList*/ 2) dashboard_changes.blackList = /*blackList*/ ctx[1];
    			if (dirty & /*chatMessages*/ 4) dashboard_changes.chatMessages = /*chatMessages*/ ctx[2];
    			if (dirty & /*currentStream*/ 8) dashboard_changes.currentStream = /*currentStream*/ ctx[3];
    			dashboard.$set(dashboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$3.name,
    		type: "slot",
    		source: "(195:6) <Route path=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }
    function create_catch_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block_1.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (198:31)          <Route path="/users">           <Users {users}
    function create_then_block_1(ctx) {
    	let route;
    	let current;

    	route = new Route({
    			props: {
    				path: "/users",
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route_changes = {};

    			if (dirty & /*$$scope, users*/ 16385) {
    				route_changes.$$scope = { dirty, ctx };
    			}

    			route.$set(route_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block_1.name,
    		type: "then",
    		source: "(198:31)          <Route path=\\\"/users\\\">           <Users {users}",
    		ctx
    	});

    	return block;
    }

    // (199:8) <Route path="/users">
    function create_default_slot_6$3(ctx) {
    	let users_1;
    	let current;

    	users_1 = new Users({
    			props: {
    				users: /*users*/ ctx[0],
    				areas: /*areas*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(users_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(users_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const users_1_changes = {};
    			if (dirty & /*users*/ 1) users_1_changes.users = /*users*/ ctx[0];
    			users_1.$set(users_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(users_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(users_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(users_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(199:8) <Route path=\\\"/users\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }
    function create_pending_block_1(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block_1.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (203:6) <Route path="/banned">
    function create_default_slot_5$4(ctx) {
    	let banned;
    	let current;

    	banned = new Banned({
    			props: { blackList: /*blackList*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(banned.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(banned, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const banned_changes = {};
    			if (dirty & /*blackList*/ 2) banned_changes.blackList = /*blackList*/ ctx[1];
    			banned.$set(banned_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(banned.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(banned.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(banned, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(203:6) <Route path=\\\"/banned\\\">",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }
    function create_catch_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_catch_block.name,
    		type: "catch",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (207:39)            <Textchat {chatMessages}
    function create_then_block(ctx) {
    	let textchat;
    	let current;

    	textchat = new Textchat({
    			props: {
    				chatMessages: /*chatMessages*/ ctx[2],
    				users: /*userList*/ ctx[7]
    			},
    			$$inline: true
    		});

    	textchat.$on("message", /*message_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(textchat.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textchat, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textchat_changes = {};
    			if (dirty & /*chatMessages*/ 4) textchat_changes.chatMessages = /*chatMessages*/ ctx[2];
    			textchat.$set(textchat_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textchat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textchat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textchat, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_then_block.name,
    		type: "then",
    		source: "(207:39)            <Textchat {chatMessages}",
    		ctx
    	});

    	return block;
    }

    // (1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }
    function create_pending_block(ctx) {
    	const block = {
    		c: noop,
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_pending_block.name,
    		type: "pending",
    		source: "(1:0) <script>   // # # # # # # # # # # # # #   //   //  TSoaP Moderator   //   // # # # # # # # # # # # # #    // IMPORTS   import { onMount }",
    		ctx
    	});

    	return block;
    }

    // (206:6) <Route path="/textchat">
    function create_default_slot_4$4(ctx) {
    	let await_block_anchor;
    	let promise;
    	let current;

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 7,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*userList*/ ctx[7], info);

    	const block = {
    		c: function create() {
    			await_block_anchor = empty();
    			info.block.c();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, await_block_anchor, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => await_block_anchor.parentNode;
    			info.anchor = await_block_anchor;
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[7] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.block);
    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(await_block_anchor);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(206:6) <Route path=\\\"/textchat\\\">",
    		ctx
    	});

    	return block;
    }

    // (226:6) <Route path="/audiochat">
    function create_default_slot_3$5(ctx) {
    	let audiochat;
    	let current;
    	audiochat = new Audiochat({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(audiochat.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(audiochat, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(audiochat.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(audiochat.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(audiochat, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(226:6) <Route path=\\\"/audiochat\\\">",
    		ctx
    	});

    	return block;
    }

    // (229:6) <Route path="/livestreams">
    function create_default_slot_2$7(ctx) {
    	let livestreams;
    	let current;

    	livestreams = new Livestreams({
    			props: { currentStream: /*currentStream*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(livestreams.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(livestreams, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const livestreams_changes = {};
    			if (dirty & /*currentStream*/ 8) livestreams_changes.currentStream = /*currentStream*/ ctx[3];
    			livestreams.$set(livestreams_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(livestreams.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(livestreams.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(livestreams, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(229:6) <Route path=\\\"/livestreams\\\">",
    		ctx
    	});

    	return block;
    }

    // (194:4) <Router>
    function create_default_slot_1$8(ctx) {
    	let route0;
    	let t0;
    	let promise;
    	let t1;
    	let route1;
    	let t2;
    	let route2;
    	let t3;
    	let route3;
    	let t4;
    	let route4;
    	let current;

    	route0 = new Route({
    			props: {
    				path: "/",
    				$$slots: { default: [create_default_slot_7$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		hasCatch: false,
    		pending: create_pending_block_1,
    		then: create_then_block_1,
    		catch: create_catch_block_1,
    		value: 6,
    		blocks: [,,,]
    	};

    	handle_promise(promise = /*areas*/ ctx[6], info);

    	route1 = new Route({
    			props: {
    				path: "/banned",
    				$$slots: { default: [create_default_slot_5$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "/textchat",
    				$$slots: { default: [create_default_slot_4$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "/audiochat",
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route4 = new Route({
    			props: {
    				path: "/livestreams",
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route0.$$.fragment);
    			t0 = space();
    			info.block.c();
    			t1 = space();
    			create_component(route1.$$.fragment);
    			t2 = space();
    			create_component(route2.$$.fragment);
    			t3 = space();
    			create_component(route3.$$.fragment);
    			t4 = space();
    			create_component(route4.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route0, target, anchor);
    			insert_dev(target, t0, anchor);
    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => t1.parentNode;
    			info.anchor = t1;
    			insert_dev(target, t1, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(route3, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(route4, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const route0_changes = {};

    			if (dirty & /*$$scope, users, blackList, chatMessages, currentStream*/ 16399) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);

    			{
    				const child_ctx = ctx.slice();
    				child_ctx[6] = info.resolved;
    				info.block.p(child_ctx, dirty);
    			}

    			const route1_changes = {};

    			if (dirty & /*$$scope, blackList*/ 16386) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope, chatMessages, $gameRoom*/ 16404) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    			const route4_changes = {};

    			if (dirty & /*$$scope, currentStream*/ 16392) {
    				route4_changes.$$scope = { dirty, ctx };
    			}

    			route4.$set(route4_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(info.block);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t0);
    			info.block.d(detaching);
    			info.token = null;
    			info = null;
    			if (detaching) detach_dev(t1);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(route3, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(route4, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(194:4) <Router>",
    		ctx
    	});

    	return block;
    }

    // (193:2) <Content>
    function create_default_slot$a(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};

    			if (dirty & /*$$scope, currentStream, chatMessages, $gameRoom, blackList, users*/ 16415) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(193:2) <Content>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let div;
    	let header;
    	let t;
    	let content;
    	let links_action;
    	let current;
    	let mounted;
    	let dispose;

    	header = new Header({
    			props: {
    				company: "HkW",
    				platformName: "The Shape of a Practice",
    				$$slots: {
    					default: [create_default_slot_8$3],
    					"skip-to-content": [create_skip_to_content_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	content = new Content({
    			props: {
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(header.$$.fragment);
    			t = space();
    			create_component(content.$$.fragment);
    			attr_dev(div, "class", "svelte-1kacku4");
    			add_location(div, file$P, 177, 0, 4505);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(header, div, null);
    			append_dev(div, t);
    			mount_component(content, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(links_action = links.call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const header_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				header_changes.$$scope = { dirty, ctx };
    			}

    			header.$set(header_changes);
    			const content_changes = {};

    			if (dirty & /*$$scope, currentStream, chatMessages, $gameRoom, blackList, users*/ 16415) {
    				content_changes.$$scope = { dirty, ctx };
    			}

    			content.$set(content_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(content.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(content.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(header);
    			destroy_component(content);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let $gameRoom;
    	validate_store(gameRoom, "gameRoom");
    	component_subscribe($$self, gameRoom, $$value => $$invalidate(4, $gameRoom = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	const chance = new chance_1();
    	let users = {};
    	let blackList = [];
    	let chatMessages = [];

    	// *** COLYSEUS
    	const gameClient = new lib$4.Client("wss://gameserver.tsoap.dev");

    	// *** SANITY
    	const areas = loadData(QUERY.AREAS).catch(err => {
    		console.log(err);
    	});

    	const audioRoomNames = loadData(QUERY.AUDIOROOM_NAMES).catch(err => {
    		console.log(err);
    	});

    	const userList = loadData(QUERY.USERS).catch(err => {
    		console.log(err);
    	});

    	let currentStream = false;

    	let activeStreams = loadData(QUERY.ACTIVE_STREAMS).catch(err => {
    		console.log(err);
    	}).then(activeStreams => {
    		$$invalidate(3, currentStream = activeStreams.mainStream);
    	});

    	// __ Listen for changes to the active streams post
    	client.listen(QUERY.ACTIVE_STREAMS).subscribe(update => {
    		$$invalidate(3, currentStream = false);

    		setTimeout(
    			() => {
    				activeStreams = loadData(QUERY.ACTIVE_STREAMS).then(aS => {
    					if (aS.mainStream) {
    						$$invalidate(3, currentStream = aS.mainStream);
    					} else {
    						$$invalidate(3, currentStream = false);
    					}
    				}).catch(err => {
    					console.log(err);
    				});
    			},
    			1000
    		);
    	});

    	// FUNCTIONS
    	let submitChat = () => {
    		
    	};

    	// CREATE PLAYER
    	const createPlayer = (player, sessionId) => {
    		let avatar = {};
    		avatar.x = player.x;
    		avatar.y = player.y;
    		avatar.waypoints = [];
    		avatar.area = player.area;
    		avatar.tint = player.tint;
    		avatar.name = player.name;
    		avatar.uuid = player.uuid;
    		avatar.ip = player.ip;
    		avatar.connected = player.connected;
    		avatar.authenticated = player.authenticated;
    		avatar.npc = player.npc;
    		avatar.carrying = player.carrying;
    		avatar.id = sessionId;
    		return avatar;
    	};

    	onMount(async () => {
    		// => GAME ROOM
    		gameRoom.set(await gameClient.joinOrCreate("game", {
    			moderator: true,
    			uuid: chance.guid(),
    			name: "Moderator",
    			avatar: 0,
    			tint: "0x000000"
    		}));

    		// PLAYER: REMOVE
    		set_store_value(
    			gameRoom,
    			$gameRoom.state.players.onRemove = function (player, sessionId) {
    				// console.log("REMOVE")
    				// console.dir(users[sessionId])
    				delete users[sessionId];

    				// FORCE RENDER
    				$$invalidate(0, users);
    			},
    			$gameRoom
    		);

    		// PLAYER: ADD
    		set_store_value(
    			gameRoom,
    			$gameRoom.state.players.onAdd = function (player, sessionId) {
    				$$invalidate(0, users[sessionId] = createPlayer(player, sessionId), users);

    				// PLAYER: STATE CHANGE
    				player.onChange = changes => {
    					$$invalidate(0, users[sessionId].x = player.x, users);
    					$$invalidate(0, users[sessionId].y = player.y, users);
    					$$invalidate(0, users[sessionId].area = player.area, users);
    					$$invalidate(0, users[sessionId].carrying = player.carrying, users);
    				};
    			},
    			$gameRoom
    		);

    		// BLACKLIST: ADD
    		set_store_value(
    			gameRoom,
    			$gameRoom.state.blacklist.onAdd = function (bannedIP, sessionId) {
    				$$invalidate(1, blackList = [...blackList, bannedIP]);
    			},
    			$gameRoom
    		);

    		// BLACKLIST: REMOVE
    		set_store_value(
    			gameRoom,
    			$gameRoom.state.blacklist.onRemove = function (unBannedIP, sessionId) {
    				$$invalidate(1, blackList = blackList.filter(ip => ip.address !== unBannedIP.address));
    			},
    			$gameRoom
    		);

    		// GAME ROOM: ERROR
    		$gameRoom.onError((code, message) => {
    			console.error("!!! COLYSEUS ERROR:");
    			console.error(message);
    		});

    		// CHAT: ADD
    		set_store_value(
    			gameRoom,
    			$gameRoom.state.messages.onAdd = message => {
    				$$invalidate(2, chatMessages = [message, ...chatMessages]);
    			},
    			$gameRoom
    		);

    		$gameRoom.onMessage("nukeMessage", msgIdToRemove => {
    			// console.log("!!!! MESGS")
    			// console.dir(msgIdToRemove)
    			const itemIndex = chatMessages.findIndex(m => m.msgId === msgIdToRemove);

    			// console.log(itemIndex)
    			// console.dir(chatMessages[itemIndex])
    			chatMessages.splice(itemIndex, 1);

    			$$invalidate(2, chatMessages);
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const message_handler = event => {
    		console.dir(event.detail);

    		$gameRoom.send("submitChatMessage", {
    			msgId: chance.guid(),
    			uuid: chance.guid(),
    			directed: true,
    			directedTo: get_1(event, "detail.recipient", ""),
    			name: "Moderator",
    			username: "moderator",
    			authenticated: false,
    			room: 1,
    			text: get_1(event, "detail.message", "")
    		});
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		Colyseus,
    		get: get_1,
    		loadData,
    		client,
    		Router,
    		Route,
    		links,
    		Header,
    		HeaderNav,
    		HeaderNavItem,
    		SkipToContent,
    		Content,
    		Chance: chance_1,
    		chance,
    		Dashboard,
    		Users,
    		Textchat,
    		Audiochat,
    		Livestreams,
    		Banned,
    		users,
    		blackList,
    		chatMessages,
    		gameRoom,
    		QUERY,
    		gameClient,
    		areas,
    		audioRoomNames,
    		userList,
    		currentStream,
    		activeStreams,
    		submitChat,
    		createPlayer,
    		$gameRoom
    	});

    	$$self.$inject_state = $$props => {
    		if ("users" in $$props) $$invalidate(0, users = $$props.users);
    		if ("blackList" in $$props) $$invalidate(1, blackList = $$props.blackList);
    		if ("chatMessages" in $$props) $$invalidate(2, chatMessages = $$props.chatMessages);
    		if ("currentStream" in $$props) $$invalidate(3, currentStream = $$props.currentStream);
    		if ("activeStreams" in $$props) activeStreams = $$props.activeStreams;
    		if ("submitChat" in $$props) submitChat = $$props.submitChat;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		users,
    		blackList,
    		chatMessages,
    		currentStream,
    		$gameRoom,
    		chance,
    		areas,
    		userList,
    		message_handler
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    const app = new App({
    	target: document.body,
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
